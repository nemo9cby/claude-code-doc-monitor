<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>agents-and-tools/tool-use/programmatic-tool-calling - Diff Report</title>
    <link rel="stylesheet" href="../../css/diff.css">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --card-bg: #16213e;
            --text-color: #eee;
            --accent: #0f3460;
            --add-bg: #1a4d1a;
            --del-bg: #4d1a1a;
            --add-text: #4ade80;
            --del-text: #f87171;
        }
        @media (prefers-color-scheme: light) {
            :root {
                --bg-color: #f5f5f5;
                --card-bg: #fff;
                --text-color: #333;
                --accent: #e0e0e0;
                --add-bg: #d4edda;
                --del-bg: #f8d7da;
                --add-text: #155724;
                --del-text: #721c24;
            }
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 2rem;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        header { margin-bottom: 2rem; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .meta { color: #888; font-size: 0.9rem; }
        .summary {
            background: var(--card-bg);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            display: flex;
            gap: 2rem;
        }
        .stat { display: flex; align-items: center; gap: 0.5rem; }
        .stat.added { color: var(--add-text); }
        .stat.removed { color: var(--del-text); }
        .analysis {
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            border-left: 4px solid #8b5cf6;
        }
        .analysis-header {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #8b5cf6;
        }
        .analysis-content {
            white-space: pre-wrap;
            font-size: 0.95rem;
            line-height: 1.7;
        }
        .diff-container {
            background: var(--card-bg);
            border-radius: 8px;
            overflow: hidden;
        }
        .diff-header {
            background: var(--accent);
            padding: 0.75rem 1rem;
            font-weight: 600;
        }
        .diff-content {
            padding: 1rem;
            overflow-x: auto;
        }
        .diff-content ins {
            background: var(--add-bg);
            color: var(--add-text);
            text-decoration: none;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        .diff-content del {
            background: var(--del-bg);
            color: var(--del-text);
            text-decoration: line-through;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        pre {
            background: var(--accent);
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.85rem;
            margin-top: 2rem;
        }
        a { color: #60a5fa; }
        .back-link { margin-bottom: 1rem; display: inline-block; }
    </style>
</head>
<body>
    <div class="container">
        <a href="../../../index.html" class="back-link">&larr; Back to daily report</a>

        <header>
            <h1>agents-and-tools/tool-use/programmatic-tool-calling.md</h1>
            <p class="meta">Changed on 2026-02-23 15:39:16 EST</p>
        </header>

        <div class="summary">
            <div class="stat added">
                <span>+3</span> lines added
            </div>
            <div class="stat removed">
                <span>-1</span> lines removed
            </div>
        </div>

        

        <div class="diff-container">
            <div class="diff-header">Visual Diff</div>
            <div class="diff-content"><span># Programmatic tool calling&para;<br>&para;<br>---&para;<br>&para;<br>Programmatic tool calling allows Claude to write code that calls your tools programmatically within a [code execution](/docs/en/agents-and-tools/tool-use/code-execution-tool) container, rather than requiring round trips through the model for each tool invocation. This reduces latency for multi-tool workflows and decreases token consumption by allowing Claude to filter or process data before it reaches the model's context window.</span><ins style="background:#e6ffe6;"> On agentic search benchmarks like [BrowseComp](https://arxiv.org/abs/2504.12516) and [DeepSearchQA](https://github.com/google-deepmind/deepsearchqa), which test multi-step web research and complex information retrieval, adding programmatic tool calling on top of basic search tools was the key factor that fully unlocked agent performance.&para;<br>&para;<br>The difference compounds fast in real workflows. Consider checking budget compliance across 20 employees: the traditional approach requires 20 separate model round-trips, pulling thousands of expense line items into the context along the way. With programmatic tool calling, a single script runs all 20 lookups, filters the results, and returns only the employees who exceeded their limits, shrinking what Claude needs to reason over from hundreds of kilobytes down to a handful of lines.&para;<br>&para;<br>&lt;Tip&gt;&para;<br>For a deeper look at the inference and context costs that programmatic tool calling addresses, see [Advanced tool use](https://www.anthropic.com/engineering/advanced-tool-use).&para;<br>&lt;/Tip&gt;</ins><span>&para;<br>&para;<br>&lt;Note&gt;&para;<br>This feature requires the code execution tool to be enabled.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>&lt;Note&gt;&para;<br>This feature is **not** covered by [Zero Data Retention (ZDR)](/docs/en/build-with-claude/zero-data-retention) arrangements. Data is retained according to the feature's standard retention policy.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>## Model compatibility&para;<br>&para;<br>Programmatic tool calling is available on the following models:&para;<br>&para;<br>| Model | Tool Version |&para;<br>|-------|--------------|&para;<br>| Claude Opus 4.6 (`claude-opus-4-6`) | `code_execution_20260120` |&para;<br>| Claude Sonnet 4.6 (`claude-sonnet-4-6`) | `code_execution_20260120` |&para;<br>| Claude Sonnet 4.5 (`claude-sonnet-4-5-20250929`) | `code_execution_20260120` |&para;<br>| Claude Opus 4.5 (`claude-opus-4-5-20251101`) | `code_execution_20260120` |&para;<br>&para;<br>&lt;Warning&gt;&para;<br>Programmatic tool calling is available via the Claude API and Microsoft Foundry.&para;<br>&lt;/Warning&gt;&para;<br>&para;<br>## Quick start&para;<br>&para;<br>Here's a simple example where Claude programmatically queries a database multiple times and aggregates results:&para;<br>&para;<br>&lt;CodeGroup&gt;&para;<br>```bash Shell&para;<br>curl https://api.anthropic.com/v1/messages \&para;<br>    --header "x-api-key: $ANTHROPIC_API_KEY" \&para;<br>    --header "anthropic-version: 2023-06-01" \&para;<br>    --header "content-type: application/json" \&para;<br>    --data '{&para;<br>        "model": "claude-opus-4-6",&para;<br>        "max_tokens": 4096,&para;<br>        "messages": [&para;<br>            {&para;<br>                "role": "user",&para;<br>                "content": "Query sales data for the West, East, and Central regions, then tell me which region had the highest revenue"&para;<br>            }&para;<br>        ],&para;<br>        "tools": [&para;<br>            {&para;<br>                "type": "code_execution_20260120",&para;<br>                "name": "code_execution"&para;<br>            },&para;<br>            {&para;<br>                "name": "query_database",&para;<br>                "description": "Execute a SQL query against the sales database. Returns a list of rows as JSON objects.",&para;<br>                "input_schema": {&para;<br>                    "type": "object",&para;<br>                    "properties": {&para;<br>                        "sql": {&para;<br>                            "type": "string",&para;<br>                            "description": "SQL query to execute"&para;<br>                        }&para;<br>                    },&para;<br>                    "required": ["sql"]&para;<br>                },&para;<br>                "allowed_callers": ["code_execution_20260120"]&para;<br>            }&para;<br>        ]&para;<br>    }'&para;<br>```&para;<br>&para;<br>```python Python&para;<br>import anthropic&para;<br>&para;<br>client = anthropic.Anthropic()&para;<br>&para;<br>response = client.messages.create(&para;<br>    model="claude-opus-4-6",&para;<br>    max_tokens=4096,&para;<br>    messages=[&para;<br>        {&para;<br>            "role": "user",&para;<br>            "content": "Query sales data for the West, East, and Central regions, then tell me which region had the highest revenue",&para;<br>        }&para;<br>    ],&para;<br>    tools=[&para;<br>        {"type": "code_execution_20260120", "name": "code_execution"},&para;<br>        {&para;<br>            "name": "query_database",&para;<br>            "description": "Execute a SQL query against the sales database. Returns a list of rows as JSON objects.",&para;<br>            "input_schema": {&para;<br>                "type": "object",&para;<br>                "properties": {&para;<br>                    "sql": {"type": "string", "description": "SQL query to execute"}&para;<br>                },&para;<br>                "required": ["sql"],&para;<br>            },&para;<br>            "allowed_callers": ["code_execution_20260120"],&para;<br>        },&para;<br>    ],&para;<br>)&para;<br>&para;<br>print(response)&para;<br>```&para;<br>&para;<br>```typescript TypeScript&para;<br>import { Anthropic } from "@anthropic-ai/sdk";&para;<br>&para;<br>const anthropic = new Anthropic();&para;<br>&para;<br>async function main() {&para;<br>  const response = await anthropic.messages.create({&para;<br>    model: "claude-opus-4-6",&para;<br>    max_tokens: 4096,&para;<br>    messages: [&para;<br>      {&para;<br>        role: "user",&para;<br>        content: "Query sales data for the West, East, and Central regions, then tell me which region had the highest revenue"&para;<br>      }&para;<br>    ],&para;<br>    tools: [&para;<br>      {&para;<br>        type: "code_execution_20260120",&para;<br>        name: "code_execution"&para;<br>      },&para;<br>      {&para;<br>        name: "query_database",&para;<br>        description: "Execute a SQL query against the sales database. Returns a list of rows as JSON objects.",&para;<br>        input_schema: {&para;<br>          type: "object",&para;<br>          properties: {&para;<br>            sql: {&para;<br>              type: "string",&para;<br>              description: "SQL query to execute"&para;<br>            }&para;<br>          },&para;<br>          required: ["sql"]&para;<br>        },&para;<br>        allowed_callers: ["code_execution_20260120"]&para;<br>      }&para;<br>    ]&para;<br>  });&para;<br>&para;<br>  console.log(response);&para;<br>}&para;<br>&para;<br>main().catch(console.error);&para;<br>```&para;<br>&lt;/CodeGroup&gt;&para;<br>&para;<br>## How programmatic tool calling works&para;<br>&para;<br>When you configure a tool to be callable from code execution and Claude decides to use that tool:&para;<br>&para;<br>1. Claude writes Python code that invokes the tool as a function, potentially including multiple tool calls and pre/post-processing logic&para;<br>2. Claude runs this code in a sandboxed container via code execution&para;<br>3. When a tool function is called, code execution pauses and the API returns a `tool_use` block&para;<br>4. You provide the tool result, and code execution continues (intermediate results are not loaded into Claude's context window)&para;<br>5. Once all code execution completes, Claude receives the final output and continues working on the task&para;<br>&para;<br>This approach is particularly useful for:&para;<br>- **Large data processing**: Filter or aggregate tool results before they reach Claude's context&para;<br>- **Multi-step workflows**: Save tokens and latency by calling tools serially or in a loop without sampling Claude in-between tool calls&para;<br>- **Conditional logic**: Make decisions based on intermediate tool results&para;<br>&para;<br>&lt;Note&gt;&para;<br>Custom tools are converted to async Python functions to support parallel tool calling. When Claude writes code that calls your tools, it uses `await` (e.g., `result = await query_database("&lt;sql&gt;")`) and automatically includes the appropriate async wrapper function.&para;<br>&para;<br>The async wrapper is omitted from code examples in this documentation for clarity.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>## Core concepts&para;<br>&para;<br>### The `allowed_callers` field&para;<br>&para;<br>The `allowed_callers` field specifies which contexts can invoke a tool:&para;<br>&para;<br>```json&para;<br>{&para;<br>  "name": "query_database",&para;<br>  "description": "Execute a SQL query against the database",&para;<br>  "input_schema": {...},&para;<br>  "allowed_callers": ["code_execution_20260120"]&para;<br>}&para;<br>```&para;<br>&para;<br>**Possible values:**&para;<br>- `["direct"]` - Only Claude can call this tool directly (default if omitted)&para;<br>- `["code_execution_20260120"]` - Only callable from within code execution&para;<br>- `["direct", "code_execution_20260120"]` - Callable both directly and from code execution&para;<br>&para;<br>&lt;Tip&gt;&para;<br>Choose either `["direct"]` or `["code_execution_20260120"]` for each tool rather than enabling both, as this provides clearer guidance to Claude for how best to use the tool.&para;<br>&lt;/Tip&gt;&para;<br>&para;<br>### The `caller` field in responses&para;<br>&para;<br>Every tool use block includes a `caller` field indicating how it was invoked:&para;<br>&para;<br>**Direct invocation (traditional tool use):**&para;<br>```json&para;<br>{&para;<br>  "type": "tool_use",&para;<br>  "id": "toolu_abc123",&para;<br>  "name": "query_database",&para;<br>  "input": {"sql": "&lt;sql&gt;"},&para;<br>  "caller": {"type": "direct"}&para;<br>}&para;<br>```&para;<br>&para;<br>**Programmatic invocation:**&para;<br>```json&para;<br>{&para;<br>  "type": "tool_use",&para;<br>  "id": "toolu_xyz789",&para;<br>  "name": "query_database",&para;<br>  "input": {"sql": "&lt;sql&gt;"},&para;<br>  "caller": {&para;<br>    "type": "code_execution_20260120",&para;<br>    "tool_id": "srvtoolu_abc123"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>The `tool_id` references the code execution tool that made the programmatic call.&para;<br>&para;<br>### Container lifecycle&para;<br>&para;<br>Programmatic tool calling uses the same containers as code execution:&para;<br>&para;<br>- **Container creation**: A new container is created for each session unless you reuse an existing one&para;<br>- **Expiration**: Containers expire after approximately 4.5 minutes of inactivity (subject to change)&para;<br>- **Container ID**: Returned in responses via the `container` field&para;<br>- **Reuse**: Pass the container ID to maintain state across requests&para;<br>&para;<br>&lt;Warning&gt;&para;<br>When a tool is called programmatically and the container is waiting for your tool result, you must respond before the container expires. Monitor the `expires_at` field. If the container expires, Claude may treat the tool call as timed out and retry it.&para;<br>&lt;/Warning&gt;&para;<br>&para;<br>## Example workflow&para;<br>&para;<br>Here's how a complete programmatic tool calling flow works:&para;<br>&para;<br>### Step 1: Initial request&para;<br>&para;<br>Send a request with code execution and a tool that allows programmatic calling. To enable programmatic calling, add the `allowed_callers` field to your tool definition.&para;<br>&para;<br>&lt;Note&gt;&para;<br>Provide detailed descriptions of your tool's output format in the tool description. If you specify that the tool returns JSON, Claude will attempt to deserialize and process the result in code. The more detail you provide about the output schema, the better Claude can handle the response programmatically.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>&lt;CodeGroup&gt;&para;<br>```python Python&para;<br>response = client.messages.create(&para;<br>    model="claude-opus-4-6",&para;<br>    max_tokens=4096,&para;<br>    messages=[&para;<br>        {&para;<br>            "role": "user",&para;<br>            "content": "Query customer purchase history from the last quarter and identify our top 5 customers by revenue",&para;<br>        }&para;<br>    ],&para;<br>    tools=[&para;<br>        {"type": "code_execution_20260120", "name": "code_execution"},&para;<br>        {&para;<br>            "name": "query_database",&para;<br>            "description": "Execute a SQL query against the sales database. Returns a list of rows as JSON objects.",&para;<br>            "input_schema": {...},&para;<br>            "allowed_callers": ["code_execution_20260120"],&para;<br>        },&para;<br>    ],&para;<br>)&para;<br>```&para;<br>&para;<br>```typescript TypeScript&para;<br>const response = await anthropic.messages.create({&para;<br>  model: "claude-opus-4-6",&para;<br>  max_tokens: 4096,&para;<br>  messages: [{&para;<br>    role: "user",&para;<br>    content: "Query customer purchase history from the last quarter and identify our top 5 customers by revenue"&para;<br>  }],&para;<br>  tools: [&para;<br>    {&para;<br>      type: "code_execution_20260120",&para;<br>      name: "code_execution"&para;<br>    },&para;<br>    {&para;<br>      name: "query_database",&para;<br>      description: "Execute a SQL query against the sales database. Returns a list of rows as JSON objects.",&para;<br>      input_schema: { /* ... */ },&para;<br>      allowed_callers: ["code_execution_20260120"]&para;<br>    }&para;<br>  ]&para;<br>});&para;<br>```&para;<br>&lt;/CodeGroup&gt;&para;<br>&para;<br>### Step 2: API response with tool call&para;<br>&para;<br>Claude writes code that calls your tool. The API pauses and returns:&para;<br>&para;<br>```json&para;<br>{&para;<br>  "role": "assistant",&para;<br>  "content": [&para;<br>    {&para;<br>      "type": "text",&para;<br>      "text": "I'll query the purchase history and analyze the results."&para;<br>    },&para;<br>    {&para;<br>      "type": "server_tool_use",&para;<br>      "id": "srvtoolu_abc123",&para;<br>      "name": "code_execution",&para;<br>      "input": {&para;<br>        "code": "results = await query_database('&lt;sql&gt;')\ntop_customers = sorted(results, key=lambda x: x['revenue'], reverse=True)[:5]\nprint(f'Top 5 customers: {top_customers}')"&para;<br>      }&para;<br>    },&para;<br>    {&para;<br>      "type": "tool_use",&para;<br>      "id": "toolu_def456",&para;<br>      "name": "query_database",&para;<br>      "input": {"sql": "&lt;sql&gt;"},&para;<br>      "caller": {&para;<br>        "type": "code_execution_20260120",&para;<br>        "tool_id": "srvtoolu_abc123"&para;<br>      }&para;<br>    }&para;<br>  ],&para;<br>  "container": {&para;<br>    "id": "container_xyz789",&para;<br>    "expires_at": "2025-01-15T14:30:00Z"&para;<br>  },&para;<br>  "stop_reason": "tool_use"&para;<br>}&para;<br>```&para;<br>&para;<br>### Step 3: Provide tool result&para;<br>&para;<br>Include the full conversation history plus your tool result:&para;<br>&para;<br>&lt;CodeGroup&gt;&para;<br>```python Python&para;<br>response = client.messages.create(&para;<br>    model="claude-opus-4-6",&para;<br>    max_tokens=4096,&para;<br>    container="container_xyz789",  # Reuse the container&para;<br>    messages=[&para;<br>        {&para;<br>            "role": "user",&para;<br>            "content": "Query customer purchase history from the last quarter and identify our top 5 customers by revenue",&para;<br>        },&para;<br>        {&para;<br>            "role": "assistant",&para;<br>            "content": [&para;<br>                {&para;<br>                    "type": "text",&para;<br>                    "text": "I'll query the purchase history and analyze the results.",&para;<br>                },&para;<br>                {&para;<br>                    "type": "server_tool_use",&para;<br>                    "id": "srvtoolu_abc123",&para;<br>                    "name": "code_execution",&para;<br>                    "input": {"code": "..."},&para;<br>                },&para;<br>                {&para;<br>                    "type": "tool_use",&para;<br>                    "id": "toolu_def456",&para;<br>                    "name": "query_database",&para;<br>                    "input": {"sql": "&lt;sql&gt;"},&para;<br>                    "caller": {&para;<br>                        "type": "code_execution_20260120",&para;<br>                        "tool_id": "srvtoolu_abc123",&para;<br>                    },&para;<br>                },&para;<br>            ],&para;<br>        },&para;<br>        {&para;<br>            "role": "user",&para;<br>            "content": [&para;<br>                {&para;<br>                    "type": "tool_result",&para;<br>                    "tool_use_id": "toolu_def456",&para;<br>                    "content": '[{"customer_id": "C1", "revenue": 45000}, {"customer_id": "C2", "revenue": 38000}, ...]',&para;<br>                }&para;<br>            ],&para;<br>        },&para;<br>    ],&para;<br>    tools=[...],&para;<br>)&para;<br>```&para;<br>&para;<br>```typescript TypeScript&para;<br>const response = await anthropic.messages.create({&para;<br>  model: "claude-opus-4-6",&para;<br>  max_tokens: 4096,&para;<br>  container: "container_xyz789", // Reuse the container&para;<br>  messages: [&para;<br>    { role: "user", content: "Query customer purchase history from the last quarter and identify our top 5 customers by revenue" },&para;<br>    {&para;<br>      role: "assistant",&para;<br>      content: [&para;<br>        { type: "text", text: "I'll query the purchase history and analyze the results." },&para;<br>        {&para;<br>          type: "server_tool_use",&para;<br>          id: "srvtoolu_abc123",&para;<br>          name: "code_execution",&para;<br>          input: { code: "..." }&para;<br>        },&para;<br>        {&para;<br>          type: "tool_use",&para;<br>          id: "toolu_def456",&para;<br>          name: "query_database",&para;<br>          input: { sql: "&lt;sql&gt;" },&para;<br>          caller: {&para;<br>            type: "code_execution_20260120",&para;<br>            tool_id: "srvtoolu_abc123"&para;<br>          }&para;<br>        }&para;<br>      ]&para;<br>    },&para;<br>    {&para;<br>      role: "user",&para;<br>      content: [&para;<br>        {&para;<br>          type: "tool_result",&para;<br>          tool_use_id: "toolu_def456",&para;<br>          content: "[{\"customer_id\": \"C1\", \"revenue\": 45000}, {\"customer_id\": \"C2\", \"revenue\": 38000}, ...]"&para;<br>        }&para;<br>      ]&para;<br>    }&para;<br>  ],&para;<br>  tools: [/* ... */]&para;<br>});&para;<br>```&para;<br>&lt;/CodeGroup&gt;&para;<br>&para;<br>### Step 4: Next tool call or completion&para;<br>&para;<br>The code execution continues and processes the results. If additional tool calls are needed, repeat Step 3 until all tool calls are satisfied.&para;<br>&para;<br>### Step 5: Final response&para;<br>&para;<br>Once the code execution completes, Claude provides the final response:&para;<br>&para;<br>```json&para;<br>{&para;<br>  "content": [&para;<br>    {&para;<br>      "type": "code_execution_tool_result",&para;<br>      "tool_use_id": "srvtoolu_abc123",&para;<br>      "content": {&para;<br>        "type": "code_execution_result",&para;<br>        "stdout": "Top 5 customers by revenue:\n1. Customer C1: $45,000\n2. Customer C2: $38,000\n3. Customer C5: $32,000\n4. Customer C8: $28,500\n5. Customer C3: $24,000",&para;<br>        "stderr": "",&para;<br>        "return_code": 0,&para;<br>        "content": []&para;<br>      }&para;<br>    },&para;<br>    {&para;<br>      "type": "text",&para;<br>      "text": "I've analyzed the purchase history from last quarter. Your top 5 customers generated $167,500 in total revenue, with Customer C1 leading at $45,000."&para;<br>    }&para;<br>  ],&para;<br>  "stop_reason": "end_turn"&para;<br>}&para;<br>```&para;<br>&para;<br>## Advanced patterns&para;<br>&para;<br>### Batch processing with loops&para;<br>&para;<br>Claude can write code that processes multiple items efficiently:&para;<br>&para;<br>```python&para;<br># async wrapper omitted for clarity&para;<br>regions = ["West", "East", "Central", "North", "South"]&para;<br>results = {}&para;<br>for region in regions:&para;<br>    data = await query_database(f"&lt;sql for {region}&gt;")&para;<br>    results[region] = sum(row["revenue"] for row in data)&para;<br>&para;<br># Process results programmatically&para;<br>top_region = max(results.items(), key=lambda x: x[1])&para;<br>print(f"Top region: {top_region[0]} with ${top_region[1]:,} in revenue")&para;<br>```&para;<br>&para;<br>This pattern:&para;<br>- Reduces model round-trips from N (one per region) to 1&para;<br>- Processes large result sets programmatically before returning to Claude&para;<br>- Saves tokens by only returning aggregated conclusions instead of raw data&para;<br>&para;<br>### Early termination&para;<br>&para;<br>Claude can stop processing as soon as success criteria are met:&para;<br>&para;<br>```python&para;<br># async wrapper omitted for clarity&para;<br>endpoints = ["us-east", "eu-west", "apac"]&para;<br>for endpoint in endpoints:&para;<br>    status = await check_health(endpoint)&para;<br>    if status == "healthy":&para;<br>        print(f"Found healthy endpoint: {endpoint}")&para;<br>        break  # Stop early, don't check remaining&para;<br>```&para;<br>&para;<br>### Conditional tool selection&para;<br>&para;<br>```python&para;<br># async wrapper omitted for clarity&para;<br>file_info = await get_file_info(path)&para;<br>if file_info["size"] &lt; 10000:&para;<br>    content = await read_full_file(path)&para;<br>else:&para;<br>    content = await read_file_summary(path)&para;<br>print(content)&para;<br>```&para;<br>&para;<br>### Data filtering&para;<br>&para;<br>```python&para;<br># async wrapper omitted for clarity&para;<br>logs = await fetch_logs(server_id)&para;<br>errors = [log for log in logs if "ERROR" in log]&para;<br>print(f"Found {len(errors)} errors")&para;<br>for error in errors[-10:]:  # Only return last 10 errors&para;<br>    print(error)&para;<br>```&para;<br>&para;<br>## Response format&para;<br>&para;<br>### Programmatic tool call&para;<br>&para;<br>When code execution calls a tool:&para;<br>&para;<br>```json&para;<br>{&para;<br>  "type": "tool_use",&para;<br>  "id": "toolu_abc123",&para;<br>  "name": "query_database",&para;<br>  "input": {"sql": "&lt;sql&gt;"},&para;<br>  "caller": {&para;<br>    "type": "code_execution_20260120",&para;<br>    "tool_id": "srvtoolu_xyz789"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### Tool result handling&para;<br>&para;<br>Your tool result is passed back to the running code:&para;<br>&para;<br>```json&para;<br>{&para;<br>  "role": "user",&para;<br>  "content": [&para;<br>    {&para;<br>      "type": "tool_result",&para;<br>      "tool_use_id": "toolu_abc123",&para;<br>      "content": "[{\"customer_id\": \"C1\", \"revenue\": 45000, \"orders\": 23}, {\"customer_id\": \"C2\", \"revenue\": 38000, \"orders\": 18}, ...]"&para;<br>    }&para;<br>  ]&para;<br>}&para;<br>```&para;<br>&para;<br>### Code execution completion&para;<br>&para;<br>When all tool calls are satisfied and code completes:&para;<br>&para;<br>```json&para;<br>{&para;<br>  "type": "code_execution_tool_result",&para;<br>  "tool_use_id": "srvtoolu_xyz789",&para;<br>  "content": {&para;<br>    "type": "code_execution_result",&para;<br>    "stdout": "Analysis complete. Top 5 customers identified from 847 total records.",&para;<br>    "stderr": "",&para;<br>    "return_code": 0,&para;<br>    "content": []&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>## Error handling&para;<br>&para;<br>### Common errors&para;<br>&para;<br>| Error | Description | Solution |&para;<br>|-------|-------------|----------|&para;<br>| `invalid_tool_input` | Tool input doesn't match schema | Validate your tool's input_schema |&para;<br>| `tool_not_allowed` | Tool doesn't allow the requested caller type | Check `allowed_callers` includes the right contexts |&para;<br>| `missing_beta_header` | Required beta header not provided | Add the required beta headers to your request |&para;<br>&para;<br>### Container expiration during tool call&para;<br>&para;<br>If your tool takes too long to respond, the code execution will receive a `TimeoutError`. Claude sees this in stderr and will typically retry:&para;<br>&para;<br>```json&para;<br>{&para;<br>  "type": "code_execution_tool_result",&para;<br>  "tool_use_id": "srvtoolu_abc123",&para;<br>  "content": {&para;<br>    "type": "code_execution_result",&para;<br>    "stdout": "",&para;<br>    "stderr": "TimeoutError: Calling tool ['query_database'] timed out.",&para;<br>    "return_code": 0,&para;<br>    "content": []&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>To prevent timeouts:&para;<br>- Monitor the `expires_at` field in responses&para;<br>- Implement timeouts for your tool execution&para;<br>- Consider breaking long operations into smaller chunks&para;<br>&para;<br>### Tool execution errors&para;<br>&para;<br>If your tool returns an error:&para;<br>&para;<br>```python&para;<br># Provide error information in the tool result&para;<br>{&para;<br>    "type": "tool_result",&para;<br>    "tool_use_id": "toolu_abc123",&para;<br>    "content": "Error: Query timeout - table lock exceeded 30 seconds",&para;<br>}&para;<br>```&para;<br>&para;<br>Claude's code will receive this error and can handle it appropriately.&para;<br>&para;<br>## Constraints and limitations&para;<br>&para;<br>### Feature incompatibilities&para;<br>&para;<br>- **Structured outputs**: Tools with `strict: true` are not supported with programmatic calling&para;<br>- **Tool choice**: You cannot force programmatic calling of a specific tool via `tool_choice`&para;<br>- **Parallel tool use**: `disable_parallel_tool_use: true` is not supported with programmatic calling&para;<br>&para;<br>### Tool restrictions&para;<br>&para;<br>The following tools cannot currently be called programmatically, but support may be added in future releases:&para;<br>&para;<br>- Tools provided by an [MCP connector](/docs/en/agents-and-tools/mcp-connector)&para;<br>&para;<br>### Message formatting restrictions&para;<br>&para;<br>When responding to programmatic tool calls, there are strict formatting requirements:&para;<br>&para;<br>**Tool result only responses**: If there are pending programmatic tool calls waiting for results, your response message must contain **only** `tool_result` blocks. You cannot include any text content, even after the tool results.&para;<br>&para;<br>```json&para;<br>// ❌ INVALID - Cannot include text when responding to programmatic tool calls&para;<br>{&para;<br>  "role": "user",&para;<br>  "content": [&para;<br>    {"type": "tool_result", "tool_use_id": "toolu_01", "content": "[{\"customer_id\": \"C1\", \"revenue\": 45000}]"},&para;<br>    {"type": "text", "text": "What should I do next?"}  // This will cause an error&para;<br>  ]&para;<br>}&para;<br>&para;<br>// ✅ VALID - Only tool results when responding to programmatic tool calls&para;<br>{&para;<br>  "role": "user",&para;<br>  "content": [&para;<br>    {"type": "tool_result", "tool_use_id": "toolu_01", "content": "[{\"customer_id\": \"C1\", \"revenue\": 45000}]"}&para;<br>  ]&para;<br>}&para;<br>```&para;<br>&para;<br>This restriction only applies when responding to programmatic (code execution) tool calls. For regular client-side tool calls, you can include text content after tool results.&para;<br>&para;<br>### Rate limits&para;<br>&para;<br>Programmatic tool calls are subject to the same rate limits as regular tool calls. Each tool call from code execution counts as a separate invocation.&para;<br>&para;<br>### Validate tool results before use&para;<br>&para;<br>When implementing custom tools that will be called programmatically:&para;<br>&para;<br>- **Tool results are returned as strings**: They can contain any content, including code snippets or executable commands that may be processed by the execution environment.&para;<br>- **Validate external tool results**: If your tool returns data from external sources or accepts user input, be aware of code injection risks if the output will be interpreted or executed as code.&para;<br>&para;<br>## Token efficiency&para;<br>&para;<br>Programmatic tool calling can significantly reduce token consumption:&para;<br>&para;<br>- **Tool results from programmatic calls are not added to Claude's context** - only the final code output is&para;<br>- **Intermediate processing happens in code** - filtering, aggregation, etc. don't consume model tokens&para;<br>- **Multiple tool calls in one code execution** - reduces overhead compared to separate model turns&para;<br>&para;<br>For example, calling 10 tools directly uses ~10x the tokens of calling them programmatically and returning a summary.&para;<br>&para;<br>## Usage and pricing&para;<br>&para;<br>Programmatic tool calling uses the same pricing as code execution. See the [code execution pricing](/docs/en/agents-and-tools/tool-use/code-execution-tool#usage-and-pricing) for details.&para;<br>&para;<br>&lt;Note&gt;&para;<br>Token counting for programmatic tool calls: Tool results from programmatic invocations do not count toward your input/output token usage. Only the final code execution result and Claude's response count.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>## Best practices&para;<br>&para;<br>### Tool design&para;<br>&para;<br>- **Provide detailed output descriptions**: Since Claude deserializes tool results in code, clearly document the format (JSON structure, field types, etc.)&para;<br>- **Return structured data**: JSON or other easily parseable formats work best for programmatic processing&para;<br>- **Keep responses concise**: Return only necessary data to minimize processing overhead&para;<br>&para;<br>### When to use programmatic calling&para;<br>&para;<br>**Good use cases:**&para;<br>- Processing large datasets where you only need aggregates or summaries&para;<br>- Multi-step workflows with 3+ dependent tool calls&para;<br>- Operations requiring filtering, sorting, or transformation of tool results&para;<br>- Tasks where intermediate data shouldn't influence Claude's reasoning&para;<br>- Parallel operations across many items (e.g., checking 50 endpoints)&para;<br>&para;<br>**Less ideal use cases:**&para;<br>- Single tool calls with simple responses&para;<br>- Tools that need immediate user feedback&para;<br>- Very fast operations where code execution overhead would outweigh the benefit&para;<br>&para;<br>### Performance optimization&para;<br>&para;<br>- **Reuse containers** when making multiple related requests to maintain state&para;<br>- **Batch similar operations** in a single code execution when possible&para;<br>&para;<br>## Troubleshooting&para;<br>&para;<br>### Common issues&para;<br>&para;<br>**"Tool not allowed" error**&para;<br>- Verify your tool definition includes `"allowed_callers": ["code_execution_20260120"]`&para;<br>&para;<br>**Container expiration**&para;<br>- Ensure you respond to tool calls within the container's lifetime (~4.5 minutes)&para;<br>- Monitor the `expires_at` field in responses&para;<br>- Consider implementing faster tool execution&para;<br>&para;<br>**Tool result not parsed correctly**&para;<br>- Ensure your tool returns string data that Claude can deserialize&para;<br>- Provide clear output format documentation in your tool description&para;<br>&para;<br>### Debugging tips&para;<br>&para;<br>1. **Log all tool calls and results** to track the flow&para;<br>2. **Check the `caller` field** to confirm programmatic invocation&para;<br>3. **Monitor container IDs** to ensure proper reuse&para;<br>4. **Test tools independently** before enabling programmatic calling&para;<br>&para;<br>## Why programmatic tool calling works&para;<br>&para;<br>Claude's training includes extensive exposure to code, making it effective at reasoning through and chaining function calls. When tools are presented as callable functions within a code execution environment, Claude can leverage this strength to:&para;<br>&para;<br>- **Reason naturally about tool composition**: Chain operations and handle dependencies as naturally as writing any Python code&para;<br>- **Process large results efficiently**: Filter down large tool outputs, extract only relevant data, or write intermediate results to files before returning summaries to the context window&para;<br>- **Reduce latency significantly**: Eliminate the overhead of re-sampling Claude between each tool call in multi-step workflows&para;<br>&para;<br>This approach enables workflows that would be impractical with traditional tool use (such as processing files over 1M tokens) by allowing Claude to work with data programmatically rather than loading everything into the conversation context.&para;<br>&para;<br>## Alternative implementations&para;<br>&para;<br>Programmatic tool calling is a generalizable pattern that can be implemented outside of Anthropic's managed code execution. Here's an overview of the approaches:&para;<br>&para;<br>### Client-side direct execution&para;<br>&para;<br>Provide Claude with a code execution tool and describe what functions are available in that environment. When Claude invokes the tool with code, your application executes it locally where those functions are defined.&para;<br>&para;<br>**Advantages:**&para;<br>- Simple to implement with minimal re-architecting&para;<br>- Full control over the environment and instructions&para;<br>&para;<br>**Disadvantages:**&para;<br>- Executes untrusted code outside of a sandbox&para;<br>- Tool invocations can be vectors for code injection&para;<br>&para;<br>**Use when:** Your application can safely execute arbitrary code, you want a simple solution, and Anthropic's managed offering doesn't fit your needs.&para;<br>&para;<br>### Self-managed sandboxed execution&para;<br>&para;<br>Same approach from Claude's perspective, but code runs in a sandboxed container with security restrictions (e.g., no network egress). If your tools require external resources, you'll need a protocol for executing tool calls outside the sandbox.&para;<br>&para;<br>**Advantages:**&para;<br>- Safe programmatic tool calling on your own infrastructure&para;<br>- Full control over the execution environment&para;<br>&para;<br>**Disadvantages:**&para;<br>- Complex to build and maintain&para;<br>- Requires managing both infrastructure and inter-process communication&para;<br>&para;<br>**Use when:** Security is critical and Anthropic's managed solution doesn't fit your requirements.&para;<br>&para;<br>### Anthropic-managed execution&para;<br>&para;<br>Anthropic's programmatic tool calling is a managed version of sandboxed execution with an opinionated Python environment tuned for Claude. Anthropic handles container management, code execution, and secure tool invocation communication.&para;<br>&para;<br>**Advantages:**&para;<br>- Safe and secure by default&para;<br>- Easy to enable with minimal configuration&para;<br>- Environment and instructions optimized for Claude&para;<br>&para;<br>Consider using Anthropic's managed solution if you're using the Claude API.&para;<br>&para;<br>## Related features&para;<br>&para;<br>&lt;CardGroup cols={2}&gt;&para;<br>  &lt;Card title="Code Execution Tool" icon="code" href="/docs/en/agents-and-tools/tool-use/code-execution-tool"&gt;&para;<br>    Learn about the underlying code execution capability that powers programmatic tool calling.&para;<br>  &lt;/Card&gt;&para;<br>  &lt;Card title="Tool Use Overview" icon="wrench" href="/docs/en/agents-and-tools/tool-use/overview"&gt;&para;<br>    Understand the fundamentals of tool use with Claude.&para;<br>  &lt;/Card&gt;&para;<br>  &lt;Card title="Implement Tool Use" icon="hammer" href="/docs/en/agents-and-tools/tool-use/implement-tool-use"&gt;&para;<br>    Step-by-step guide for implementing tools.&para;<br>  &lt;/Card&gt;&para;<br>&lt;/CardGroup&gt;</span></div>
        </div>

        <h2 style="margin-top: 2rem; margin-bottom: 1rem;">Unified Diff</h2>
        <pre><code>--- a/agents-and-tools/tool-use/programmatic-tool-calling.md
+++ b/agents-and-tools/tool-use/programmatic-tool-calling.md
@@ -2,7 +2,13 @@
 
 ---
 
-Programmatic tool calling allows Claude to write code that calls your tools programmatically within a [code execution](/docs/en/agents-and-tools/tool-use/code-execution-tool) container, rather than requiring round trips through the model for each tool invocation. This reduces latency for multi-tool workflows and decreases token consumption by allowing Claude to filter or process data before it reaches the model&#39;s context window.
+Programmatic tool calling allows Claude to write code that calls your tools programmatically within a [code execution](/docs/en/agents-and-tools/tool-use/code-execution-tool) container, rather than requiring round trips through the model for each tool invocation. This reduces latency for multi-tool workflows and decreases token consumption by allowing Claude to filter or process data before it reaches the model&#39;s context window. On agentic search benchmarks like [BrowseComp](https://arxiv.org/abs/2504.12516) and [DeepSearchQA](https://github.com/google-deepmind/deepsearchqa), which test multi-step web research and complex information retrieval, adding programmatic tool calling on top of basic search tools was the key factor that fully unlocked agent performance.
+
+The difference compounds fast in real workflows. Consider checking budget compliance across 20 employees: the traditional approach requires 20 separate model round-trips, pulling thousands of expense line items into the context along the way. With programmatic tool calling, a single script runs all 20 lookups, filters the results, and returns only the employees who exceeded their limits, shrinking what Claude needs to reason over from hundreds of kilobytes down to a handful of lines.
+
+&lt;Tip&gt;
+For a deeper look at the inference and context costs that programmatic tool calling addresses, see [Advanced tool use](https://www.anthropic.com/engineering/advanced-tool-use).
+&lt;/Tip&gt;
 
 &lt;Note&gt;
 This feature requires the code execution tool to be enabled.
</code></pre>
    </div>
</body>
</html>