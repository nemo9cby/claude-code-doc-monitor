<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>agents-and-tools/tool-use/bash-tool - Diff Report</title>
    <link rel="stylesheet" href="../../css/diff.css">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --card-bg: #16213e;
            --text-color: #eee;
            --accent: #0f3460;
            --add-bg: #1a4d1a;
            --del-bg: #4d1a1a;
            --add-text: #4ade80;
            --del-text: #f87171;
        }
        @media (prefers-color-scheme: light) {
            :root {
                --bg-color: #f5f5f5;
                --card-bg: #fff;
                --text-color: #333;
                --accent: #e0e0e0;
                --add-bg: #d4edda;
                --del-bg: #f8d7da;
                --add-text: #155724;
                --del-text: #721c24;
            }
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 2rem;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        header { margin-bottom: 2rem; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .meta { color: #888; font-size: 0.9rem; }
        .summary {
            background: var(--card-bg);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            display: flex;
            gap: 2rem;
        }
        .stat { display: flex; align-items: center; gap: 0.5rem; }
        .stat.added { color: var(--add-text); }
        .stat.removed { color: var(--del-text); }
        .analysis {
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            border-left: 4px solid #8b5cf6;
        }
        .analysis-header {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #8b5cf6;
        }
        .analysis-content {
            white-space: pre-wrap;
            font-size: 0.95rem;
            line-height: 1.7;
        }
        .diff-container {
            background: var(--card-bg);
            border-radius: 8px;
            overflow: hidden;
        }
        .diff-header {
            background: var(--accent);
            padding: 0.75rem 1rem;
            font-weight: 600;
        }
        .diff-content {
            padding: 1rem;
            overflow-x: auto;
        }
        .diff-content ins {
            background: var(--add-bg);
            color: var(--add-text);
            text-decoration: none;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        .diff-content del {
            background: var(--del-bg);
            color: var(--del-text);
            text-decoration: line-through;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        pre {
            background: var(--accent);
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.85rem;
            margin-top: 2rem;
        }
        a { color: #60a5fa; }
        .back-link { margin-bottom: 1rem; display: inline-block; }
    </style>
</head>
<body>
    <div class="container">
        <a href="../../../index.html" class="back-link">&larr; Back to daily report</a>

        <header>
            <h1>agents-and-tools/tool-use/bash-tool.md</h1>
            <p class="meta">Changed on 2026-02-11 10:56:44 EST</p>
        </header>

        <div class="summary">
            <div class="stat added">
                <span>+15</span> lines added
            </div>
            <div class="stat removed">
                <span>-24</span> lines removed
            </div>
        </div>

        

        <div class="diff-container">
            <div class="diff-header">Visual Diff</div>
            <div class="diff-content"><span># Bash tool&para;<br>&para;<br>---&para;<br>&para;<br>The bash tool enables Claude to execute shell commands in a persistent bash session, allowing system operations, script execution, and command-line automation.&para;<br>&para;<br>## Overview&para;<br>&para;<br>The bash tool provides Claude with:&para;<br>- Persistent bash session that maintains state&para;<br>- Ability to run any shell command&para;<br>- Access to environment variables and working directory&para;<br>- Command chaining and scripting capabilities&para;<br>&para;<br>## Model compatibility&para;<br>&para;<br>| Model | Tool Version |&para;<br>|-------|--------------|&para;<br>| Claude 4 models and Sonnet 3.7 ([deprecated](/docs/en/about-claude/model-deprecations)) | `bash_20250124` |&para;<br>&para;<br>&lt;Warning&gt;&para;<br>Older tool versions are not guaranteed to be backwards-compatible with newer models. Always use the tool version that corresponds to your model version.&para;<br>&lt;/Warning&gt;&para;<br>&para;<br>## Use cases&para;<br>&para;<br>- **Development workflows**: Run build commands, tests, and development tools&para;<br>- **System automation**: Execute scripts, manage files, automate tasks&para;<br>- **Data processing**: Process files, run analysis scripts, manage datasets&para;<br>- **Environment setup**: Install packages, configure environments&para;<br>&para;<br>## Quick start&para;<br>&para;<br>&lt;CodeGroup&gt;&para;<br>```python Python&para;<br>import anthropic&para;<br>&para;<br>client = anthropic.Anthropic()&para;<br>&para;<br>response = client.messages.create(&para;<br>    model="claude-opus-4-6",&para;<br>    max_tokens=1024,&para;<br>    tools=[</span><del style="background:#ffe6e6;">&para;<br>        {&para;<br>            </del><ins style="background:#e6ffe6;">{</ins><span>"type": "bash_20250124",</span><del style="background:#ffe6e6;">&para;<br>           </del><span> "name": "bash"</span><del style="background:#ffe6e6;">&para;<br>        }&para;<br>    </del><ins style="background:#e6ffe6;">}</ins><span>],&para;<br>    messages=[&para;<br>        {"role": "user", "content": "List all Python files in the current directory."}&para;<br>    ]</span><ins style="background:#e6ffe6;">,</ins><span>&para;<br>)&para;<br>```&para;<br>&para;<br>```bash Shell&para;<br>curl https://api.anthropic.com/v1/messages \&para;<br>  -H "content-type: application/json" \&para;<br>  -H "x-api-key: $ANTHROPIC_API_KEY" \&para;<br>  -H "anthropic-version: 2023-06-01" \&para;<br>  -d '{&para;<br>    "model": "claude-opus-4-6",&para;<br>    "max_tokens": 1024,&para;<br>    "tools": [&para;<br>      {&para;<br>        "type": "bash_20250124",&para;<br>        "name": "bash"&para;<br>      }&para;<br>    ],&para;<br>    "messages": [&para;<br>      {&para;<br>        "role": "user",&para;<br>        "content": "List all Python files in the current directory."&para;<br>      }&para;<br>    ]&para;<br>  }'&para;<br>```&para;<br>&lt;/CodeGroup&gt;&para;<br>&para;<br>## How it works&para;<br>&para;<br>The bash tool maintains a persistent session:&para;<br>&para;<br>1. Claude determines what command to run&para;<br>2. You execute the command in a bash shell&para;<br>3. Return the output (stdout and stderr) to Claude&para;<br>4. Session state persists between commands (environment variables, working directory)&para;<br>&para;<br>## Parameters&para;<br>&para;<br>| Parameter | Required | Description |&para;<br>|-----------|----------|-------------|&para;<br>| `command` | Yes* | The bash command to run |&para;<br>| `restart` | No | Set to `true` to restart the bash session |&para;<br>&para;<br>*Required unless using `restart`&para;<br>&para;<br>&lt;section title="Example usage"&gt;&para;<br>&para;<br>```json&para;<br>// Run a command&para;<br>{&para;<br>  "command": "ls -la *.py"&para;<br>}&para;<br>&para;<br>// Restart the session&para;<br>{&para;<br>  "restart": true&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>## Example: Multi-step automation&para;<br>&para;<br>Claude can chain commands to complete complex tasks:&para;<br>&para;<br>```python&para;<br># User request&para;<br>"Install the requests library and create a simple Python script that fetches a joke from an API, then run it."&para;<br>&para;<br># Claude's tool uses:&para;<br># 1. Install package&para;<br>{"command": "pip install requests"}&para;<br>&para;<br># 2. Create script&para;<br>{</span><ins style="background:#e6ffe6;">&para;<br>    </ins><span>"command": "cat &gt; fetch_joke.py &lt;&lt; 'EOF'\nimport requests\nresponse = requests.get('https://official-joke-api.appspot.com/random_joke')\njoke = response.json()\nprint(f\"Setup: {joke['setup']}\")\nprint(f\"Punchline: {joke['punchline']}\")\nEOF"</span><ins style="background:#e6ffe6;">&para;<br></ins><span>}&para;<br>&para;<br># 3. Run script&para;<br>{"command": "python fetch_joke.py"}&para;<br>```&para;<br>&para;<br>The session maintains state between commands, so files created in step 2 are available in step 3.&para;<br>&para;<br>***&para;<br>&para;<br>## Implement the bash tool&para;<br>&para;<br>The bash tool is implemented as a schema-less tool. When using this tool, you don't need to provide an input schema as with other tools; the schema is built into Claude's model and can't be modified.&para;<br>&para;<br>&lt;Steps&gt;&para;<br>  &lt;Step title="Set up a bash environment"&gt;&para;<br>    Create a persistent bash session that Claude can interact with:&para;<br>    ```python&para;<br>    import subprocess&para;<br>    import threading&para;<br>    import queue&para;<br></span><del style="background:#ffe6e6;">    </del><ins style="background:#e6ffe6;">&para;<br></ins><span>&para;<br>    class BashSession:&para;<br>        def __init__(self):&para;<br>            self.process = subprocess.Popen(&para;<br>                [</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>/bin/bash</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>],&para;<br>                stdin=subprocess.PIPE,&para;<br>                stdout=subprocess.PIPE,&para;<br>                stderr=subprocess.PIPE,&para;<br>                text=True,&para;<br>                bufsize=0</span><ins style="background:#e6ffe6;">,</ins><span>&para;<br>            )&para;<br>            self.output_queue = queue.Queue()&para;<br>            self.error_queue = queue.Queue()&para;<br>            self._start_readers()&para;<br>    ```&para;<br>  &lt;/Step&gt;&para;<br>  &lt;Step title="Handle command execution"&gt;&para;<br>    Create a function to execute commands and capture output:&para;<br>    ```python&para;<br>    def execute_command(self, command):&para;<br>        # Send command to bash&para;<br>        self.process.stdin.write(command + </span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>\n</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>)&para;<br>        self.process.stdin.flush()&para;<br></span><del style="background:#ffe6e6;">        </del><span>&para;<br>        # Capture output with timeout&para;<br>        output = self._read_output(timeout=10)&para;<br>        return output&para;<br>    ```&para;<br>  &lt;/Step&gt;&para;<br>  &lt;Step title="Process Claude's tool calls"&gt;&para;<br>    Extract and execute commands from Claude's responses:&para;<br>    ```python&para;<br>    for content in response.content:&para;<br>        if content.type == "tool_use" and content.name == "bash":&para;<br>            if content.input.get("restart"):&para;<br>                bash_session.restart()&para;<br>                result = "Bash session restarted"&para;<br>            else:&para;<br>                command = content.input.get("command")&para;<br>                result = bash_session.execute_command(command)&para;<br></span><del style="background:#ffe6e6;">            </del><span>&para;<br>            # Return result to Claude&para;<br>            tool_result = {&para;<br>                "type": "tool_result",&para;<br>                "tool_use_id": content.id,&para;<br>                "content": result</span><ins style="background:#e6ffe6;">,</ins><span>&para;<br>            }&para;<br>    ```&para;<br>  &lt;/Step&gt;&para;<br>  &lt;Step title="Implement safety measures"&gt;&para;<br>    Add validation and restrictions:&para;<br>    ```python&para;<br>    def validate_command(command):&para;<br>        # Block dangerous commands&para;<br>        dangerous_patterns = [</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>rm -rf /</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>, </span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>format</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>, </span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>:(){:|:&amp;};:</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>]&para;<br>        for pattern in dangerous_patterns:&para;<br>            if pattern in command:&para;<br>                return False, f"Command contains dangerous pattern: {pattern}"&para;<br></span><del style="background:#ffe6e6;">        </del><span>&para;<br>        # Add more validation as needed&para;<br>        return True, None&para;<br>    ```&para;<br>  &lt;/Step&gt;&para;<br>&lt;/Steps&gt;&para;<br>&para;<br>### Handle errors&para;<br>&para;<br>When implementing the bash tool, handle various error scenarios:&para;<br>&para;<br>&lt;section title="Command execution timeout"&gt;&para;<br>&para;<br>If a command takes too long to execute:&para;<br>&para;<br>```json&para;<br>{&para;<br>  "role": "user",&para;<br>  "content": [&para;<br>    {&para;<br>      "type": "tool_result",&para;<br>      "tool_use_id": "toolu_01A09q90qw90lq917835lq9",&para;<br>      "content": "Error: Command timed out after 30 seconds",&para;<br>      "is_error": true&para;<br>    }&para;<br>  ]&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Command not found"&gt;&para;<br>&para;<br>If a command doesn't exist:&para;<br>&para;<br>```json&para;<br>{&para;<br>  "role": "user",&para;<br>  "content": [&para;<br>    {&para;<br>      "type": "tool_result",&para;<br>      "tool_use_id": "toolu_01A09q90qw90lq917835lq9",&para;<br>      "content": "bash: nonexistentcommand: command not found",&para;<br>      "is_error": true&para;<br>    }&para;<br>  ]&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Permission denied"&gt;&para;<br>&para;<br>If there are permission issues:&para;<br>&para;<br>```json&para;<br>{&para;<br>  "role": "user",&para;<br>  "content": [&para;<br>    {&para;<br>      "type": "tool_result",&para;<br>      "tool_use_id": "toolu_01A09q90qw90lq917835lq9",&para;<br>      "content": "bash: /root/sensitive-file: Permission denied",&para;<br>      "is_error": true&para;<br>    }&para;<br>  ]&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>### Follow implementation best practices&para;<br>&para;<br>&lt;section title="Use command timeouts"&gt;&para;<br>&para;<br>Implement timeouts to prevent hanging commands:&para;<br>```python&para;<br>def execute_with_timeout(command, timeout=30):&para;<br>    try:&para;<br>        result = subprocess.run(&para;<br>            command, </span><del style="background:#ffe6e6;">&para;<br>            shell=True, &para;<br>            capture_output=True, &para;<br>            text=True, &para;<br>           </del><ins style="background:#e6ffe6;">shell=True, capture_output=True, text=True,</ins><span> timeout=timeout&para;<br>        )&para;<br>        return result.stdout + result.stderr&para;<br>    except subprocess.TimeoutExpired:&para;<br>        return f"Command timed out after {timeout} seconds"&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Maintain session state"&gt;&para;<br>&para;<br>Keep the bash session persistent to maintain environment variables and working directory:&para;<br>```python&para;<br># Commands run in the same session maintain state&para;<br>commands = [&para;<br>    "cd /tmp",&para;<br>    "echo 'Hello' &gt; test.txt",&para;<br>    "cat test.txt"</span><ins style="background:#e6ffe6;">,</ins><span>  # This works because we're still in /tmp&para;<br>]&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Handle large outputs"&gt;&para;<br>&para;<br>Truncate very large outputs to prevent token limit issues:&para;<br>```python&para;<br>def truncate_output(output, max_lines=100):&para;<br>    lines = output.split(</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>\n</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>)&para;<br>    if len(lines) &gt; max_lines:&para;<br>        truncated = </span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>\n</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>.join(lines[:max_lines])&para;<br>        return f"{truncated}\n\n... Output truncated ({len(lines)} total lines) ..."&para;<br>    return output&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Log all commands"&gt;&para;<br>&para;<br>Keep an audit trail of executed commands:&para;<br>```python&para;<br>import logging&para;<br>&para;<br></span><ins style="background:#e6ffe6;">&para;<br></ins><span>def log_command(command, output, user_id):&para;<br>    logging.info(f"User {user_id} executed: {command}")&para;<br>    logging.info(f"Output: {output[:200]}...")  # Log first 200 chars&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Sanitize outputs"&gt;&para;<br>&para;<br>Remove sensitive information from command outputs:&para;<br>```python&para;<br>def sanitize_output(output):&para;<br>    # Remove potential secrets or credentials&para;<br>    import re&para;<br></span><ins style="background:#e6ffe6;">&para;<br></ins><span>    # Example: Remove AWS credentials&para;<br>    output = re.sub(r</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>aws_access_key_id\s*=\s*\S+</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>, </span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>aws_access_key_id=***</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>, output)&para;<br>    output = re.sub(</span><del style="background:#ffe6e6;">r'</del><ins style="background:#e6ffe6;">&para;<br>        r"</ins><span>aws_secret_access_key\s*=\s*\S+</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>, </span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>aws_secret_access_key=***</span><del style="background:#ffe6e6;">'</del><ins style="background:#e6ffe6;">"</ins><span>, output</span><ins style="background:#e6ffe6;">&para;<br>    </ins><span>)&para;<br>    return output&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>## Security&para;<br>&para;<br>&lt;Warning&gt;&para;<br>The bash tool provides direct system access. Implement these essential safety measures:&para;<br>- Running in isolated environments (Docker/VM)&para;<br>- Implementing command filtering and allowlists&para;<br>- Setting resource limits (CPU, memory, disk)&para;<br>- Logging all executed commands&para;<br>&lt;/Warning&gt;&para;<br>&para;<br>### Key recommendations&para;<br>- Use `ulimit` to set resource constraints&para;<br>- Filter dangerous commands (`sudo`, `rm -rf`, etc.)&para;<br>- Run with minimal user permissions&para;<br>- Monitor and log all command execution&para;<br>&para;<br>## Pricing&para;<br>&para;<br>The bash tool adds **245 input tokens** to your API calls.&para;<br>&para;<br>Additional tokens are consumed by:&para;<br>- Command outputs (stdout/stderr)&para;<br>- Error messages&para;<br>- Large file contents&para;<br>&para;<br>See [tool use pricing](/docs/en/agents-and-tools/tool-use/overview#pricing) for complete pricing details.&para;<br>&para;<br>## Common patterns&para;<br>&para;<br>### Development workflows&para;<br>- Running tests: `pytest &amp;&amp; coverage report`&para;<br>- Building projects: `npm install &amp;&amp; npm run build`&para;<br>- Git operations: `git status &amp;&amp; git add . &amp;&amp; git commit -m "message"`&para;<br>&para;<br>### File operations&para;<br>- Processing data: `wc -l *.csv &amp;&amp; ls -lh *.csv`&para;<br>- Searching files: `find . -name "*.py" | xargs grep "pattern"`&para;<br>- Creating backups: `tar -czf backup.tar.gz ./data`&para;<br>&para;<br>### System tasks&para;<br>- Checking resources: `df -h &amp;&amp; free -m`&para;<br>- Process management: `ps aux | grep python`&para;<br>- Environment setup: `export PATH=$PATH:/new/path &amp;&amp; echo $PATH`&para;<br>&para;<br>## Limitations&para;<br>&para;<br>- **No interactive commands**: Cannot handle `vim`, `less`, or password prompts&para;<br>- **No GUI applications**: Command-line only&para;<br>- **Session scope**: Persists within conversation, lost between API calls&para;<br>- **Output limits**: Large outputs may be truncated&para;<br>- **No streaming**: Results returned after completion&para;<br>&para;<br>## Combining with other tools&para;<br>&para;<br>The bash tool is most powerful when combined with the [text editor](/docs/en/agents-and-tools/tool-use/text-editor-tool) and other tools.&para;<br>&para;<br>## Next steps&para;<br>&para;<br>&lt;CardGroup cols={2}&gt;&para;<br>  &lt;Card&para;<br>    title="Tool use overview"&para;<br>    icon="tool"&para;<br>    href="/docs/en/agents-and-tools/tool-use/overview"&para;<br>  &gt;&para;<br>    Learn about tool use with Claude&para;<br>  &lt;/Card&gt;&para;<br>&para;<br>  &lt;Card&para;<br>    title="Text editor tool"&para;<br>    icon="file"&para;<br>    href="/docs/en/agents-and-tools/tool-use/text-editor-tool"&para;<br>  &gt;&para;<br>    View and edit text files with Claude&para;<br>  &lt;/Card&gt;&para;<br>&lt;/CardGroup&gt;</span></div>
        </div>

        <h2 style="margin-top: 2rem; margin-bottom: 1rem;">Unified Diff</h2>
        <pre><code>--- a/agents-and-tools/tool-use/bash-tool.md
+++ b/agents-and-tools/tool-use/bash-tool.md
@@ -40,15 +40,10 @@
 response = client.messages.create(
     model=&#34;claude-opus-4-6&#34;,
     max_tokens=1024,
-    tools=[
-        {
-            &#34;type&#34;: &#34;bash_20250124&#34;,
-            &#34;name&#34;: &#34;bash&#34;
-        }
-    ],
+    tools=[{&#34;type&#34;: &#34;bash_20250124&#34;, &#34;name&#34;: &#34;bash&#34;}],
     messages=[
         {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;List all Python files in the current directory.&#34;}
-    ]
+    ],
 )
 ```
 
@@ -123,7 +118,9 @@
 {&#34;command&#34;: &#34;pip install requests&#34;}
 
 # 2. Create script
-{&#34;command&#34;: &#34;cat &gt; fetch_joke.py &lt;&lt; &#39;EOF&#39;\nimport requests\nresponse = requests.get(&#39;https://official-joke-api.appspot.com/random_joke&#39;)\njoke = response.json()\nprint(f\&#34;Setup: {joke[&#39;setup&#39;]}\&#34;)\nprint(f\&#34;Punchline: {joke[&#39;punchline&#39;]}\&#34;)\nEOF&#34;}
+{
+    &#34;command&#34;: &#34;cat &gt; fetch_joke.py &lt;&lt; &#39;EOF&#39;\nimport requests\nresponse = requests.get(&#39;https://official-joke-api.appspot.com/random_joke&#39;)\njoke = response.json()\nprint(f\&#34;Setup: {joke[&#39;setup&#39;]}\&#34;)\nprint(f\&#34;Punchline: {joke[&#39;punchline&#39;]}\&#34;)\nEOF&#34;
+}
 
 # 3. Run script
 {&#34;command&#34;: &#34;python fetch_joke.py&#34;}
@@ -144,16 +141,17 @@
     import subprocess
     import threading
     import queue
-    
+
+
     class BashSession:
         def __init__(self):
             self.process = subprocess.Popen(
-                [&#39;/bin/bash&#39;],
+                [&#34;/bin/bash&#34;],
                 stdin=subprocess.PIPE,
                 stdout=subprocess.PIPE,
                 stderr=subprocess.PIPE,
                 text=True,
-                bufsize=0
+                bufsize=0,
             )
             self.output_queue = queue.Queue()
             self.error_queue = queue.Queue()
@@ -165,9 +163,9 @@
     ```python
     def execute_command(self, command):
         # Send command to bash
-        self.process.stdin.write(command + &#39;\n&#39;)
+        self.process.stdin.write(command + &#34;\n&#34;)
         self.process.stdin.flush()
-        
+
         # Capture output with timeout
         output = self._read_output(timeout=10)
         return output
@@ -184,12 +182,12 @@
             else:
                 command = content.input.get(&#34;command&#34;)
                 result = bash_session.execute_command(command)
-            
+
             # Return result to Claude
             tool_result = {
                 &#34;type&#34;: &#34;tool_result&#34;,
                 &#34;tool_use_id&#34;: content.id,
-                &#34;content&#34;: result
+                &#34;content&#34;: result,
             }
     ```
   &lt;/Step&gt;
@@ -198,11 +196,11 @@
     ```python
     def validate_command(command):
         # Block dangerous commands
-        dangerous_patterns = [&#39;rm -rf /&#39;, &#39;format&#39;, &#39;:(){:|:&amp;};:&#39;]
+        dangerous_patterns = [&#34;rm -rf /&#34;, &#34;format&#34;, &#34;:(){:|:&amp;};:&#34;]
         for pattern in dangerous_patterns:
             if pattern in command:
                 return False, f&#34;Command contains dangerous pattern: {pattern}&#34;
-        
+
         # Add more validation as needed
         return True, None
     ```
@@ -282,11 +280,7 @@
 def execute_with_timeout(command, timeout=30):
     try:
         result = subprocess.run(
-            command, 
-            shell=True, 
-            capture_output=True, 
-            text=True, 
-            timeout=timeout
+            command, shell=True, capture_output=True, text=True, timeout=timeout
         )
         return result.stdout + result.stderr
     except subprocess.TimeoutExpired:
@@ -303,7 +297,7 @@
 commands = [
     &#34;cd /tmp&#34;,
     &#34;echo &#39;Hello&#39; &gt; test.txt&#34;,
-    &#34;cat test.txt&#34;  # This works because we&#39;re still in /tmp
+    &#34;cat test.txt&#34;,  # This works because we&#39;re still in /tmp
 ]
 ```
 
@@ -314,9 +308,9 @@
 Truncate very large outputs to prevent token limit issues:
 ```python
 def truncate_output(output, max_lines=100):
-    lines = output.split(&#39;\n&#39;)
+    lines = output.split(&#34;\n&#34;)
     if len(lines) &gt; max_lines:
-        truncated = &#39;\n&#39;.join(lines[:max_lines])
+        truncated = &#34;\n&#34;.join(lines[:max_lines])
         return f&#34;{truncated}\n\n... Output truncated ({len(lines)} total lines) ...&#34;
     return output
 ```
@@ -328,6 +322,7 @@
 Keep an audit trail of executed commands:
 ```python
 import logging
+
 
 def log_command(command, output, user_id):
     logging.info(f&#34;User {user_id} executed: {command}&#34;)
@@ -343,9 +338,12 @@
 def sanitize_output(output):
     # Remove potential secrets or credentials
     import re
+
     # Example: Remove AWS credentials
-    output = re.sub(r&#39;aws_access_key_id\s*=\s*\S+&#39;, &#39;aws_access_key_id=***&#39;, output)
-    output = re.sub(r&#39;aws_secret_access_key\s*=\s*\S+&#39;, &#39;aws_secret_access_key=***&#39;, output)
+    output = re.sub(r&#34;aws_access_key_id\s*=\s*\S+&#34;, &#34;aws_access_key_id=***&#34;, output)
+    output = re.sub(
+        r&#34;aws_secret_access_key\s*=\s*\S+&#34;, &#34;aws_secret_access_key=***&#34;, output
+    )
     return output
 ```
 
</code></pre>
    </div>
</body>
</html>