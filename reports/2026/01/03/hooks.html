<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hooks - Diff Report</title>
    <link rel="stylesheet" href="../../css/diff.css">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --card-bg: #16213e;
            --text-color: #eee;
            --accent: #0f3460;
            --add-bg: #1a4d1a;
            --del-bg: #4d1a1a;
            --add-text: #4ade80;
            --del-text: #f87171;
        }
        @media (prefers-color-scheme: light) {
            :root {
                --bg-color: #f5f5f5;
                --card-bg: #fff;
                --text-color: #333;
                --accent: #e0e0e0;
                --add-bg: #d4edda;
                --del-bg: #f8d7da;
                --add-text: #155724;
                --del-text: #721c24;
            }
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 2rem;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        header { margin-bottom: 2rem; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .meta { color: #888; font-size: 0.9rem; }
        .summary {
            background: var(--card-bg);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            display: flex;
            gap: 2rem;
        }
        .stat { display: flex; align-items: center; gap: 0.5rem; }
        .stat.added { color: var(--add-text); }
        .stat.removed { color: var(--del-text); }
        .diff-container {
            background: var(--card-bg);
            border-radius: 8px;
            overflow: hidden;
        }
        .diff-header {
            background: var(--accent);
            padding: 0.75rem 1rem;
            font-weight: 600;
        }
        .diff-content {
            padding: 1rem;
            overflow-x: auto;
        }
        .diff-content ins {
            background: var(--add-bg);
            color: var(--add-text);
            text-decoration: none;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        .diff-content del {
            background: var(--del-bg);
            color: var(--del-text);
            text-decoration: line-through;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        pre {
            background: var(--accent);
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.85rem;
            margin-top: 2rem;
        }
        a { color: #60a5fa; }
        .back-link { margin-bottom: 1rem; display: inline-block; }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">&larr; Back to daily report</a>

        <header>
            <h1>hooks.md</h1>
            <p class="meta">Changed on 2026-01-03 20:36:25 UTC</p>
        </header>

        <div class="summary">
            <div class="stat added">
                <span>+577</span> lines added
            </div>
            <div class="stat removed">
                <span>-0</span> lines removed
            </div>
        </div>

        <div class="diff-container">
            <div class="diff-header">Visual Diff</div>
            <div class="diff-content"><ins style="background:#e6ffe6;"># Hooks reference&para;<br>&para;<br>&gt; This page provides reference documentation for implementing hooks in Claude Code.&para;<br>&para;<br>&lt;Tip&gt;&para;<br>  For a quickstart guide with examples, see [Get started with Claude Code hooks](/en/hooks-guide).&para;<br>&lt;/Tip&gt;&para;<br>&para;<br>## Configuration&para;<br>&para;<br>Claude Code hooks are configured in your [settings files](/en/settings):&para;<br>&para;<br>* `~/.claude/settings.json` - User settings&para;<br>* `.claude/settings.json` - Project settings&para;<br>* `.claude/settings.local.json` - Local project settings (not committed)&para;<br>* Enterprise managed policy settings&para;<br>&para;<br>&lt;Note&gt;&para;<br>  Enterprise administrators can use `allowManagedHooksOnly` to block user, project, and plugin hooks. See [Hook configuration](/en/settings#hook-configuration).&para;<br>&lt;/Note&gt;&para;<br>&para;<br>### Structure&para;<br>&para;<br>Hooks are organized by matchers, where each matcher can have multiple hooks:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "EventName": [&para;<br>      {&para;<br>        "matcher": "ToolPattern",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "your-command-here"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>* **matcher**: Pattern to match tool names, case-sensitive (only applicable for&para;<br>  `PreToolUse`, `PermissionRequest`, and `PostToolUse`)&para;<br>  * Simple strings match exactly: `Write` matches only the Write tool&para;<br>  * Supports regex: `Edit|Write` or `Notebook.*`&para;<br>  * Use `*` to match all tools. You can also use empty string (`""`) or leave&para;<br>    `matcher` blank.&para;<br>* **hooks**: Array of hooks to execute when the pattern matches&para;<br>  * `type`: Hook execution type - `"command"` for bash commands or `"prompt"` for LLM-based evaluation&para;<br>  * `command`: (For `type: "command"`) The bash command to execute (can use `$CLAUDE_PROJECT_DIR` environment variable)&para;<br>  * `prompt`: (For `type: "prompt"`) The prompt to send to the LLM for evaluation&para;<br>  * `timeout`: (Optional) How long a hook should run, in seconds, before canceling that specific hook&para;<br>&para;<br>For events like `UserPromptSubmit`, `Stop`, and `SubagentStop`&para;<br>that don't use matchers, you can omit the matcher field:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "UserPromptSubmit": [&para;<br>      {&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "/path/to/prompt-validator.py"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### Project-Specific Hook Scripts&para;<br>&para;<br>You can use the environment variable `CLAUDE_PROJECT_DIR` (only available when&para;<br>Claude Code spawns the hook command) to reference scripts stored in your project,&para;<br>ensuring they work regardless of Claude's current directory:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PostToolUse": [&para;<br>      {&para;<br>        "matcher": "Write|Edit",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/check-style.sh"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### Plugin hooks&para;<br>&para;<br>[Plugins](/en/plugins) can provide hooks that integrate seamlessly with your user and project hooks. Plugin hooks are automatically merged with your configuration when plugins are enabled.&para;<br>&para;<br>**How plugin hooks work**:&para;<br>&para;<br>* Plugin hooks are defined in the plugin's `hooks/hooks.json` file or in a file given by a custom path to the `hooks` field.&para;<br>* When a plugin is enabled, its hooks are merged with user and project hooks&para;<br>* Multiple hooks from different sources can respond to the same event&para;<br>* Plugin hooks use the `${CLAUDE_PLUGIN_ROOT}` environment variable to reference plugin files&para;<br>&para;<br>**Example plugin hook configuration**:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "description": "Automatic code formatting",&para;<br>  "hooks": {&para;<br>    "PostToolUse": [&para;<br>      {&para;<br>        "matcher": "Write|Edit",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "${CLAUDE_PLUGIN_ROOT}/scripts/format.sh",&para;<br>            "timeout": 30&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;Note&gt;&para;<br>  Plugin hooks use the same format as regular hooks with an optional `description` field to explain the hook's purpose.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>&lt;Note&gt;&para;<br>  Plugin hooks run alongside your custom hooks. If multiple hooks match an event, they all execute in parallel.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>**Environment variables for plugins**:&para;<br>&para;<br>* `${CLAUDE_PLUGIN_ROOT}`: Absolute path to the plugin directory&para;<br>* `${CLAUDE_PROJECT_DIR}`: Project root directory (same as for project hooks)&para;<br>* All standard environment variables are available&para;<br>&para;<br>See the [plugin components reference](/en/plugins-reference#hooks) for details on creating plugin hooks.&para;<br>&para;<br>## Prompt-Based Hooks&para;<br>&para;<br>In addition to bash command hooks (`type: "command"`), Claude Code supports prompt-based hooks (`type: "prompt"`) that use an LLM to evaluate whether to allow or block an action. Prompt-based hooks are currently only supported for `Stop` and `SubagentStop` hooks, where they enable intelligent, context-aware decisions.&para;<br>&para;<br>### How prompt-based hooks work&para;<br>&para;<br>Instead of executing a bash command, prompt-based hooks:&para;<br>&para;<br>1. Send the hook input and your prompt to a fast LLM (Haiku)&para;<br>2. The LLM responds with structured JSON containing a decision&para;<br>3. Claude Code processes the decision automatically&para;<br>&para;<br>### Configuration&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "Stop": [&para;<br>      {&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "prompt",&para;<br>            "prompt": "Evaluate if Claude should stop: $ARGUMENTS. Check if all tasks are complete."&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>**Fields:**&para;<br>&para;<br>* `type`: Must be `"prompt"`&para;<br>* `prompt`: The prompt text to send to the LLM&para;<br>  * Use `$ARGUMENTS` as a placeholder for the hook input JSON&para;<br>  * If `$ARGUMENTS` is not present, input JSON is appended to the prompt&para;<br>* `timeout`: (Optional) Timeout in seconds (default: 30 seconds)&para;<br>&para;<br>### Response schema&para;<br>&para;<br>The LLM must respond with JSON containing:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "decision": "approve" | "block",&para;<br>  "reason": "Explanation for the decision",&para;<br>  "continue": false,  // Optional: stops Claude entirely&para;<br>  "stopReason": "Message shown to user",  // Optional: custom stop message&para;<br>  "systemMessage": "Warning or context"  // Optional: shown to user&para;<br>}&para;<br>```&para;<br>&para;<br>**Response fields:**&para;<br>&para;<br>* `decision`: `"approve"` allows the action, `"block"` prevents it&para;<br>* `reason`: Explanation shown to Claude when decision is `"block"`&para;<br>* `continue`: (Optional) If `false`, stops Claude's execution entirely&para;<br>* `stopReason`: (Optional) Message shown when `continue` is false&para;<br>* `systemMessage`: (Optional) Additional message shown to the user&para;<br>&para;<br>### Supported hook events&para;<br>&para;<br>Prompt-based hooks work with any hook event, but are most useful for:&para;<br>&para;<br>* **Stop**: Intelligently decide if Claude should continue working&para;<br>* **SubagentStop**: Evaluate if a subagent has completed its task&para;<br>* **UserPromptSubmit**: Validate user prompts with LLM assistance&para;<br>* **PreToolUse**: Make context-aware permission decisions&para;<br>* **PermissionRequest**: Intelligently allow or deny permission dialogs&para;<br>&para;<br>### Example: Intelligent Stop hook&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "Stop": [&para;<br>      {&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "prompt",&para;<br>            "prompt": "You are evaluating whether Claude should stop working. Context: $ARGUMENTS\n\nAnalyze the conversation and determine if:\n1. All user-requested tasks are complete\n2. Any errors need to be addressed\n3. Follow-up work is needed\n\nRespond with JSON: {\"decision\": \"approve\" or \"block\", \"reason\": \"your explanation\"}",&para;<br>            "timeout": 30&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### Example: SubagentStop with custom logic&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "SubagentStop": [&para;<br>      {&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "prompt",&para;<br>            "prompt": "Evaluate if this subagent should stop. Input: $ARGUMENTS\n\nCheck if:\n- The subagent completed its assigned task\n- Any errors occurred that need fixing\n- Additional context gathering is needed\n\nReturn: {\"decision\": \"approve\" or \"block\", \"reason\": \"explanation\"}"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### Comparison with bash command hooks&para;<br>&para;<br>| Feature               | Bash Command Hooks      | Prompt-Based Hooks             |&para;<br>| --------------------- | ----------------------- | ------------------------------ |&para;<br>| **Execution**         | Runs bash script        | Queries LLM                    |&para;<br>| **Decision logic**    | You implement in code   | LLM evaluates context          |&para;<br>| **Setup complexity**  | Requires script file    | Configure prompt               |&para;<br>| **Context awareness** | Limited to script logic | Natural language understanding |&para;<br>| **Performance**       | Fast (local execution)  | Slower (API call)              |&para;<br>| **Use case**          | Deterministic rules     | Context-aware decisions        |&para;<br>&para;<br>### Best practices&para;<br>&para;<br>* **Be specific in prompts**: Clearly state what you want the LLM to evaluate&para;<br>* **Include decision criteria**: List the factors the LLM should consider&para;<br>* **Test your prompts**: Verify the LLM makes correct decisions for your use cases&para;<br>* **Set appropriate timeouts**: Default is 30 seconds, adjust if needed&para;<br>* **Use for complex decisions**: Bash hooks are better for simple, deterministic rules&para;<br>&para;<br>See the [plugin components reference](/en/plugins-reference#hooks) for details on creating plugin hooks.&para;<br>&para;<br>## Hook Events&para;<br>&para;<br>### PreToolUse&para;<br>&para;<br>Runs after Claude creates tool parameters and before processing the tool call.&para;<br>&para;<br>**Common matchers:**&para;<br>&para;<br>* `Task` - Subagent tasks (see [subagents documentation](/en/sub-agents))&para;<br>* `Bash` - Shell commands&para;<br>* `Glob` - File pattern matching&para;<br>* `Grep` - Content search&para;<br>* `Read` - File reading&para;<br>* `Edit` - File editing&para;<br>* `Write` - File writing&para;<br>* `WebFetch`, `WebSearch` - Web operations&para;<br>&para;<br>Use [PreToolUse decision control](#pretooluse-decision-control) to allow, deny, or ask for permission to use the tool.&para;<br>&para;<br>### PermissionRequest&para;<br>&para;<br>Runs when the user is shown a permission dialog.&para;<br>Use [PermissionRequest decision control](#permissionrequest-decision-control) to allow or deny on behalf of the user.&para;<br>&para;<br>Recognizes the same matcher values as PreToolUse.&para;<br>&para;<br>### PostToolUse&para;<br>&para;<br>Runs immediately after a tool completes successfully.&para;<br>&para;<br>Recognizes the same matcher values as PreToolUse.&para;<br>&para;<br>### Notification&para;<br>&para;<br>Runs when Claude Code sends notifications. Supports matchers to filter by notification type.&para;<br>&para;<br>**Common matchers:**&para;<br>&para;<br>* `permission_prompt` - Permission requests from Claude Code&para;<br>* `idle_prompt` - When Claude is waiting for user input (after 60+ seconds of idle time)&para;<br>* `auth_success` - Authentication success notifications&para;<br>* `elicitation_dialog` - When Claude Code needs input for MCP tool elicitation&para;<br>&para;<br>You can use matchers to run different hooks for different notification types, or omit the matcher to run hooks for all notifications.&para;<br>&para;<br>**Example: Different notifications for different types**&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "Notification": [&para;<br>      {&para;<br>        "matcher": "permission_prompt",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "/path/to/permission-alert.sh"&para;<br>          }&para;<br>        ]&para;<br>      },&para;<br>      {&para;<br>        "matcher": "idle_prompt",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "/path/to/idle-notification.sh"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### UserPromptSubmit&para;<br>&para;<br>Runs when the user submits a prompt, before Claude processes it. This allows you&para;<br>to add additional context based on the prompt/conversation, validate prompts, or&para;<br>block certain types of prompts.&para;<br>&para;<br>### Stop&para;<br>&para;<br>Runs when the main Claude Code agent has finished responding. Does not run if&para;<br>the stoppage occurred due to a user interrupt.&para;<br>&para;<br>### SubagentStop&para;<br>&para;<br>Runs when a Claude Code subagent (Task tool call) has finished responding.&para;<br>&para;<br>### PreCompact&para;<br>&para;<br>Runs before Claude Code is about to run a compact operation.&para;<br>&para;<br>**Matchers:**&para;<br>&para;<br>* `manual` - Invoked from `/compact`&para;<br>* `auto` - Invoked from auto-compact (due to full context window)&para;<br>&para;<br>### SessionStart&para;<br>&para;<br>Runs when Claude Code starts a new session or resumes an existing session (which&para;<br>currently does start a new session under the hood). Useful for loading in&para;<br>development context like existing issues or recent changes to your codebase, installing dependencies, or setting up environment variables.&para;<br>&para;<br>**Matchers:**&para;<br>&para;<br>* `startup` - Invoked from startup&para;<br>* `resume` - Invoked from `--resume`, `--continue`, or `/resume`&para;<br>* `clear` - Invoked from `/clear`&para;<br>* `compact` - Invoked from auto or manual compact.&para;<br>&para;<br>#### Persisting environment variables&para;<br>&para;<br>SessionStart hooks have access to the `CLAUDE_ENV_FILE` environment variable, which provides a file path where you can persist environment variables for subsequent bash commands.&para;<br>&para;<br>**Example: Setting individual environment variables**&para;<br>&para;<br>```bash  theme={null}&para;<br>#!/bin/bash&para;<br>&para;<br>if [ -n "$CLAUDE_ENV_FILE" ]; then&para;<br>  echo 'export NODE_ENV=production' &gt;&gt; "$CLAUDE_ENV_FILE"&para;<br>  echo 'export API_KEY=your-api-key' &gt;&gt; "$CLAUDE_ENV_FILE"&para;<br>  echo 'export PATH="$PATH:./node_modules/.bin"' &gt;&gt; "$CLAUDE_ENV_FILE"&para;<br>fi&para;<br>&para;<br>exit 0&para;<br>```&para;<br>&para;<br>**Example: Persisting all environment changes from the hook**&para;<br>&para;<br>When your setup modifies the environment (for example, `nvm use`), capture and persist all changes by diffing the environment:&para;<br>&para;<br>```bash  theme={null}&para;<br>#!/bin/bash&para;<br>&para;<br>ENV_BEFORE=$(export -p | sort)&para;<br>&para;<br># Run your setup commands that modify the environment&para;<br>source ~/.nvm/nvm.sh&para;<br>nvm use 20&para;<br>&para;<br>if [ -n "$CLAUDE_ENV_FILE" ]; then&para;<br>  ENV_AFTER=$(export -p | sort)&para;<br>  comm -13 &lt;(echo "$ENV_BEFORE") &lt;(echo "$ENV_AFTER") &gt;&gt; "$CLAUDE_ENV_FILE"&para;<br>fi&para;<br>&para;<br>exit 0&para;<br>```&para;<br>&para;<br>Any variables written to this file will be available in all subsequent bash commands that Claude Code executes during the session.&para;<br>&para;<br>&lt;Note&gt;&para;<br>  `CLAUDE_ENV_FILE` is only available for SessionStart hooks. Other hook types do not have access to this variable.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>### SessionEnd&para;<br>&para;<br>Runs when a Claude Code session ends. Useful for cleanup tasks, logging session&para;<br>statistics, or saving session state.&para;<br>&para;<br>The `reason` field in the hook input will be one of:&para;<br>&para;<br>* `clear` - Session cleared with /clear command&para;<br>* `logout` - User logged out&para;<br>* `prompt_input_exit` - User exited while prompt input was visible&para;<br>* `other` - Other exit reasons&para;<br>&para;<br>## Hook Input&para;<br>&para;<br>Hooks receive JSON data via stdin containing session information and&para;<br>event-specific data:&para;<br>&para;<br>```typescript  theme={null}&para;<br>{&para;<br>  // Common fields&para;<br>  session_id: string&para;<br>  transcript_path: string  // Path to conversation JSON&para;<br>  cwd: string              // The current working directory when the hook is invoked&para;<br>  permission_mode: string  // Current permission mode: "default", "plan", "acceptEdits", "dontAsk", or "bypassPermissions"&para;<br>&para;<br>  // Event-specific fields&para;<br>  hook_event_name: string&para;<br>  ...&para;<br>}&para;<br>```&para;<br>&para;<br>### PreToolUse Input&para;<br>&para;<br>The exact schema for `tool_input` depends on the tool.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "PreToolUse",&para;<br>  "tool_name": "Write",&para;<br>  "tool_input": {&para;<br>    "file_path": "/path/to/file.txt",&para;<br>    "content": "file content"&para;<br>  },&para;<br>  "tool_use_id": "toolu_01ABC123..."&para;<br>}&para;<br>```&para;<br>&para;<br>### PostToolUse Input&para;<br>&para;<br>The exact schema for `tool_input` and `tool_response` depends on the tool.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "PostToolUse",&para;<br>  "tool_name": "Write",&para;<br>  "tool_input": {&para;<br>    "file_path": "/path/to/file.txt",&para;<br>    "content": "file content"&para;<br>  },&para;<br>  "tool_response": {&para;<br>    "filePath": "/path/to/file.txt",&para;<br>    "success": true&para;<br>  },&para;<br>  "tool_use_id": "toolu_01ABC123..."&para;<br>}&para;<br>```&para;<br>&para;<br>### Notification Input&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "Notification",&para;<br>  "message": "Claude needs your permission to use Bash",&para;<br>  "notification_type": "permission_prompt"&para;<br>}&para;<br>```&para;<br>&para;<br>### UserPromptSubmit Input&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "UserPromptSubmit",&para;<br>  "prompt": "Write a function to calculate the factorial of a number"&para;<br>}&para;<br>```&para;<br>&para;<br>### Stop and SubagentStop Input&para;<br>&para;<br>`stop_hook_active` is true when Claude Code is already continuing as a result of&para;<br>a stop hook. Check this value or process the transcript to prevent Claude Code&para;<br>from running indefinitely.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "Stop",&para;<br>  "stop_hook_active": true&para;<br>}&para;<br>```&para;<br>&para;<br>### PreCompact Input&para;<br>&para;<br>For `manual`, `custom_instructions` comes from what the user passes into&para;<br>`/compact`. For `auto`, `custom_instructions` is empty.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "PreCompact",&para;<br>  "trigger": "manual",&para;<br>  "custom_instructions": ""&para;<br>}&para;<br>```&para;<br>&para;<br>### SessionStart Input&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "SessionStart",&para;<br>  "source": "startup"&para;<br>}&para;<br>```&para;<br>&para;<br>### SessionEnd Input&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "SessionEnd",&para;<br>  "reason": "exit"&para;<br>}&para;<br>```&para;<br>&para;<br>## Hook Output&para;<br>&para;<br>There are two mutually exclusive ways for hooks to return output back to Claude Code. The output&para;<br>communicates whether to block and any feedback that should be shown to Claude&para;<br>and the user.&para;<br>&para;<br>### Simple: Exit Code&para;<br>&para;<br>Hooks communicate status through exit codes, stdout, and stderr:&para;<br>&para;<br>* **Exit code 0**: Success. `stdout` is shown to the user in verbose mode&para;<br>  (ctrl+o), except for `UserPromptSubmit` and `SessionStart`, where stdout is&para;<br>  added to the context. JSON output in `stdout` is parsed for structured control&para;<br>  (see [Advanced: JSON Output](#advanced-json-output)).&para;<br>* **Exit code 2**: Blocking error. Only `stderr` is used as the error message&para;<br>  and fed back to Claude. The format is `[command]: {stderr}`. JSON in `stdout`&para;<br>  is **not** processed for exit code 2. See per-hook-event behavior below.&para;<br>* **Other exit codes**: Non-blocking error. `stderr` is shown to the user in verbose mode (ctrl+o) with&para;<br>  format `Failed with non-blocking status code: {stderr}`. If `stderr` is empty,&para;<br>  it shows `No stderr output`. Execution continues.&para;<br>&para;<br>&lt;Warning&gt;&para;<br>  Reminder: Claude Code does not see stdout if the exit code is 0, except for&para;<br>  the `UserPromptSubmit` hook where stdout is injected as context.&para;<br>&lt;/Warning&gt;&para;<br>&para;<br>#### Exit Code 2 Behavior&para;<br>&para;<br>| Hook Event          | Behavior                                                           |&para;<br>| ------------------- | ------------------------------------------------------------------ |&para;<br>| `PreToolUse`        | Blocks the tool call, shows stderr to Claude                       |&para;<br>| `PermissionRequest` | Denies the permission, shows stderr to Claude                      |&para;<br>| `PostToolUse`       | Shows stderr to Claude (tool already ran)                          |&para;<br>| `Notification`      | N/A, shows stderr to user only                                     |&para;<br>| `UserPromptSubmit`  | Blocks prompt processing, erases prompt, shows stderr to user only |&para;<br>| `Stop`              | Blocks stoppage, shows stderr to Claude                            |&para;<br>| `SubagentStop`      | Blocks stoppage, shows stderr to Claude subagent                   |&para;<br>| `PreCompact`        | N/A, shows stderr to user only                                     |&para;<br>| `SessionStart`      | N/A, shows stderr to user only                                     |&para;<br>| `SessionEnd`        | N/A, shows stderr to user only                                     |&para;<br>&para;<br>### Advanced: JSON Output&para;<br>&para;<br>Hooks can return structured JSON in `stdout` for more sophisticated control.&para;<br>&para;<br>&lt;Warning&gt;&para;<br>  JSON output is only processed when the hook exits with code 0. If your hook&para;<br>  exits with code 2 (blocking error), `stderr` text is used directly—any JSON in `stdout`&para;<br>  is ignored. For other non-zero exit codes, only `stderr` is shown to the user in verbose mode (ctrl+o).&para;<br>&lt;/Warning&gt;&para;<br>&para;<br>#### Common JSON Fields&para;<br>&para;<br>All hook types can include these optional fields:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "continue": true, // Whether Claude should continue after hook execution (default: true)&para;<br>  "stopReason": "string", // Message shown when continue is false&para;<br>&para;<br>  "suppressOutput": true, // Hide stdout from transcript mode (default: false)&para;<br>  "systemMessage": "string" // Optional warning message shown to the user&para;<br>}&para;<br>```&para;<br>&para;<br>If `continue` is false, Claude stops processing after the hooks run.&para;<br>&para;<br>* For `PreToolUse`, this is different from `"permissionDecision": "deny"`, which&para;<br>  only blocks a specific tool call and provides automatic feedback to Claude.&para;<br>* For `PostToolUse`, this is different from `"decision": "block"`, which&para;<br>  provides automated feedback to Claude.&para;<br>* For `UserPromptSubmit`, this prevents the prompt from being processed.&para;<br>* For `Stop` and `SubagentStop`, this takes precedence over any&para;<br>  `"decision": "block"` output.&para;<br>* In all cases, `"continue" = false` takes precedence over any&para;<br>  `"decision": "block"` output.&para;<br>&para;<br>`stopReason` accompanies `continue` with a reason shown to the user, not shown&para;<br>to Claude.&para;<br>&para;<br>#### `PreToolUse` Decision Control&para;<br>&para;<br>`PreToolUse` hooks can control whether a tool call proceeds.&para;<br>&para;<br>* `"allow"` bypasses the permission system. `permissionDecisionReason` is shown&para;<br>  to the user but not to Claude.&para;<br>* `"deny"` prevents the tool call from executing. `permissionDecisionReason` is&para;<br>  shown to Claude.&para;<br>* `"ask"` asks the user to confirm the tool call in the UI.&para;<br>  `permissionDecisionReason` is shown to the user but not to Claude.&para;<br>&para;<br>Additionally, hooks can modify tool inputs before execution using `updatedInput`:&para;<br>&para;<br>* `updatedInput` allows you to modify the tool's input parameters before the tool executes.&para;<br>* This is most useful with `"permissionDecision": "allow"` to modify and approve tool calls.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "PreToolUse",&para;<br>    "permissionDecision": "allow"&para;<br>    "permissionDecisionReason": "My reason here",&para;<br>    "updatedInput": {&para;<br>      "field_to_modify": "new value"&para;<br>    }&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;Note&gt;&para;<br>  The `decision` and `reason` fields are deprecated for PreToolUse hooks.&para;<br>  Use `hookSpecificOutput.permissionDecision` and&para;<br>  `hookSpecificOutput.permissionDecisionReason` instead. The deprecated fields&para;<br>  `"approve"` and `"block"` map to `"allow"` and `"deny"` respectively.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>#### `PermissionRequest` Decision Control&para;<br>&para;<br>`PermissionRequest` hooks can allow or deny permission requests shown to the user.&para;<br>&para;<br>* For `"behavior": "allow"` you can also optionally pass in an `"updatedInput"` that modifies the tool's input parameters before the tool executes.&para;<br>* For `"behavior": "deny"` you can also optionally pass in a `"message"` string that tells the model why the permission was denied, and a boolean `"interrupt"` which will stop Claude.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "PermissionRequest",&para;<br>    "decision": {&para;<br>      "behavior": "allow",&para;<br>      "updatedInput": {&para;<br>        "command": "npm run lint"&para;<br>      }&para;<br>    }&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>#### `PostToolUse` Decision Control&para;<br>&para;<br>`PostToolUse` hooks can provide feedback to Claude after tool execution.&para;<br>&para;<br>* `"block"` automatically prompts Claude with `reason`.&para;<br>* `undefined` does nothing. `reason` is ignored.&para;<br>* `"hookSpecificOutput.additionalContext"` adds context for Claude to consider.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "decision": "block" | undefined,&para;<br>  "reason": "Explanation for decision",&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "PostToolUse",&para;<br>    "additionalContext": "Additional information for Claude"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>#### `UserPromptSubmit` Decision Control&para;<br>&para;<br>`UserPromptSubmit` hooks can control whether a user prompt is processed and add context.&para;<br>&para;<br>**Adding context (exit code 0):**&para;<br>There are two ways to add context to the conversation:&para;<br>&para;<br>1. **Plain text stdout** (simpler): Any non-JSON text written to stdout is added&para;<br>   as context. This is the easiest way to inject information.&para;<br>&para;<br>2. **JSON with `additionalContext`** (structured): Use the JSON format below for&para;<br>   more control. The `additionalContext` field is added as context.&para;<br>&para;<br>Both methods work with exit code 0. Plain stdout is shown as hook output in&para;<br>the transcript; `additionalContext` is added more discretely.&para;<br>&para;<br>**Blocking prompts:**&para;<br>&para;<br>* `"decision": "block"` prevents the prompt from being processed. The submitted&para;<br>  prompt is erased from context. `"reason"` is shown to the user but not added&para;<br>  to context.&para;<br>* `"decision": undefined` (or omitted) allows the prompt to proceed normally.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "decision": "block" | undefined,&para;<br>  "reason": "Explanation for decision",&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "UserPromptSubmit",&para;<br>    "additionalContext": "My additional context here"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;Note&gt;&para;<br>  The JSON format isn't required for simple use cases. To add context, you can print plain text to stdout with exit code 0. Use JSON when you need to&para;<br>  block prompts or want more structured control.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>#### `Stop`/`SubagentStop` Decision Control&para;<br>&para;<br>`Stop` and `SubagentStop` hooks can control whether Claude must continue.&para;<br>&para;<br>* `"block"` prevents Claude from stopping. You must populate `reason` for Claude&para;<br>  to know how to proceed.&para;<br>* `undefined` allows Claude to stop. `reason` is ignored.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "decision": "block" | undefined,&para;<br>  "reason": "Must be provided when Claude is blocked from stopping"&para;<br>}&para;<br>```&para;<br>&para;<br>#### `SessionStart` Decision Control&para;<br>&para;<br>`SessionStart` hooks allow you to load in context at the start of a session.&para;<br>&para;<br>* `"hookSpecificOutput.additionalContext"` adds the string to the context.&para;<br>* Multiple hooks' `additionalContext` values are concatenated.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "SessionStart",&para;<br>    "additionalContext": "My additional context here"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>#### `SessionEnd` Decision Control&para;<br>&para;<br>`SessionEnd` hooks run when a session ends. They cannot block session termination&para;<br>but can perform cleanup tasks.&para;<br>&para;<br>#### Exit Code Example: Bash Command Validation&para;<br>&para;<br>```python  theme={null}&para;<br>#!/usr/bin/env python3&para;<br>import json&para;<br>import re&para;<br>import sys&para;<br>&para;<br># Define validation rules as a list of (regex pattern, message) tuples&para;<br>VALIDATION_RULES = [&para;<br>    (&para;<br>        r"\bgrep\b(?!.*\|)",&para;<br>        "Use 'rg' (ripgrep) instead of 'grep' for better performance and features",&para;<br>    ),&para;<br>    (&para;<br>        r"\bfind\s+\S+\s+-name\b",&para;<br>        "Use 'rg --files | rg pattern' or 'rg --files -g pattern' instead of 'find -name' for better performance",&para;<br>    ),&para;<br>]&para;<br>&para;<br>&para;<br>def validate_command(command: str) -&gt; list[str]:&para;<br>    issues = []&para;<br>    for pattern, message in VALIDATION_RULES:&para;<br>        if re.search(pattern, command):&para;<br>            issues.append(message)&para;<br>    return issues&para;<br>&para;<br>&para;<br>try:&para;<br>    input_data = json.load(sys.stdin)&para;<br>except json.JSONDecodeError as e:&para;<br>    print(f"Error: Invalid JSON input: {e}", file=sys.stderr)&para;<br>    sys.exit(1)&para;<br>&para;<br>tool_name = input_data.get("tool_name", "")&para;<br>tool_input = input_data.get("tool_input", {})&para;<br>command = tool_input.get("command", "")&para;<br>&para;<br>if tool_name != "Bash" or not command:&para;<br>    sys.exit(1)&para;<br>&para;<br># Validate the command&para;<br>issues = validate_command(command)&para;<br>&para;<br>if issues:&para;<br>    for message in issues:&para;<br>        print(f"• {message}", file=sys.stderr)&para;<br>    # Exit code 2 blocks tool call and shows stderr to Claude&para;<br>    sys.exit(2)&para;<br>```&para;<br>&para;<br>#### JSON Output Example: UserPromptSubmit to Add Context and Validation&para;<br>&para;<br>&lt;Note&gt;&para;<br>  For `UserPromptSubmit` hooks, you can inject context using either method:&para;<br>&para;<br>  * **Plain text stdout** with exit code 0: Simplest approach, prints text&para;<br>  * **JSON output** with exit code 0: Use `"decision": "block"` to reject prompts,&para;<br>    or `additionalContext` for structured context injection&para;<br>&para;<br>  Remember: Exit code 2 only uses `stderr` for the error message. To block using&para;<br>  JSON (with a custom reason), use `"decision": "block"` with exit code 0.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>```python  theme={null}&para;<br>#!/usr/bin/env python3&para;<br>import json&para;<br>import sys&para;<br>import re&para;<br>import datetime&para;<br>&para;<br># Load input from stdin&para;<br>try:&para;<br>    input_data = json.load(sys.stdin)&para;<br>except json.JSONDecodeError as e:&para;<br>    print(f"Error: Invalid JSON input: {e}", file=sys.stderr)&para;<br>    sys.exit(1)&para;<br>&para;<br>prompt = input_data.get("prompt", "")&para;<br>&para;<br># Check for sensitive patterns&para;<br>sensitive_patterns = [&para;<br>    (r"(?i)\b(password|secret|key|token)\s*[:=]", "Prompt contains potential secrets"),&para;<br>]&para;<br>&para;<br>for pattern, message in sensitive_patterns:&para;<br>    if re.search(pattern, prompt):&para;<br>        # Use JSON output to block with a specific reason&para;<br>        output = {&para;<br>            "decision": "block",&para;<br>            "reason": f"Security policy violation: {message}. Please rephrase your request without sensitive information."&para;<br>        }&para;<br>        print(json.dumps(output))&para;<br>        sys.exit(0)&para;<br>&para;<br># Add current time to context&para;<br>context = f"Current time: {datetime.datetime.now()}"&para;<br>print(context)&para;<br>&para;<br>"""&para;<br>The following is also equivalent:&para;<br>print(json.dumps({&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "UserPromptSubmit",&para;<br>    "additionalContext": context,&para;<br>  },&para;<br>}))&para;<br>"""&para;<br>&para;<br># Allow the prompt to proceed with the additional context&para;<br>sys.exit(0)&para;<br>```&para;<br>&para;<br>#### JSON Output Example: PreToolUse with Approval&para;<br>&para;<br>```python  theme={null}&para;<br>#!/usr/bin/env python3&para;<br>import json&para;<br>import sys&para;<br>&para;<br># Load input from stdin&para;<br>try:&para;<br>    input_data = json.load(sys.stdin)&para;<br>except json.JSONDecodeError as e:&para;<br>    print(f"Error: Invalid JSON input: {e}", file=sys.stderr)&para;<br>    sys.exit(1)&para;<br>&para;<br>tool_name = input_data.get("tool_name", "")&para;<br>tool_input = input_data.get("tool_input", {})&para;<br>&para;<br># Example: Auto-approve file reads for documentation files&para;<br>if tool_name == "Read":&para;<br>    file_path = tool_input.get("file_path", "")&para;<br>    if file_path.endswith((".md", ".mdx", ".txt", ".json")):&para;<br>        # Use JSON output to auto-approve the tool call&para;<br>        output = {&para;<br>            "decision": "approve",&para;<br>            "reason": "Documentation file auto-approved",&para;<br>            "suppressOutput": True  # Don't show in verbose mode&para;<br>        }&para;<br>        print(json.dumps(output))&para;<br>        sys.exit(0)&para;<br>&para;<br># For other cases, let the normal permission flow proceed&para;<br>sys.exit(0)&para;<br>```&para;<br>&para;<br>## Working with MCP Tools&para;<br>&para;<br>Claude Code hooks work seamlessly with&para;<br>[Model Context Protocol (MCP) tools](/en/mcp). When MCP servers&para;<br>provide tools, they appear with a special naming pattern that you can match in&para;<br>your hooks.&para;<br>&para;<br>### MCP Tool Naming&para;<br>&para;<br>MCP tools follow the pattern `mcp__&lt;server&gt;__&lt;tool&gt;`, for example:&para;<br>&para;<br>* `mcp__memory__create_entities` - Memory server's create entities tool&para;<br>* `mcp__filesystem__read_file` - Filesystem server's read file tool&para;<br>* `mcp__github__search_repositories` - GitHub server's search tool&para;<br>&para;<br>### Configuring Hooks for MCP Tools&para;<br>&para;<br>You can target specific MCP tools or entire MCP servers:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PreToolUse": [&para;<br>      {&para;<br>        "matcher": "mcp__memory__.*",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "echo 'Memory operation initiated' &gt;&gt; ~/mcp-operations.log"&para;<br>          }&para;<br>        ]&para;<br>      },&para;<br>      {&para;<br>        "matcher": "mcp__.*__write.*",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "/home/user/scripts/validate-mcp-write.py"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>## Examples&para;<br>&para;<br>&lt;Tip&gt;&para;<br>  For practical examples including code formatting, notifications, and file protection, see [More Examples](/en/hooks-guide#more-examples) in the get started guide.&para;<br>&lt;/Tip&gt;&para;<br>&para;<br>## Security Considerations&para;<br>&para;<br>### Disclaimer&para;<br>&para;<br>**USE AT YOUR OWN RISK**: Claude Code hooks execute arbitrary shell commands on&para;<br>your system automatically. By using hooks, you acknowledge that:&para;<br>&para;<br>* You are solely responsible for the commands you configure&para;<br>* Hooks can modify, delete, or access any files your user account can access&para;<br>* Malicious or poorly written hooks can cause data loss or system damage&para;<br>* Anthropic provides no warranty and assumes no liability for any damages&para;<br>  resulting from hook usage&para;<br>* You should thoroughly test hooks in a safe environment before production use&para;<br>&para;<br>Always review and understand any hook commands before adding them to your&para;<br>configuration.&para;<br>&para;<br>### Security Best Practices&para;<br>&para;<br>Here are some key practices for writing more secure hooks:&para;<br>&para;<br>1. **Validate and sanitize inputs** - Never trust input data blindly&para;<br>2. **Always quote shell variables** - Use `"$VAR"` not `$VAR`&para;<br>3. **Block path traversal** - Check for `..` in file paths&para;<br>4. **Use absolute paths** - Specify full paths for scripts (use&para;<br>   "\$CLAUDE\_PROJECT\_DIR" for the project path)&para;<br>5. **Skip sensitive files** - Avoid `.env`, `.git/`, keys, etc.&para;<br>&para;<br>### Configuration Safety&para;<br>&para;<br>Direct edits to hooks in settings files don't take effect immediately. Claude&para;<br>Code:&para;<br>&para;<br>1. Captures a snapshot of hooks at startup&para;<br>2. Uses this snapshot throughout the session&para;<br>3. Warns if hooks are modified externally&para;<br>4. Requires review in `/hooks` menu for changes to apply&para;<br>&para;<br>This prevents malicious hook modifications from affecting your current session.&para;<br>&para;<br>## Hook Execution Details&para;<br>&para;<br>* **Timeout**: 60-second execution limit by default, configurable per command.&para;<br>  * A timeout for an individual command does not affect the other commands.&para;<br>* **Parallelization**: All matching hooks run in parallel&para;<br>* **Deduplication**: Multiple identical hook commands are deduplicated automatically&para;<br>* **Environment**: Runs in current directory with Claude Code's environment&para;<br>  * The `CLAUDE_PROJECT_DIR` environment variable is available and contains the&para;<br>    absolute path to the project root directory (where Claude Code was started)&para;<br>  * The `CLAUDE_CODE_REMOTE` environment variable indicates whether the hook is running in a remote (web) environment (`"true"`) or local CLI environment (not set or empty). Use this to run different logic based on execution context.&para;<br>* **Input**: JSON via stdin&para;<br>* **Output**:&para;<br>  * PreToolUse/PermissionRequest/PostToolUse/Stop/SubagentStop: Progress shown in verbose mode (ctrl+o)&para;<br>  * Notification/SessionEnd: Logged to debug only (`--debug`)&para;<br>  * UserPromptSubmit/SessionStart: stdout added as context for Claude&para;<br>&para;<br>## Debugging&para;<br>&para;<br>### Basic Troubleshooting&para;<br>&para;<br>If your hooks aren't working:&para;<br>&para;<br>1. **Check configuration** - Run `/hooks` to see if your hook is registered&para;<br>2. **Verify syntax** - Ensure your JSON settings are valid&para;<br>3. **Test commands** - Run hook commands manually first&para;<br>4. **Check permissions** - Make sure scripts are executable&para;<br>5. **Review logs** - Use `claude --debug` to see hook execution details&para;<br>&para;<br>Common issues:&para;<br>&para;<br>* **Quotes not escaped** - Use `\"` inside JSON strings&para;<br>* **Wrong matcher** - Check tool names match exactly (case-sensitive)&para;<br>* **Command not found** - Use full paths for scripts&para;<br>&para;<br>### Advanced Debugging&para;<br>&para;<br>For complex hook issues:&para;<br>&para;<br>1. **Inspect hook execution** - Use `claude --debug` to see detailed hook&para;<br>   execution&para;<br>2. **Validate JSON schemas** - Test hook input/output with external tools&para;<br>3. **Check environment variables** - Verify Claude Code's environment is correct&para;<br>4. **Test edge cases** - Try hooks with unusual file paths or inputs&para;<br>5. **Monitor system resources** - Check for resource exhaustion during hook&para;<br>   execution&para;<br>6. **Use structured logging** - Implement logging in your hook scripts&para;<br>&para;<br>### Debug Output Example&para;<br>&para;<br>Use `claude --debug` to see hook execution details:&para;<br>&para;<br>```&para;<br>[DEBUG] Executing hooks for PostToolUse:Write&para;<br>[DEBUG] Getting matching hook commands for PostToolUse with query: Write&para;<br>[DEBUG] Found 1 hook matchers in settings&para;<br>[DEBUG] Matched 1 hooks for query "Write"&para;<br>[DEBUG] Found 1 hook commands to execute&para;<br>[DEBUG] Executing hook command: &lt;Your command&gt; with timeout 60000ms&para;<br>[DEBUG] Hook command completed with status 0: &lt;Your stdout&gt;&para;<br>```&para;<br>&para;<br>Progress messages appear in verbose mode (ctrl+o) showing:&para;<br>&para;<br>* Which hook is running&para;<br>* Command being executed&para;<br>* Success/failure status&para;<br>* Output or error messages&para;<br>&para;<br>&para;<br>---&para;<br>&para;<br>&gt; To find navigation and other pages in this documentation, fetch the llms.txt file at: https://code.claude.com/docs/llms.txt</ins></div>
        </div>

        <h2 style="margin-top: 2rem; margin-bottom: 1rem;">Unified Diff</h2>
        <pre><code>--- a/hooks.md
+++ b/hooks.md
@@ -0,0 +1,1137 @@
+# Hooks reference
+
+&gt; This page provides reference documentation for implementing hooks in Claude Code.
+
+&lt;Tip&gt;
+  For a quickstart guide with examples, see [Get started with Claude Code hooks](/en/hooks-guide).
+&lt;/Tip&gt;
+
+## Configuration
+
+Claude Code hooks are configured in your [settings files](/en/settings):
+
+* `~/.claude/settings.json` - User settings
+* `.claude/settings.json` - Project settings
+* `.claude/settings.local.json` - Local project settings (not committed)
+* Enterprise managed policy settings
+
+&lt;Note&gt;
+  Enterprise administrators can use `allowManagedHooksOnly` to block user, project, and plugin hooks. See [Hook configuration](/en/settings#hook-configuration).
+&lt;/Note&gt;
+
+### Structure
+
+Hooks are organized by matchers, where each matcher can have multiple hooks:
+
+```json  theme={null}
+{
+  &#34;hooks&#34;: {
+    &#34;EventName&#34;: [
+      {
+        &#34;matcher&#34;: &#34;ToolPattern&#34;,
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;command&#34;,
+            &#34;command&#34;: &#34;your-command-here&#34;
+          }
+        ]
+      }
+    ]
+  }
+}
+```
+
+* **matcher**: Pattern to match tool names, case-sensitive (only applicable for
+  `PreToolUse`, `PermissionRequest`, and `PostToolUse`)
+  * Simple strings match exactly: `Write` matches only the Write tool
+  * Supports regex: `Edit|Write` or `Notebook.*`
+  * Use `*` to match all tools. You can also use empty string (`&#34;&#34;`) or leave
+    `matcher` blank.
+* **hooks**: Array of hooks to execute when the pattern matches
+  * `type`: Hook execution type - `&#34;command&#34;` for bash commands or `&#34;prompt&#34;` for LLM-based evaluation
+  * `command`: (For `type: &#34;command&#34;`) The bash command to execute (can use `$CLAUDE_PROJECT_DIR` environment variable)
+  * `prompt`: (For `type: &#34;prompt&#34;`) The prompt to send to the LLM for evaluation
+  * `timeout`: (Optional) How long a hook should run, in seconds, before canceling that specific hook
+
+For events like `UserPromptSubmit`, `Stop`, and `SubagentStop`
+that don&#39;t use matchers, you can omit the matcher field:
+
+```json  theme={null}
+{
+  &#34;hooks&#34;: {
+    &#34;UserPromptSubmit&#34;: [
+      {
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;command&#34;,
+            &#34;command&#34;: &#34;/path/to/prompt-validator.py&#34;
+          }
+        ]
+      }
+    ]
+  }
+}
+```
+
+### Project-Specific Hook Scripts
+
+You can use the environment variable `CLAUDE_PROJECT_DIR` (only available when
+Claude Code spawns the hook command) to reference scripts stored in your project,
+ensuring they work regardless of Claude&#39;s current directory:
+
+```json  theme={null}
+{
+  &#34;hooks&#34;: {
+    &#34;PostToolUse&#34;: [
+      {
+        &#34;matcher&#34;: &#34;Write|Edit&#34;,
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;command&#34;,
+            &#34;command&#34;: &#34;\&#34;$CLAUDE_PROJECT_DIR\&#34;/.claude/hooks/check-style.sh&#34;
+          }
+        ]
+      }
+    ]
+  }
+}
+```
+
+### Plugin hooks
+
+[Plugins](/en/plugins) can provide hooks that integrate seamlessly with your user and project hooks. Plugin hooks are automatically merged with your configuration when plugins are enabled.
+
+**How plugin hooks work**:
+
+* Plugin hooks are defined in the plugin&#39;s `hooks/hooks.json` file or in a file given by a custom path to the `hooks` field.
+* When a plugin is enabled, its hooks are merged with user and project hooks
+* Multiple hooks from different sources can respond to the same event
+* Plugin hooks use the `${CLAUDE_PLUGIN_ROOT}` environment variable to reference plugin files
+
+**Example plugin hook configuration**:
+
+```json  theme={null}
+{
+  &#34;description&#34;: &#34;Automatic code formatting&#34;,
+  &#34;hooks&#34;: {
+    &#34;PostToolUse&#34;: [
+      {
+        &#34;matcher&#34;: &#34;Write|Edit&#34;,
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;command&#34;,
+            &#34;command&#34;: &#34;${CLAUDE_PLUGIN_ROOT}/scripts/format.sh&#34;,
+            &#34;timeout&#34;: 30
+          }
+        ]
+      }
+    ]
+  }
+}
+```
+
+&lt;Note&gt;
+  Plugin hooks use the same format as regular hooks with an optional `description` field to explain the hook&#39;s purpose.
+&lt;/Note&gt;
+
+&lt;Note&gt;
+  Plugin hooks run alongside your custom hooks. If multiple hooks match an event, they all execute in parallel.
+&lt;/Note&gt;
+
+**Environment variables for plugins**:
+
+* `${CLAUDE_PLUGIN_ROOT}`: Absolute path to the plugin directory
+* `${CLAUDE_PROJECT_DIR}`: Project root directory (same as for project hooks)
+* All standard environment variables are available
+
+See the [plugin components reference](/en/plugins-reference#hooks) for details on creating plugin hooks.
+
+## Prompt-Based Hooks
+
+In addition to bash command hooks (`type: &#34;command&#34;`), Claude Code supports prompt-based hooks (`type: &#34;prompt&#34;`) that use an LLM to evaluate whether to allow or block an action. Prompt-based hooks are currently only supported for `Stop` and `SubagentStop` hooks, where they enable intelligent, context-aware decisions.
+
+### How prompt-based hooks work
+
+Instead of executing a bash command, prompt-based hooks:
+
+1. Send the hook input and your prompt to a fast LLM (Haiku)
+2. The LLM responds with structured JSON containing a decision
+3. Claude Code processes the decision automatically
+
+### Configuration
+
+```json  theme={null}
+{
+  &#34;hooks&#34;: {
+    &#34;Stop&#34;: [
+      {
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;prompt&#34;,
+            &#34;prompt&#34;: &#34;Evaluate if Claude should stop: $ARGUMENTS. Check if all tasks are complete.&#34;
+          }
+        ]
+      }
+    ]
+  }
+}
+```
+
+**Fields:**
+
+* `type`: Must be `&#34;prompt&#34;`
+* `prompt`: The prompt text to send to the LLM
+  * Use `$ARGUMENTS` as a placeholder for the hook input JSON
+  * If `$ARGUMENTS` is not present, input JSON is appended to the prompt
+* `timeout`: (Optional) Timeout in seconds (default: 30 seconds)
+
+### Response schema
+
+The LLM must respond with JSON containing:
+
+```json  theme={null}
+{
+  &#34;decision&#34;: &#34;approve&#34; | &#34;block&#34;,
+  &#34;reason&#34;: &#34;Explanation for the decision&#34;,
+  &#34;continue&#34;: false,  // Optional: stops Claude entirely
+  &#34;stopReason&#34;: &#34;Message shown to user&#34;,  // Optional: custom stop message
+  &#34;systemMessage&#34;: &#34;Warning or context&#34;  // Optional: shown to user
+}
+```
+
+**Response fields:**
+
+* `decision`: `&#34;approve&#34;` allows the action, `&#34;block&#34;` prevents it
+* `reason`: Explanation shown to Claude when decision is `&#34;block&#34;`
+* `continue`: (Optional) If `false`, stops Claude&#39;s execution entirely
+* `stopReason`: (Optional) Message shown when `continue` is false
+* `systemMessage`: (Optional) Additional message shown to the user
+
+### Supported hook events
+
+Prompt-based hooks work with any hook event, but are most useful for:
+
+* **Stop**: Intelligently decide if Claude should continue working
+* **SubagentStop**: Evaluate if a subagent has completed its task
+* **UserPromptSubmit**: Validate user prompts with LLM assistance
+* **PreToolUse**: Make context-aware permission decisions
+* **PermissionRequest**: Intelligently allow or deny permission dialogs
+
+### Example: Intelligent Stop hook
+
+```json  theme={null}
+{
+  &#34;hooks&#34;: {
+    &#34;Stop&#34;: [
+      {
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;prompt&#34;,
+            &#34;prompt&#34;: &#34;You are evaluating whether Claude should stop working. Context: $ARGUMENTS\n\nAnalyze the conversation and determine if:\n1. All user-requested tasks are complete\n2. Any errors need to be addressed\n3. Follow-up work is needed\n\nRespond with JSON: {\&#34;decision\&#34;: \&#34;approve\&#34; or \&#34;block\&#34;, \&#34;reason\&#34;: \&#34;your explanation\&#34;}&#34;,
+            &#34;timeout&#34;: 30
+          }
+        ]
+      }
+    ]
+  }
+}
+```
+
+### Example: SubagentStop with custom logic
+
+```json  theme={null}
+{
+  &#34;hooks&#34;: {
+    &#34;SubagentStop&#34;: [
+      {
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;prompt&#34;,
+            &#34;prompt&#34;: &#34;Evaluate if this subagent should stop. Input: $ARGUMENTS\n\nCheck if:\n- The subagent completed its assigned task\n- Any errors occurred that need fixing\n- Additional context gathering is needed\n\nReturn: {\&#34;decision\&#34;: \&#34;approve\&#34; or \&#34;block\&#34;, \&#34;reason\&#34;: \&#34;explanation\&#34;}&#34;
+          }
+        ]
+      }
+    ]
+  }
+}
+```
+
+### Comparison with bash command hooks
+
+| Feature               | Bash Command Hooks      | Prompt-Based Hooks             |
+| --------------------- | ----------------------- | ------------------------------ |
+| **Execution**         | Runs bash script        | Queries LLM                    |
+| **Decision logic**    | You implement in code   | LLM evaluates context          |
+| **Setup complexity**  | Requires script file    | Configure prompt               |
+| **Context awareness** | Limited to script logic | Natural language understanding |
+| **Performance**       | Fast (local execution)  | Slower (API call)              |
+| **Use case**          | Deterministic rules     | Context-aware decisions        |
+
+### Best practices
+
+* **Be specific in prompts**: Clearly state what you want the LLM to evaluate
+* **Include decision criteria**: List the factors the LLM should consider
+* **Test your prompts**: Verify the LLM makes correct decisions for your use cases
+* **Set appropriate timeouts**: Default is 30 seconds, adjust if needed
+* **Use for complex decisions**: Bash hooks are better for simple, deterministic rules
+
+See the [plugin components reference](/en/plugins-reference#hooks) for details on creating plugin hooks.
+
+## Hook Events
+
+### PreToolUse
+
+Runs after Claude creates tool parameters and before processing the tool call.
+
+**Common matchers:**
+
+* `Task` - Subagent tasks (see [subagents documentation](/en/sub-agents))
+* `Bash` - Shell commands
+* `Glob` - File pattern matching
+* `Grep` - Content search
+* `Read` - File reading
+* `Edit` - File editing
+* `Write` - File writing
+* `WebFetch`, `WebSearch` - Web operations
+
+Use [PreToolUse decision control](#pretooluse-decision-control) to allow, deny, or ask for permission to use the tool.
+
+### PermissionRequest
+
+Runs when the user is shown a permission dialog.
+Use [PermissionRequest decision control](#permissionrequest-decision-control) to allow or deny on behalf of the user.
+
+Recognizes the same matcher values as PreToolUse.
+
+### PostToolUse
+
+Runs immediately after a tool completes successfully.
+
+Recognizes the same matcher values as PreToolUse.
+
+### Notification
+
+Runs when Claude Code sends notifications. Supports matchers to filter by notification type.
+
+**Common matchers:**
+
+* `permission_prompt` - Permission requests from Claude Code
+* `idle_prompt` - When Claude is waiting for user input (after 60+ seconds of idle time)
+* `auth_success` - Authentication success notifications
+* `elicitation_dialog` - When Claude Code needs input for MCP tool elicitation
+
+You can use matchers to run different hooks for different notification types, or omit the matcher to run hooks for all notifications.
+
+**Example: Different notifications for different types**
+
+```json  theme={null}
+{
+  &#34;hooks&#34;: {
+    &#34;Notification&#34;: [
+      {
+        &#34;matcher&#34;: &#34;permission_prompt&#34;,
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;command&#34;,
+            &#34;command&#34;: &#34;/path/to/permission-alert.sh&#34;
+          }
+        ]
+      },
+      {
+        &#34;matcher&#34;: &#34;idle_prompt&#34;,
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;command&#34;,
+            &#34;command&#34;: &#34;/path/to/idle-notification.sh&#34;
+          }
+        ]
+      }
+    ]
+  }
+}
+```
+
+### UserPromptSubmit
+
+Runs when the user submits a prompt, before Claude processes it. This allows you
+to add additional context based on the prompt/conversation, validate prompts, or
+block certain types of prompts.
+
+### Stop
+
+Runs when the main Claude Code agent has finished responding. Does not run if
+the stoppage occurred due to a user interrupt.
+
+### SubagentStop
+
+Runs when a Claude Code subagent (Task tool call) has finished responding.
+
+### PreCompact
+
+Runs before Claude Code is about to run a compact operation.
+
+**Matchers:**
+
+* `manual` - Invoked from `/compact`
+* `auto` - Invoked from auto-compact (due to full context window)
+
+### SessionStart
+
+Runs when Claude Code starts a new session or resumes an existing session (which
+currently does start a new session under the hood). Useful for loading in
+development context like existing issues or recent changes to your codebase, installing dependencies, or setting up environment variables.
+
+**Matchers:**
+
+* `startup` - Invoked from startup
+* `resume` - Invoked from `--resume`, `--continue`, or `/resume`
+* `clear` - Invoked from `/clear`
+* `compact` - Invoked from auto or manual compact.
+
+#### Persisting environment variables
+
+SessionStart hooks have access to the `CLAUDE_ENV_FILE` environment variable, which provides a file path where you can persist environment variables for subsequent bash commands.
+
+**Example: Setting individual environment variables**
+
+```bash  theme={null}
+#!/bin/bash
+
+if [ -n &#34;$CLAUDE_ENV_FILE&#34; ]; then
+  echo &#39;export NODE_ENV=production&#39; &gt;&gt; &#34;$CLAUDE_ENV_FILE&#34;
+  echo &#39;export API_KEY=your-api-key&#39; &gt;&gt; &#34;$CLAUDE_ENV_FILE&#34;
+  echo &#39;export PATH=&#34;$PATH:./node_modules/.bin&#34;&#39; &gt;&gt; &#34;$CLAUDE_ENV_FILE&#34;
+fi
+
+exit 0
+```
+
+**Example: Persisting all environment changes from the hook**
+
+When your setup modifies the environment (for example, `nvm use`), capture and persist all changes by diffing the environment:
+
+```bash  theme={null}
+#!/bin/bash
+
+ENV_BEFORE=$(export -p | sort)
+
+# Run your setup commands that modify the environment
+source ~/.nvm/nvm.sh
+nvm use 20
+
+if [ -n &#34;$CLAUDE_ENV_FILE&#34; ]; then
+  ENV_AFTER=$(export -p | sort)
+  comm -13 &lt;(echo &#34;$ENV_BEFORE&#34;) &lt;(echo &#34;$ENV_AFTER&#34;) &gt;&gt; &#34;$CLAUDE_ENV_FILE&#34;
+fi
+
+exit 0
+```
+
+Any variables written to this file will be available in all subsequent bash commands that Claude Code executes during the session.
+
+&lt;Note&gt;
+  `CLAUDE_ENV_FILE` is only available for SessionStart hooks. Other hook types do not have access to this variable.
+&lt;/Note&gt;
+
+### SessionEnd
+
+Runs when a Claude Code session ends. Useful for cleanup tasks, logging session
+statistics, or saving session state.
+
+The `reason` field in the hook input will be one of:
+
+* `clear` - Session cleared with /clear command
+* `logout` - User logged out
+* `prompt_input_exit` - User exited while prompt input was visible
+* `other` - Other exit reasons
+
+## Hook Input
+
+Hooks receive JSON data via stdin containing session information and
+event-specific data:
+
+```typescript  theme={null}
+{
+  // Common fields
+  session_id: string
+  transcript_path: string  // Path to conversation JSON
+  cwd: string              // The current working directory when the hook is invoked
+  permission_mode: string  // Current permission mode: &#34;default&#34;, &#34;plan&#34;, &#34;acceptEdits&#34;, &#34;dontAsk&#34;, or &#34;bypassPermissions&#34;
+
+  // Event-specific fields
+  hook_event_name: string
+  ...
+}
+```
+
+### PreToolUse Input
+
+The exact schema for `tool_input` depends on the tool.
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;cwd&#34;: &#34;/Users/...&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;PreToolUse&#34;,
+  &#34;tool_name&#34;: &#34;Write&#34;,
+  &#34;tool_input&#34;: {
+    &#34;file_path&#34;: &#34;/path/to/file.txt&#34;,
+    &#34;content&#34;: &#34;file content&#34;
+  },
+  &#34;tool_use_id&#34;: &#34;toolu_01ABC123...&#34;
+}
+```
+
+### PostToolUse Input
+
+The exact schema for `tool_input` and `tool_response` depends on the tool.
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;cwd&#34;: &#34;/Users/...&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;PostToolUse&#34;,
+  &#34;tool_name&#34;: &#34;Write&#34;,
+  &#34;tool_input&#34;: {
+    &#34;file_path&#34;: &#34;/path/to/file.txt&#34;,
+    &#34;content&#34;: &#34;file content&#34;
+  },
+  &#34;tool_response&#34;: {
+    &#34;filePath&#34;: &#34;/path/to/file.txt&#34;,
+    &#34;success&#34;: true
+  },
+  &#34;tool_use_id&#34;: &#34;toolu_01ABC123...&#34;
+}
+```
+
+### Notification Input
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;cwd&#34;: &#34;/Users/...&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;Notification&#34;,
+  &#34;message&#34;: &#34;Claude needs your permission to use Bash&#34;,
+  &#34;notification_type&#34;: &#34;permission_prompt&#34;
+}
+```
+
+### UserPromptSubmit Input
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;cwd&#34;: &#34;/Users/...&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;UserPromptSubmit&#34;,
+  &#34;prompt&#34;: &#34;Write a function to calculate the factorial of a number&#34;
+}
+```
+
+### Stop and SubagentStop Input
+
+`stop_hook_active` is true when Claude Code is already continuing as a result of
+a stop hook. Check this value or process the transcript to prevent Claude Code
+from running indefinitely.
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;Stop&#34;,
+  &#34;stop_hook_active&#34;: true
+}
+```
+
+### PreCompact Input
+
+For `manual`, `custom_instructions` comes from what the user passes into
+`/compact`. For `auto`, `custom_instructions` is empty.
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;PreCompact&#34;,
+  &#34;trigger&#34;: &#34;manual&#34;,
+  &#34;custom_instructions&#34;: &#34;&#34;
+}
+```
+
+### SessionStart Input
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;SessionStart&#34;,
+  &#34;source&#34;: &#34;startup&#34;
+}
+```
+
+### SessionEnd Input
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;cwd&#34;: &#34;/Users/...&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;SessionEnd&#34;,
+  &#34;reason&#34;: &#34;exit&#34;
+}
+```
+
+## Hook Output
+
+There are two mutually exclusive ways for hooks to return output back to Claude Code. The output
+communicates whether to block and any feedback that should be shown to Claude
+and the user.
+
+### Simple: Exit Code
+
+Hooks communicate status through exit codes, stdout, and stderr:
+
+* **Exit code 0**: Success. `stdout` is shown to the user in verbose mode
+  (ctrl+o), except for `UserPromptSubmit` and `SessionStart`, where stdout is
+  added to the context. JSON output in `stdout` is parsed for structured control
+  (see [Advanced: JSON Output](#advanced-json-output)).
+* **Exit code 2**: Blocking error. Only `stderr` is used as the error message
+  and fed back to Claude. The format is `[command]: {stderr}`. JSON in `stdout`
+  is **not** processed for exit code 2. See per-hook-event behavior below.
+* **Other exit codes**: Non-blocking error. `stderr` is shown to the user in verbose mode (ctrl+o) with
+  format `Failed with non-blocking status code: {stderr}`. If `stderr` is empty,
+  it shows `No stderr output`. Execution continues.
+
+&lt;Warning&gt;
+  Reminder: Claude Code does not see stdout if the exit code is 0, except for
+  the `UserPromptSubmit` hook where stdout is injected as context.
+&lt;/Warning&gt;
+
+#### Exit Code 2 Behavior
+
+| Hook Event          | Behavior                                                           |
+| ------------------- | ------------------------------------------------------------------ |
+| `PreToolUse`        | Blocks the tool call, shows stderr to Claude                       |
+| `PermissionRequest` | Denies the permission, shows stderr to Claude                      |
+| `PostToolUse`       | Shows stderr to Claude (tool already ran)                          |
+| `Notification`      | N/A, shows stderr to user only                                     |
+| `UserPromptSubmit`  | Blocks prompt processing, erases prompt, shows stderr to user only |
+| `Stop`              | Blocks stoppage, shows stderr to Claude                            |
+| `SubagentStop`      | Blocks stoppage, shows stderr to Claude subagent                   |
+| `PreCompact`        | N/A, shows stderr to user only                                     |
+| `SessionStart`      | N/A, shows stderr to user only                                     |
+| `SessionEnd`        | N/A, shows stderr to user only                                     |
+
+### Advanced: JSON Output
+
+Hooks can return structured JSON in `stdout` for more sophisticated control.
+
+&lt;Warning&gt;
+  JSON output is only processed when the hook exits with code 0. If your hook
+  exits with code 2 (blocking error), `stderr` text is used directly—any JSON in `stdout`
+  is ignored. For other non-zero exit codes, only `stderr` is shown to the user in verbose mode (ctrl+o).
+&lt;/Warning&gt;
+
+#### Common JSON Fields
+
+All hook types can include these optional fields:
+
+```json  theme={null}
+{
+  &#34;continue&#34;: true, // Whether Claude should continue after hook execution (default: true)
+  &#34;stopReason&#34;: &#34;string&#34;, // Message shown when continue is false
+
+  &#34;suppressOutput&#34;: true, // Hide stdout from transcript mode (default: false)
+  &#34;systemMessage&#34;: &#34;string&#34; // Optional warning message shown to the user
+}
+```
+
+If `continue` is false, Claude stops processing after the hooks run.
+
+* For `PreToolUse`, this is different from `&#34;permissionDecision&#34;: &#34;deny&#34;`, which
+  only blocks a specific tool call and provides automatic feedback to Claude.
+* For `PostToolUse`, this is different from `&#34;decision&#34;: &#34;block&#34;`, which
+  provides automated feedback to Claude.
+* For `UserPromptSubmit`, this prevents the prompt from being processed.
+* For `Stop` and `SubagentStop`, this takes precedence over any
+  `&#34;decision&#34;: &#34;block&#34;` output.
+* In all cases, `&#34;continue&#34; = false` takes precedence over any
+  `&#34;decision&#34;: &#34;block&#34;` output.
+
+`stopReason` accompanies `continue` with a reason shown to the user, not shown
+to Claude.
+
+#### `PreToolUse` Decision Control
+
+`PreToolUse` hooks can control whether a tool call proceeds.
+
+* `&#34;allow&#34;` bypasses the permission system. `permissionDecisionReason` is shown
+  to the user but not to Claude.
+* `&#34;deny&#34;` prevents the tool call from executing. `permissionDecisionReason` is
+  shown to Claude.
+* `&#34;ask&#34;` asks the user to confirm the tool call in the UI.
+  `permissionDecisionReason` is shown to the user but not to Claude.
+
+Additionally, hooks can modify tool inputs before execution using `updatedInput`:
+
+* `updatedInput` allows you to modify the tool&#39;s input parameters before the tool executes.
+* This is most useful with `&#34;permissionDecision&#34;: &#34;allow&#34;` to modify and approve tool calls.
+
+```json  theme={null}
+{
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;PreToolUse&#34;,
+    &#34;permissionDecision&#34;: &#34;allow&#34;
+    &#34;permissionDecisionReason&#34;: &#34;My reason here&#34;,
+    &#34;updatedInput&#34;: {
+      &#34;field_to_modify&#34;: &#34;new value&#34;
+    }
+  }
+}
+```
+
+&lt;Note&gt;
+  The `decision` and `reason` fields are deprecated for PreToolUse hooks.
+  Use `hookSpecificOutput.permissionDecision` and
+  `hookSpecificOutput.permissionDecisionReason` instead. The deprecated fields
+  `&#34;approve&#34;` and `&#34;block&#34;` map to `&#34;allow&#34;` and `&#34;deny&#34;` respectively.
+&lt;/Note&gt;
+
+#### `PermissionRequest` Decision Control
+
+`PermissionRequest` hooks can allow or deny permission requests shown to the user.
+
+* For `&#34;behavior&#34;: &#34;allow&#34;` you can also optionally pass in an `&#34;updatedInput&#34;` that modifies the tool&#39;s input parameters before the tool executes.
+* For `&#34;behavior&#34;: &#34;deny&#34;` you can also optionally pass in a `&#34;message&#34;` string that tells the model why the permission was denied, and a boolean `&#34;interrupt&#34;` which will stop Claude.
+
+```json  theme={null}
+{
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;PermissionRequest&#34;,
+    &#34;decision&#34;: {
+      &#34;behavior&#34;: &#34;allow&#34;,
+      &#34;updatedInput&#34;: {
+        &#34;command&#34;: &#34;npm run lint&#34;
+      }
+    }
+  }
+}
+```
+
+#### `PostToolUse` Decision Control
+
+`PostToolUse` hooks can provide feedback to Claude after tool execution.
+
+* `&#34;block&#34;` automatically prompts Claude with `reason`.
+* `undefined` does nothing. `reason` is ignored.
+* `&#34;hookSpecificOutput.additionalContext&#34;` adds context for Claude to consider.
+
+```json  theme={null}
+{
+  &#34;decision&#34;: &#34;block&#34; | undefined,
+  &#34;reason&#34;: &#34;Explanation for decision&#34;,
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;PostToolUse&#34;,
+    &#34;additionalContext&#34;: &#34;Additional information for Claude&#34;
+  }
+}
+```
+
+#### `UserPromptSubmit` Decision Control
+
+`UserPromptSubmit` hooks can control whether a user prompt is processed and add context.
+
+**Adding context (exit code 0):**
+There are two ways to add context to the conversation:
+
+1. **Plain text stdout** (simpler): Any non-JSON text written to stdout is added
+   as context. This is the easiest way to inject information.
+
+2. **JSON with `additionalContext`** (structured): Use the JSON format below for
+   more control. The `additionalContext` field is added as context.
+
+Both methods work with exit code 0. Plain stdout is shown as hook output in
+the transcript; `additionalContext` is added more discretely.
+
+**Blocking prompts:**
+
+* `&#34;decision&#34;: &#34;block&#34;` prevents the prompt from being processed. The submitted
+  prompt is erased from context. `&#34;reason&#34;` is shown to the user but not added
+  to context.
+* `&#34;decision&#34;: undefined` (or omitted) allows the prompt to proceed normally.
+
+```json  theme={null}
+{
+  &#34;decision&#34;: &#34;block&#34; | undefined,
+  &#34;reason&#34;: &#34;Explanation for decision&#34;,
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;UserPromptSubmit&#34;,
+    &#34;additionalContext&#34;: &#34;My additional context here&#34;
+  }
+}
+```
+
+&lt;Note&gt;
+  The JSON format isn&#39;t required for simple use cases. To add context, you can print plain text to stdout with exit code 0. Use JSON when you need to
+  block prompts or want more structured control.
+&lt;/Note&gt;
+
+#### `Stop`/`SubagentStop` Decision Control
+
+`Stop` and `SubagentStop` hooks can control whether Claude must continue.
+
+* `&#34;block&#34;` prevents Claude from stopping. You must populate `reason` for Claude
+  to know how to proceed.
+* `undefined` allows Claude to stop. `reason` is ignored.
+
+```json  theme={null}
+{
+  &#34;decision&#34;: &#34;block&#34; | undefined,
+  &#34;reason&#34;: &#34;Must be provided when Claude is blocked from stopping&#34;
+}
+```
+
+#### `SessionStart` Decision Control
+
+`SessionStart` hooks allow you to load in context at the start of a session.
+
+* `&#34;hookSpecificOutput.additionalContext&#34;` adds the string to the context.
+* Multiple hooks&#39; `additionalContext` values are concatenated.
+
+```json  theme={null}
+{
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;SessionStart&#34;,
+    &#34;additionalContext&#34;: &#34;My additional context here&#34;
+  }
+}
+```
+
+#### `SessionEnd` Decision Control
+
+`SessionEnd` hooks run when a session ends. They cannot block session termination
+but can perform cleanup tasks.
+
+#### Exit Code Example: Bash Command Validation
+
+```python  theme={null}
+#!/usr/bin/env python3
+import json
+import re
+import sys
+
+# Define validation rules as a list of (regex pattern, message) tuples
+VALIDATION_RULES = [
+    (
+        r&#34;\bgrep\b(?!.*\|)&#34;,
+        &#34;Use &#39;rg&#39; (ripgrep) instead of &#39;grep&#39; for better performance and features&#34;,
+    ),
+    (
+        r&#34;\bfind\s+\S+\s+-name\b&#34;,
+        &#34;Use &#39;rg --files | rg pattern&#39; or &#39;rg --files -g pattern&#39; instead of &#39;find -name&#39; for better performance&#34;,
+    ),
+]
+
+
+def validate_command(command: str) -&gt; list[str]:
+    issues = []
+    for pattern, message in VALIDATION_RULES:
+        if re.search(pattern, command):
+            issues.append(message)
+    return issues
+
+
+try:
+    input_data = json.load(sys.stdin)
+except json.JSONDecodeError as e:
+    print(f&#34;Error: Invalid JSON input: {e}&#34;, file=sys.stderr)
+    sys.exit(1)
+
+tool_name = input_data.get(&#34;tool_name&#34;, &#34;&#34;)
+tool_input = input_data.get(&#34;tool_input&#34;, {})
+command = tool_input.get(&#34;command&#34;, &#34;&#34;)
+
+if tool_name != &#34;Bash&#34; or not command:
+    sys.exit(1)
+
+# Validate the command
+issues = validate_command(command)
+
+if issues:
+    for message in issues:
+        print(f&#34;• {message}&#34;, file=sys.stderr)
+    # Exit code 2 blocks tool call and shows stderr to Claude
+    sys.exit(2)
+```
+
+#### JSON Output Example: UserPromptSubmit to Add Context and Validation
+
+&lt;Note&gt;
+  For `UserPromptSubmit` hooks, you can inject context using either method:
+
+  * **Plain text stdout** with exit code 0: Simplest approach, prints text
+  * **JSON output** with exit code 0: Use `&#34;decision&#34;: &#34;block&#34;` to reject prompts,
+    or `additionalContext` for structured context injection
+
+  Remember: Exit code 2 only uses `stderr` for the error message. To block using
+  JSON (with a custom reason), use `&#34;decision&#34;: &#34;block&#34;` with exit code 0.
+&lt;/Note&gt;
+
+```python  theme={null}
+#!/usr/bin/env python3
+import json
+import sys
+import re
+import datetime
+
+# Load input from stdin
+try:
+    input_data = json.load(sys.stdin)
+except json.JSONDecodeError as e:
+    print(f&#34;Error: Invalid JSON input: {e}&#34;, file=sys.stderr)
+    sys.exit(1)
+
+prompt = input_data.get(&#34;prompt&#34;, &#34;&#34;)
+
+# Check for sensitive patterns
+sensitive_patterns = [
+    (r&#34;(?i)\b(password|secret|key|token)\s*[:=]&#34;, &#34;Prompt contains potential secrets&#34;),
+]
+
+for pattern, message in sensitive_patterns:
+    if re.search(pattern, prompt):
+        # Use JSON output to block with a specific reason
+        output = {
+            &#34;decision&#34;: &#34;block&#34;,
+            &#34;reason&#34;: f&#34;Security policy violation: {message}. Please rephrase your request without sensitive information.&#34;
+        }
+        print(json.dumps(output))
+        sys.exit(0)
+
+# Add current time to context
+context = f&#34;Current time: {datetime.datetime.now()}&#34;
+print(context)
+
+&#34;&#34;&#34;
+The following is also equivalent:
+print(json.dumps({
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;UserPromptSubmit&#34;,
+    &#34;additionalContext&#34;: context,
+  },
+}))
+&#34;&#34;&#34;
+
+# Allow the prompt to proceed with the additional context
+sys.exit(0)
+```
+
+#### JSON Output Example: PreToolUse with Approval
+
+```python  theme={null}
+#!/usr/bin/env python3
+import json
+import sys
+
+# Load input from stdin
+try:
+    input_data = json.load(sys.stdin)
+except json.JSONDecodeError as e:
+    print(f&#34;Error: Invalid JSON input: {e}&#34;, file=sys.stderr)
+    sys.exit(1)
+
+tool_name = input_data.get(&#34;tool_name&#34;, &#34;&#34;)
+tool_input = input_data.get(&#34;tool_input&#34;, {})
+
+# Example: Auto-approve file reads for documentation files
+if tool_name == &#34;Read&#34;:
+    file_path = tool_input.get(&#34;file_path&#34;, &#34;&#34;)
+    if file_path.endswith((&#34;.md&#34;, &#34;.mdx&#34;, &#34;.txt&#34;, &#34;.json&#34;)):
+        # Use JSON output to auto-approve the tool call
+        output = {
+            &#34;decision&#34;: &#34;approve&#34;,
+            &#34;reason&#34;: &#34;Documentation file auto-approved&#34;,
+            &#34;suppressOutput&#34;: True  # Don&#39;t show in verbose mode
+        }
+        print(json.dumps(output))
+        sys.exit(0)
+
+# For other cases, let the normal permission flow proceed
+sys.exit(0)
+```
+
+## Working with MCP Tools
+
+Claude Code hooks work seamlessly with
+[Model Context Protocol (MCP) tools](/en/mcp). When MCP servers
+provide tools, they appear with a special naming pattern that you can match in
+your hooks.
+
+### MCP Tool Naming
+
+MCP tools follow the pattern `mcp__&lt;server&gt;__&lt;tool&gt;`, for example:
+
+* `mcp__memory__create_entities` - Memory server&#39;s create entities tool
+* `mcp__filesystem__read_file` - Filesystem server&#39;s read file tool
+* `mcp__github__search_repositories` - GitHub server&#39;s search tool
+
+### Configuring Hooks for MCP Tools
+
+You can target specific MCP tools or entire MCP servers:
+
+```json  theme={null}
+{
+  &#34;hooks&#34;: {
+    &#34;PreToolUse&#34;: [
+      {
+        &#34;matcher&#34;: &#34;mcp__memory__.*&#34;,
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;command&#34;,
+            &#34;command&#34;: &#34;echo &#39;Memory operation initiated&#39; &gt;&gt; ~/mcp-operations.log&#34;
+          }
+        ]
+      },
+      {
+        &#34;matcher&#34;: &#34;mcp__.*__write.*&#34;,
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;command&#34;,
+            &#34;command&#34;: &#34;/home/user/scripts/validate-mcp-write.py&#34;
+          }
+        ]
+      }
+    ]
+  }
+}
+```
+
+## Examples
+
+&lt;Tip&gt;
+  For practical examples including code formatting, notifications, and file protection, see [More Examples](/en/hooks-guide#more-examples) in the get started guide.
+&lt;/Tip&gt;
+
+## Security Considerations
+
+### Disclaimer
+
+**USE AT YOUR OWN RISK**: Claude Code hooks execute arbitrary shell commands on
+your system automatically. By using hooks, you acknowledge that:
+
+* You are solely responsible for the commands you configure
+* Hooks can modify, delete, or access any files your user account can access
+* Malicious or poorly written hooks can cause data loss or system damage
+* Anthropic provides no warranty and assumes no liability for any damages
+  resulting from hook usage
+* You should thoroughly test hooks in a safe environment before production use
+
+Always review and understand any hook commands before adding them to your
+configuration.
+
+### Security Best Practices
+
+Here are some key practices for writing more secure hooks:
+
+1. **Validate and sanitize inputs** - Never trust input data blindly
+2. **Always quote shell variables** - Use `&#34;$VAR&#34;` not `$VAR`
+3. **Block path traversal** - Check for `..` in file paths
+4. **Use absolute paths** - Specify full paths for scripts (use
+   &#34;\$CLAUDE\_PROJECT\_DIR&#34; for the project path)
+5. **Skip sensitive files** - Avoid `.env`, `.git/`, keys, etc.
+
+### Configuration Safety
+
+Direct edits to hooks in settings files don&#39;t take effect immediately. Claude
+Code:
+
+1. Captures a snapshot of hooks at startup
+2. Uses this snapshot throughout the session
+3. Warns if hooks are modified externally
+4. Requires review in `/hooks` menu for changes to apply
+
+This prevents malicious hook modifications from affecting your current session.
+
+## Hook Execution Details
+
+* **Timeout**: 60-second execution limit by default, configurable per command.
+  * A timeout for an individual command does not affect the other commands.
+* **Parallelization**: All matching hooks run in parallel
+* **Deduplication**: Multiple identical hook commands are deduplicated automatically
+* **Environment**: Runs in current directory with Claude Code&#39;s environment
+  * The `CLAUDE_PROJECT_DIR` environment variable is available and contains the
+    absolute path to the project root directory (where Claude Code was started)
+  * The `CLAUDE_CODE_REMOTE` environment variable indicates whether the hook is running in a remote (web) environment (`&#34;true&#34;`) or local CLI environment (not set or empty). Use this to run different logic based on execution context.
+* **Input**: JSON via stdin
+* **Output**:
+  * PreToolUse/PermissionRequest/PostToolUse/Stop/SubagentStop: Progress shown in verbose mode (ctrl+o)
+  * Notification/SessionEnd: Logged to debug only (`--debug`)
+  * UserPromptSubmit/SessionStart: stdout added as context for Claude
+
+## Debugging
+
+### Basic Troubleshooting
+
+If your hooks aren&#39;t working:
+
+1. **Check configuration** - Run `/hooks` to see if your hook is registered
+2. **Verify syntax** - Ensure your JSON settings are valid
+3. **Test commands** - Run hook commands manually first
+4. **Check permissions** - Make sure scripts are executable
+5. **Review logs** - Use `claude --debug` to see hook execution details
+
+Common issues:
+
+* **Quotes not escaped** - Use `\&#34;` inside JSON strings
+* **Wrong matcher** - Check tool names match exactly (case-sensitive)
+* **Command not found** - Use full paths for scripts
+
+### Advanced Debugging
+
+For complex hook issues:
+
+1. **Inspect hook execution** - Use `claude --debug` to see detailed hook
+   execution
+2. **Validate JSON schemas** - Test hook input/output with external tools
+3. **Check environment variables** - Verify Claude Code&#39;s environment is correct
+4. **Test edge cases** - Try hooks with unusual file paths or inputs
+5. **Monitor system resources** - Check for resource exhaustion during hook
+   execution
+6. **Use structured logging** - Implement logging in your hook scripts
+
+### Debug Output Example
+
+Use `claude --debug` to see hook execution details:
+
+```
+[DEBUG] Executing hooks for PostToolUse:Write
+[DEBUG] Getting matching hook commands for PostToolUse with query: Write
+[DEBUG] Found 1 hook matchers in settings
+[DEBUG] Matched 1 hooks for query &#34;Write&#34;
+[DEBUG] Found 1 hook commands to execute
+[DEBUG] Executing hook command: &lt;Your command&gt; with timeout 60000ms
+[DEBUG] Hook command completed with status 0: &lt;Your stdout&gt;
+```
+
+Progress messages appear in verbose mode (ctrl+o) showing:
+
+* Which hook is running
+* Command being executed
+* Success/failure status
+* Output or error messages
+
+
+---
+
+&gt; To find navigation and other pages in this documentation, fetch the llms.txt file at: https://code.claude.com/docs/llms.txt</code></pre>
    </div>
</body>
</html>