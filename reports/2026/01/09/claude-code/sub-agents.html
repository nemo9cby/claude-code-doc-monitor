<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sub-agents - Diff Report</title>
    <link rel="stylesheet" href="../../css/diff.css">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --card-bg: #16213e;
            --text-color: #eee;
            --accent: #0f3460;
            --add-bg: #1a4d1a;
            --del-bg: #4d1a1a;
            --add-text: #4ade80;
            --del-text: #f87171;
        }
        @media (prefers-color-scheme: light) {
            :root {
                --bg-color: #f5f5f5;
                --card-bg: #fff;
                --text-color: #333;
                --accent: #e0e0e0;
                --add-bg: #d4edda;
                --del-bg: #f8d7da;
                --add-text: #155724;
                --del-text: #721c24;
            }
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 2rem;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        header { margin-bottom: 2rem; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .meta { color: #888; font-size: 0.9rem; }
        .summary {
            background: var(--card-bg);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            display: flex;
            gap: 2rem;
        }
        .stat { display: flex; align-items: center; gap: 0.5rem; }
        .stat.added { color: var(--add-text); }
        .stat.removed { color: var(--del-text); }
        .analysis {
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            border-left: 4px solid #8b5cf6;
        }
        .analysis-header {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #8b5cf6;
        }
        .analysis-content {
            white-space: pre-wrap;
            font-size: 0.95rem;
            line-height: 1.7;
        }
        .diff-container {
            background: var(--card-bg);
            border-radius: 8px;
            overflow: hidden;
        }
        .diff-header {
            background: var(--accent);
            padding: 0.75rem 1rem;
            font-weight: 600;
        }
        .diff-content {
            padding: 1rem;
            overflow-x: auto;
        }
        .diff-content ins {
            background: var(--add-bg);
            color: var(--add-text);
            text-decoration: none;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        .diff-content del {
            background: var(--del-bg);
            color: var(--del-text);
            text-decoration: line-through;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        pre {
            background: var(--accent);
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.85rem;
            margin-top: 2rem;
        }
        a { color: #60a5fa; }
        .back-link { margin-bottom: 1rem; display: inline-block; }
    </style>
</head>
<body>
    <div class="container">
        <a href="../index.html" class="back-link">&larr; Back to daily report</a>

        <header>
            <h1>sub-agents.md</h1>
            <p class="meta">Changed on 2026-01-09 18:16:34 EST</p>
        </header>

        <div class="summary">
            <div class="stat added">
                <span>+242</span> lines added
            </div>
            <div class="stat removed">
                <span>-247</span> lines removed
            </div>
        </div>

        

        <div class="diff-container">
            <div class="diff-header">Visual Diff</div>
            <div class="diff-content"><span># </span><del style="background:#ffe6e6;">S</del><ins style="background:#e6ffe6;">Create custom s</ins><span>ubagents&para;<br>&para;<br>&gt; Create and use specialized AI subagents in Claude Code for task-specific workflows and improved context management.&para;<br>&para;<br></span><del style="background:#ffe6e6;">Custom subagents in Claude Code are specialized AI assistants that can be invoked to handle specific types of tasks. They enable more efficient problem-solving by providing task-specific configurations with customized system prompts, tools and a separate context window.&para;<br>&para;<br>## What are subagents?&para;<br>&para;<br>Subagents are pre-configured AI personalities that Claude Code can delegate tasks to. Each subagent:&para;<br>&para;<br>* Has a specific purpose and expertise area&para;<br>* Uses its own context window separate from the main conversation&para;<br>* Can be configured with specific tools it's allowed to use&para;<br>* Includes a custom system prompt that guides its behavior&para;<br>&para;<br>When Claude Code encounters a task that matches a subagent's expertise, it can delegate that task to the specialized subagent, which works independently and returns results.&para;<br>&para;<br>## Key benefits&para;<br>&para;<br>&lt;CardGroup cols={2}&gt;&para;<br>  &lt;Card title="Context preservation" icon="layer-group"&gt;&para;<br>    Each subagent operates in its own context, preventing pollution of the main conversation and keeping it focused on high-level objectives.&para;<br>  &lt;/Card&gt;&para;<br>&para;<br>  &lt;Card title="Specialized expertise" icon="brain"&gt;&para;<br>    Subagents can be fine-tuned with detailed instructions for specific domains, leading to higher success rates on designated tasks.&para;<br>  &lt;/Card&gt;&para;<br>&para;<br>  &lt;Card title="Reusability" icon="rotate"&gt;&para;<br>    Once created, you can use subagents across different projects and share them with your team for consistent workflows.&para;<br>  &lt;/Card&gt;&para;<br>&para;<br>  &lt;Card title="Flexible permissions" icon="shield-check"&gt;&para;<br>    Each subagent can have different tool access levels, allowing you to limit powerful tools to specific subagent types.&para;<br>  &lt;/Card&gt;&para;<br>&lt;/CardGroup&gt;&para;<br>&para;<br>## Quick start&para;<br>&para;<br>To create your first subagent:</del><ins style="background:#e6ffe6;">Subagents are specialized AI assistants that handle specific types of tasks. Each subagent runs in its own context window with a custom system prompt, specific tool access, and independent permissions. When Claude encounters a task that matches a subagent's description, it delegates to that subagent, which works independently and returns results.&para;<br>&para;<br>Subagents help you:&para;<br>&para;<br>* **Preserve context** by keeping exploration and implementation out of your main conversation&para;<br>* **Enforce constraints** by limiting which tools a subagent can use&para;<br>* **Reuse configurations** across projects with user-level subagents&para;<br>* **Specialize behavior** with focused system prompts for specific domains&para;<br>* **Control costs** by routing tasks to faster, cheaper models like Haiku&para;<br>&para;<br>Claude uses each subagent's description to decide when to delegate tasks. When you create a subagent, write a clear description so Claude knows when to use it.&para;<br>&para;<br>Claude Code includes several built-in subagents like **Explore**, **Plan**, and **general-purpose**. You can also create custom subagents to handle specific tasks. This page covers the [built-in subagents](#built-in-subagents), [how to create your own](#quickstart-create-your-first-subagent), [full configuration options](#configure-subagents), [patterns for working with subagents](#work-with-subagents), and [example subagents](#example-subagents).&para;<br>&para;<br>## Built-in subagents&para;<br>&para;<br>Claude Code includes built-in subagents that Claude automatically uses when appropriate. Each inherits the parent conversation's permissions with additional tool restrictions.&para;<br>&para;<br>&lt;Tabs&gt;&para;<br>  &lt;Tab title="Explore"&gt;&para;<br>    A fast, read-only agent optimized for searching and analyzing codebases.&para;<br>&para;<br>    * **Model**: Haiku (fast, low-latency)&para;<br>    * **Tools**: Read-only tools (denied access to Write and Edit tools)&para;<br>    * **Purpose**: File discovery, code search, codebase exploration&para;<br>&para;<br>    Claude delegates to Explore when it needs to search or understand a codebase without making changes. This keeps exploration results out of your main conversation context.&para;<br>&para;<br>    When invoking Explore, Claude specifies a thoroughness level: **quick** for targeted lookups, **medium** for balanced exploration, or **very thorough** for comprehensive analysis.&para;<br>  &lt;/Tab&gt;&para;<br>&para;<br>  &lt;Tab title="Plan"&gt;&para;<br>    A research agent used during [plan mode](/en/common-workflows#use-plan-mode-for-safe-code-analysis) to gather context before presenting a plan.&para;<br>&para;<br>    * **Model**: Inherits from main conversation&para;<br>    * **Tools**: Read-only tools (denied access to Write and Edit tools)&para;<br>    * **Purpose**: Codebase research for planning&para;<br>&para;<br>    When you're in plan mode and Claude needs to understand your codebase, it delegates research to the Plan subagent. This prevents infinite nesting (subagents cannot spawn other subagents) while still gathering necessary context.&para;<br>  &lt;/Tab&gt;&para;<br>&para;<br>  &lt;Tab title="General-purpose"&gt;&para;<br>    A capable agent for complex, multi-step tasks that require both exploration and action.&para;<br>&para;<br>    * **Model**: Inherits from main conversation&para;<br>    * **Tools**: All tools&para;<br>    * **Purpose**: Complex research, multi-step operations, code modifications&para;<br>&para;<br>    Claude delegates to general-purpose when the task requires both exploration and modification, complex reasoning to interpret results, or multiple dependent steps.&para;<br>  &lt;/Tab&gt;&para;<br>&lt;/Tabs&gt;&para;<br>&para;<br>Beyond these built-in subagents, you can create your own with custom prompts, tool restrictions, permission modes, hooks, and skills. The following sections show how to get started and customize subagents.&para;<br>&para;<br>## Quickstart: create your first subagent&para;<br>&para;<br>Subagents are defined in Markdown files with YAML frontmatter. You can [create them manually](#write-subagent-files) or use the `/agents` slash command.&para;<br>&para;<br>This walkthrough guides you through creating a user-level subagent with the `/agent` command. The subagent reviews code and suggests improvements for the codebase.</ins><span>&para;<br>&para;<br>&lt;Steps&gt;&para;<br>  &lt;Step title="Open the subagents interface"&gt;&para;<br>    </span><del style="background:#ffe6e6;">Run the following command</del><ins style="background:#e6ffe6;">In Claude Code, run</ins><span>:&para;<br>&para;<br>    ```&para;<br>    /agents&para;<br>    ```&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="</span><del style="background:#ffe6e6;">Select 'Create New Agent'"&gt;&para;<br>    Choose whether to create a project-level or user-level subagent&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Define the subagent"&gt;&para;<br>    * **Recommended**: generate with Claude first, then customize to make it yours&para;<br>    * Describe your subagent in detail, including when Claude should use it&para;<br>    * Select the tools you want to grant access to, or leave this blank to inherit all tools&para;<br>    * The interface shows all available tools&para;<br>    * If you're generating with Claude, you can also edit the system prompt in your own editor by pressing `e`&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Save and use"&gt;&para;<br>    Your subagent is now available. Claude uses it automatically when appropriate, or you can invoke it explicitly:&para;<br>&para;<br>    ```&para;<br>    &gt; Use the code-reviewer subagent to check my recent changes&para;<br>    ```&para;<br>  &lt;/Step&gt;&para;<br>&lt;/Steps&gt;&para;<br>&para;<br>## Subagent configuration&para;<br>&para;<br>### File locations&para;<br>&para;<br>Subagents are stored as Markdown files with YAML frontmatter in two possible locations:&para;<br>&para;<br>| Type                  | Location            | Scope                         | Priority |&para;<br>| :-------------------- | :------------------ | :---------------------------- | :------- |&para;<br>| **Project subagents** | `.claude/agents/`   | Available in current project  | Highest  |&para;<br>| **User subagents**    | `~/.claude/agents/` | Available across all projects | Lower    |&para;<br>&para;<br>When subagent names conflict, project-level subagents take precedence over user-level subagents.&para;<br>&para;<br>### Plugin agents&para;<br>&para;<br>[Plugins](/en/plugins) can provide custom subagents that integrate seamlessly with Claude Code. Plugin agents work identically to user-defined agents and appear in the `/agents` interface.&para;<br>&para;<br>**Plugin agent locations**: plugins include agents in their `agents/` directory (or custom paths specified in the plugin manifest).&para;<br>&para;<br>**Using plugin agents**:&para;<br>&para;<br>* Plugin agents appear in `/agents` alongside your custom agents&para;<br>* Can be invoked explicitly: "Use the code-reviewer agent from the security-plugin"&para;<br>* Can be invoked automatically by Claude when appropriate&para;<br>* Can be managed (viewed, inspected) through `/agents` interface&para;<br>&para;<br>See the [plugin components reference](/en/plugins-reference#agents) for details on creating plugin agents.&para;<br>&para;<br>### CLI-based configuration&para;<br>&para;<br>You can also define subagents dynamically using the `--agents` CLI flag, which accepts a JSON object:&para;<br>&para;<br>```bash  theme={null}&para;<br>claude --agents '{&para;<br>  "code-reviewer": {&para;<br>    "description": "Expert code reviewer. Use proactively after code changes.",&para;<br>    "prompt": "You are a senior code reviewer. Focus on code quality, security, and best practices.",&para;<br>    "tools": ["Read", "Grep", "Glob", "Bash"],&para;<br>    "model": "sonnet"&para;<br>  }&para;<br>}'&para;<br>```&para;<br>&para;<br>**Priority**: CLI-defined subagents have lower priority than project-level subagents but higher priority than user-level subagents.&para;<br>&para;<br>**Use case**: This approach is useful for:&para;<br>&para;<br>* Quick testing of subagent configurations&para;<br>* Session-specific subagents that don't need to be saved&para;<br>* Automation scripts that need custom subagents&para;<br>* Sharing subagent definitions in documentation or scripts&para;<br>&para;<br>For detailed information about the JSON format and all available options, see the [CLI reference documentation](/en/cli-reference#agents-flag-format).&para;<br>&para;<br>### File format&para;<br>&para;<br>Each subagent is defined in a Markdown file with this structure:&para;<br>&para;<br>```markdown  theme={null}&para;<br>---&para;<br>name: your-sub-agent-name&para;<br>description: Description of when this subagent should be invoked&para;<br>tools: tool1, tool2, tool3  # Optional - inherits all tools if omitted&para;<br>model: sonnet  # Optional - specify model alias or 'inherit'&para;<br>permissionMode: default  # Optional - permission mode for the subagent&para;<br>skills: skill1, skill2  # Optional - skills to auto-load&para;<br>---&para;<br>&para;<br>Your subagent's system prompt goes here. This can be multiple paragraphs&para;<br>and should clearly define the subagent's role, capabilities, and approach&para;<br>to solving problems.&para;<br>&para;<br>Include specific instructions, best practices, and any constraints&para;<br>the subagent should follow.&para;<br>```&para;<br>&para;<br>#### Configuration fields&para;<br>&para;<br>| Field            | Required | Description                                                                                                                                                                                                     |&para;<br>| :--------------- | :------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |&para;<br>| `name`           | Yes      | Unique identifier using lowercase letters and hyphens                                                                                                                                                           |&para;<br>| `description`    | Yes      | Natural language description of the subagent's purpose                                                                                                                                                          |&para;<br>| `tools`          | No       | Comma-separated list of specific tools. If omitted, inherits all tools from the main thread                                                                                                                     |&para;<br>| `model`          | No       | Model to use for this subagent. Can be a model alias (`sonnet`, `opus`, `haiku`) or `'inherit'` to use the main conversation's model. If omitted, defaults to the [configured subagent model](/en/model-config) |&para;<br>| `permissionMode` | No       | Permission mode for the subagent. Valid values: `default`, `acceptEdits`, `dontAsk`, `bypassPermissions`, `plan`, `ignore`. Controls how the subagent handles permission requests                               |&para;<br>| `skills`         | No       | Comma-separated list of skill names to auto-load when the subagent starts. Subagents do not inherit Skills from the parent conversation. If omitted, no Skills are preloaded.                                   |&para;<br>| `hooks`          | No       | Define hooks scoped to this subagent's lifecycle. Supports `PreToolUse`, `PostToolUse`, and `Stop` events. See [Define hooks for subagents](#define-hooks-for-subagents).                                       |&para;<br>&para;<br>### Model selection&para;<br>&para;<br>The `model` field allows you to control which [AI model](/en/model-config) the subagent uses:&para;<br>&para;<br>* **Model alias**: Use one of the available aliases: `sonnet`, `opus`, or `haiku`&para;<br>* **`'inherit'`**: Use the same model as the main conversation (useful for consistency)&para;<br>* **Omitted**: If not specified, uses the default model configured for subagents (`sonnet`)&para;<br>&para;<br>&lt;Note&gt;&para;<br>  Using `'inherit'` is particularly useful when you want your subagents to adapt to the model choice of the main conversation, ensuring consistent capabilities and response style throughout your session.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>### Available tools&para;<br>&para;<br>Subagents can be granted access to any of Claude Code's internal tools. See the [tools documentation](/en/settings#tools-available-to-claude) for a complete list of available tools.&para;<br>&para;<br>&lt;Tip&gt;&para;<br>  **Recommended:** Use the `/agents` command to modify tool access - it provides an interactive interface that lists all available tools, including any connected MCP server tools, making it easier to select the ones you need.&para;<br>&lt;/Tip&gt;&para;<br>&para;<br>You have two options for configuring tools:&para;<br>&para;<br>* **Omit the `tools` field** to inherit all tools from the main thread (default), including MCP tools&para;<br>* **Specify individual tools** as a comma-separated list for more granular control (can be edited manually or via `/agents`)&para;<br>&para;<br>**MCP Tools**: Subagents can access MCP tools from configured MCP servers. When the `tools` field is omitted, subagents inherit all MCP tools available to the main thread.&para;<br>&para;<br>### Define hooks for subagents&para;<br>&para;<br>Subagents can define hooks that run during the subagent's lifecycle. Use the `hooks` field to specify `PreToolUse`, `PostToolUse`, or `Stop` handlers:&para;<br>&para;<br>```yaml  theme={null}&para;<br>---&para;<br>name: code-reviewer&para;<br>description: Review code changes with automatic linting&para;<br>hooks:&para;<br>  PostToolUse:&para;<br>    - matcher: "Edit|Write"&para;<br>      hooks:&para;<br>        - type: command&para;<br>          command: "./scripts/run-linter.sh"&para;<br>---&para;<br>```&para;<br>&para;<br>Hooks defined in a subagent are scoped to that subagent's execution and are automatically cleaned up when the subagent finishes.&para;<br>&para;<br>See [Hooks](/en/hooks) for the complete hook configuration format.&para;<br>&para;<br>## Managing subagents&para;<br>&para;<br>### Using the /agents command (Recommended)&para;<br>&para;<br>The `/agents` command provides a comprehensive interface for subagent management:&para;<br>&para;<br>```&para;<br>/agents&para;<br>```&para;<br>&para;<br>This opens an interactive menu where you can:&para;<br>&para;<br>* View all available subagents (built-in, user, and project)&para;<br>* Create new subagents with guided setup&para;<br>* Edit existing custom subagents, including their tool access&para;<br>* Delete custom subagents&para;<br>* See which subagents are active when duplicates exist&para;<br>* **Manage tool permissions** with a complete list of available tools&para;<br>&para;<br>### Direct file management&para;<br>&para;<br>You can also manage subagents by working directly with their files:&para;<br>&para;<br>```bash  theme={null}&para;<br># Create a project subagent&para;<br>mkdir -p .claude/agents&para;<br>echo '---&para;<br>name: test-runner&para;<br>description: Use proactively to run tests and fix failures&para;<br>---&para;<br>&para;<br>You are a test automation expert. When you see code changes, proactively run the appropriate tests. If tests fail, analyze the failures and fix them while preserving the original test intent.' &gt; .claude/agents/test-runner.md&para;<br>&para;<br># Create a user subagent&para;<br>mkdir -p ~/.claude/agents&para;<br># ... create subagent file&para;<br>```&para;<br>&para;<br>&lt;Note&gt;&para;<br>  Subagents created by manually adding files will be loaded the next time you start a Claude Code session. To create and use a subagent immediately without restarting, use the `/agents` command instead.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>### Disabling specific subagents&para;<br>&para;<br>You can disable specific built-in or custom subagents using the `Task(AgentName)` permission rule syntax. Add these rules to the `deny` array in your [settings](/en/settings#permission-settings) or use the `--disallowedTools` CLI flag.&para;<br>&para;<br>**Example settings.json configuration:**&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "permissions": {&para;<br>    "deny": ["Task(Explore)", "Task(Plan)"]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>**Example CLI usage:**&para;<br>&para;<br>```bash  theme={null}&para;<br>claude --disallowedTools "Task(Explore)"&para;<br>```&para;<br>&para;<br>This is useful when you want to prevent Claude from delegating tasks to specific subagents, either for security reasons or to enforce a particular workflow.&para;<br>&para;<br>See [IAM documentation](/en/iam#tool-specific-permission-rules) for more details on permission rules.&para;<br>&para;<br>## Using subagents effectively&para;<br>&para;<br>### Automatic delegation&para;<br>&para;<br>Claude Code proactively delegates tasks based on:&para;<br>&para;<br>* The task description in your request&para;<br>* The `description` field in subagent configurations&para;<br>* Current context and available tools&para;<br>&para;<br>&lt;Tip&gt;&para;<br>  To encourage more proactive subagent use, include phrases like "use PROACTIVELY" or "MUST BE USED" in your `description` field.&para;<br>&lt;/Tip&gt;&para;<br>&para;<br>### Explicit invocation&para;<br>&para;<br>Request a specific subagent by mentioning it in your command:&para;<br>&para;<br>```&para;<br>&gt; Use the test-runner subagent to fix failing tests&para;<br>&gt; Have the code-reviewer subagent look at my recent changes&para;<br>&gt; Ask the debugger subagent to investigate this error&para;<br>```&para;<br>&para;<br>## Built-in subagents&para;<br>&para;<br>Claude Code includes built-in subagents that are available out of the box:&para;<br>&para;<br>### General-purpose subagent&para;<br>&para;<br>The general-purpose subagent is a capable agent for complex, multi-step tasks that require both exploration and action. Unlike the Explore subagent, it can modify files and execute a wider range of operations.&para;<br>&para;<br>**Key characteristics:**&para;<br>&para;<br>* **Model**: Uses Sonnet for more capable reasoning&para;<br>* **Tools**: Has access to all tools&para;<br>* **Mode**: Can read and write files, execute commands, make changes&para;<br>* **Purpose**: Complex research tasks, multi-step operations, code modifications&para;<br>&para;<br>**When Claude uses it:**&para;<br>&para;<br>Claude delegates to the general-purpose subagent when:&para;<br>&para;<br>* The task requires both exploration and modification&para;<br>* Complex reasoning is needed to interpret search results&para;<br>* Multiple strategies may be needed if initial searches fail&para;<br>* The task has multiple steps that depend on each other&para;<br>&para;<br>**Example scenario:**&para;<br>&para;<br>```&para;<br>User: Find all the places where we handle authentication and update them to use the new token format&para;<br>&para;<br>Claude: [Invokes general-purpose subagent]&para;<br>[Agent searches for auth-related code across codebase]&para;<br>[Agent reads and analyzes multiple files]&para;<br>[Agent makes necessary edits]&para;<br>[Returns detailed writeup of changes made]&para;<br>```&para;<br>&para;<br>### Plan subagent&para;<br>&para;<br>The Plan subagent is a specialized built-in agent designed for use during plan mode. When Claude is operating in plan mode (non-execution mode), it uses the Plan subagent to conduct research and gather information about your codebase before presenting a plan.&para;<br>&para;<br>**Key characteristics:**&para;<br>&para;<br>* **Model**: Uses Sonnet for more capable analysis&para;<br>* **Tools**: Has access to Read, Glob, Grep, and Bash tools for codebase exploration&para;<br>* **Purpose**: Searches files, analyzes code structure, and gathers context&para;<br>* **Automatic invocation**: Claude automatically uses this agent when in plan mode and needs to research the codebase&para;<br>&para;<br>**How it works:**&para;<br>When you're in plan mode and Claude needs to understand your codebase to create a plan, it delegates research tasks to the Plan subagent. This prevents infinite nesting of agents (subagents cannot spawn other subagents) while still allowing Claude to gather the necessary context.&para;<br>&para;<br>**Example scenario:**&para;<br>&para;<br>```&para;<br>User: [In plan mode] Help me refactor the authentication module&para;<br>&para;<br>Claude: Let me research your authentication implementation first...&para;<br>[Internally invokes Plan subagent to explore auth-related files]&para;<br>[Plan subagent searches codebase and returns findings]&para;<br>Claude: Based on my research, here's my proposed plan...&para;<br>```&para;<br>&para;<br>&lt;Tip&gt;&para;<br>  The Plan subagent is only used in plan mode. In normal execution mode, Claude uses the general-purpose agent or other custom subagents you've created.&para;<br>&lt;/Tip&gt;&para;<br>&para;<br>### Explore subagent&para;<br>&para;<br>The Explore subagent is a fast, lightweight agent optimized for searching and analyzing codebases. It operates in strict read-only mode and is designed for rapid file discovery and code exploration.&para;<br>&para;<br>**Key characteristics:**&para;<br>&para;<br>* **Model**: Uses Haiku for fast, low-latency searches&para;<br>* **Mode**: Strictly read-only - cannot create, modify, or delete files&para;<br>* **Tools available**:&para;<br>  * Glob - File pattern matching&para;<br>  * Grep - Content searching with regular expressions&para;<br>  * Read - Reading file contents&para;<br>  * Bash - Read-only commands only (ls, git status, git log, git diff, find, cat, head, tail)&para;<br>&para;<br>**When Claude uses it:**&para;<br>&para;<br>Claude will delegate to the Explore subagent when it needs to search or understand a codebase but doesn't need to make changes. This is more efficient than the main agent running multiple search commands directly, as content found during the exploration process doesn't bloat the main conversation.&para;<br>&para;<br>**Thoroughness levels:**&para;<br>&para;<br>When invoking the Explore subagent, Claude specifies a thoroughness level:&para;<br>&para;<br>* **Quick** - Fast searches with minimal exploration. Good for targeted lookups.&para;<br>* **Medium** - Moderate exploration. Balances speed and thoroughness.&para;<br>* **Very thorough** - Comprehensive analysis across multiple locations and naming conventions. Used when the target might be in unexpected places.&para;<br>&para;<br>**Example scenarios:**&para;<br>&para;<br>```&para;<br>User: Where are errors from the client handled?&para;<br>&para;<br>Claude: [Invokes Explore subagent with "medium" thoroughness]&para;<br>[Explore uses Grep to search for error handling patterns]&para;<br>[Explore uses Read to examine promising files]&para;<br>[Returns findings with absolute file paths]&para;<br>Claude: Client errors are handled in src/services/process.ts:712...&para;<br>```&para;<br>&para;<br>```&para;<br>User: What's the codebase structure?&para;<br>&para;<br>Claude: [Invokes Explore subagent with "quick" thoroughness]&para;<br>[Explore uses Glob and ls to map directory structure]&para;<br>[Returns overview of key directories and their purposes]&para;<br>```&para;<br>&para;<br>## Example subagents&para;<br>&para;<br>### Code reviewer</del><ins style="background:#e6ffe6;">Create a new user-level agent"&gt;&para;<br>    Select **Create new agent**, then choose **User-level**. This saves the subagent to `~/.claude/agents/` so it's available in all your projects.&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Generate with Claude"&gt;&para;<br>    Select **Generate with Claude**. When prompted, describe the subagent:&para;<br>&para;<br>    ```&para;<br>    A code improvement agent that scans files and suggests improvements&para;<br>    for readability, performance, and best practices. It should explain&para;<br>    each issue, show the current code, and provide an improved version.&para;<br>    ```&para;<br>&para;<br>    Claude generates the system prompt and configuration. Press `e` to open it in your editor if you want to customize it.&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Select tools"&gt;&para;<br>    For a read-only reviewer, deselect everything except **Read-only tools**. If you keep all tools selected, the subagent inherits all tools available to the main conversation.&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Select model"&gt;&para;<br>    Choose which model the subagent uses. For this example agent, select **Sonnet**, which balances capability and speed for analyzing code patterns.&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Choose a color"&gt;&para;<br>    Pick a background color for the subagent. This helps you identify which subagent is running in the UI.&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Save and try it out"&gt;&para;<br>    Save the subagent. It's available immediately (no restart needed). Try it:&para;<br>&para;<br>    ```&para;<br>    Use the code-improver agent to suggest improvements in this project&para;<br>    ```&para;<br>&para;<br>    Claude delegates to your new subagent, which scans the codebase and returns improvement suggestions.&para;<br>  &lt;/Step&gt;&para;<br>&lt;/Steps&gt;&para;<br>&para;<br>You now have a subagent you can use in any project on your machine to analyze codebases and suggest improvements.&para;<br>&para;<br>You can also create subagents manually as Markdown files, define them via CLI flags, or distribute them through plugins. The following sections cover all configuration options.&para;<br>&para;<br>## Configure subagents&para;<br>&para;<br>### Use the /agents command&para;<br>&para;<br>The `/agents` command provides an interactive interface for managing subagents. Run `/agents` to:&para;<br>&para;<br>* View all available subagents (built-in, user, project, and plugin)&para;<br>* Create new subagents with guided setup or Claude generation&para;<br>* Edit existing subagent configuration and tool access&para;<br>* Delete custom subagents&para;<br>* See which subagents are active when duplicates exist&para;<br>&para;<br>This is the recommended way to create and manage subagents. For manual creation or automation, you can also add subagent files directly.&para;<br>&para;<br>### Choose the subagent scope&para;<br>&para;<br>Subagents are Markdown files with YAML frontmatter. Store them in different locations depending on scope. When multiple subagents share the same name, the higher-priority location wins.&para;<br>&para;<br>| Location                     | Scope                   | Priority    | How to create                         |&para;<br>| :--------------------------- | :---------------------- | :---------- | :------------------------------------ |&para;<br>| `--agents` CLI flag          | Current session         | 1 (highest) | Pass JSON when launching Claude Code  |&para;<br>| `.claude/agents/`            | Current project         | 2           | Interactive or manual                 |&para;<br>| `~/.claude/agents/`          | All your projects       | 3           | Interactive or manual                 |&para;<br>| Plugin's `agents/` directory | Where plugin is enabled | 4 (lowest)  | Installed with [plugins](/en/plugins) |&para;<br>&para;<br>**Project subagents** (`.claude/agents/`) are ideal for subagents specific to a codebase. Check them into version control so your team can use and improve them collaboratively.&para;<br>&para;<br>**User subagents** (`~/.claude/agents/`) are personal subagents available in all your projects.&para;<br>&para;<br>**CLI-defined subagents** are passed as JSON when launching Claude Code. They exist only for that session and aren't saved to disk, making them useful for quick testing or automation scripts:&para;<br>&para;<br>```bash  theme={null}&para;<br>claude --agents '{&para;<br>  "code-reviewer": {&para;<br>    "description": "Expert code reviewer. Use proactively after code changes.",&para;<br>    "prompt": "You are a senior code reviewer. Focus on code quality, security, and best practices.",&para;<br>    "tools": ["Read", "Grep", "Glob", "Bash"],&para;<br>    "model": "sonnet"&para;<br>  }&para;<br>}'&para;<br>```&para;<br>&para;<br>The `--agents` flag accepts JSON with the same fields as [frontmatter](#supported-frontmatter-fields). Use `prompt` for the system prompt (equivalent to the markdown body in file-based subagents). See the [CLI reference](/en/cli-reference#agents-flag-format) for the full JSON format.&para;<br>&para;<br>**Plugin subagents** come from [plugins](/en/plugins) you've installed. They appear in `/agents` alongside your custom subagents. See the [plugin components reference](/en/plugins-reference#agents) for details on creating plugin subagents.&para;<br>&para;<br>### Write subagent files&para;<br>&para;<br>Subagent files use YAML frontmatter for configuration, followed by the system prompt in Markdown:&para;<br>&para;<br>&lt;Note&gt;&para;<br>  Subagents are loaded at session start. If you create a subagent by manually adding a file, restart your session or use `/agents` to load it immediately.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>```markdown  theme={null}&para;<br>---&para;<br>name: code-reviewer&para;<br>description: Reviews code for quality and best practices&para;<br>tools: Read, Glob, Grep&para;<br>model: sonnet&para;<br>---&para;<br>&para;<br>You are a code reviewer. When invoked, analyze the code and provide&para;<br>specific, actionable feedback on quality, security, and best practices.&para;<br>```&para;<br>&para;<br>The frontmatter defines the subagent's metadata and configuration. The body becomes the system prompt that guides the subagent's behavior. Subagents receive only this system prompt (plus basic environment details like working directory), not the full Claude Code system prompt.&para;<br>&para;<br>#### Supported frontmatter fields&para;<br>&para;<br>The following fields can be used in the YAML frontmatter. Only `name` and `description` are required.&para;<br>&para;<br>| Field             | Required | Description                                                                                                                                                                                                  |&para;<br>| :---------------- | :------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |&para;<br>| `name`            | Yes      | Unique identifier using lowercase letters and hyphens                                                                                                                                                        |&para;<br>| `description`     | Yes      | When Claude should delegate to this subagent                                                                                                                                                                 |&para;<br>| `tools`           | No       | [Tools](#available-tools) the subagent can use. Inherits all tools if omitted                                                                                                                                |&para;<br>| `disallowedTools` | No       | Tools to deny, removed from inherited or specified list                                                                                                                                                      |&para;<br>| `model`           | No       | [Model](#choose-a-model) to use: `sonnet`, `opus`, `haiku`, or `inherit`. Defaults to `sonnet`                                                                                                               |&para;<br>| `permissionMode`  | No       | [Permission mode](#permission-modes): `default`, `acceptEdits`, `dontAsk`, `bypassPermissions`, or `plan`                                                                                                    |&para;<br>| `skills`          | No       | [Skills](/en/skills) to load into the subagent's context at startup. The full skill content is injected, not just made available for invocation. Subagents don't inherit skills from the parent conversation |&para;<br>| `hooks`           | No       | [Lifecycle hooks](#define-hooks-for-subagents) scoped to this subagent                                                                                                                                       |&para;<br>&para;<br>### Choose a model&para;<br>&para;<br>The `model` field controls which [AI model](/en/model-config) the subagent uses:&para;<br>&para;<br>* **Model alias**: Use one of the available aliases: `sonnet`, `opus`, or `haiku`&para;<br>* **inherit**: Use the same model as the main conversation (useful for consistency)&para;<br>* **Omitted**: If not specified, uses the default model configured for subagents (`sonnet`)&para;<br>&para;<br>### Control subagent capabilities&para;<br>&para;<br>You can control what subagents can do through tool access, permission modes, and conditional rules.&para;<br>&para;<br>#### Available tools&para;<br>&para;<br>Subagents can use any of Claude Code's [internal tools](/en/settings#tools-available-to-claude). By default, subagents inherit all tools from the main conversation, including MCP tools.&para;<br>&para;<br>To restrict tools, use the `tools` field (allowlist) or `disallowedTools` field (denylist):&para;<br>&para;<br>```yaml  theme={null}&para;<br>---&para;<br>name: safe-researcher&para;<br>description: Research agent with restricted capabilities&para;<br>tools: Read, Grep, Glob, Bash&para;<br>disallowedTools: Write, Edit&para;<br>---&para;<br>```&para;<br>&para;<br>#### Permission modes&para;<br>&para;<br>The `permissionMode` field controls how the subagent handles permission prompts. Subagents inherit the permission context from the main conversation but can override the mode.&para;<br>&para;<br>| Mode                | Behavior                                                           |&para;<br>| :------------------ | :----------------------------------------------------------------- |&para;<br>| `default`           | Standard permission checking with prompts                          |&para;<br>| `acceptEdits`       | Auto-accept file edits                                             |&para;<br>| `dontAsk`           | Auto-deny permission prompts (explicitly allowed tools still work) |&para;<br>| `bypassPermissions` | Skip all permission checks                                         |&para;<br>| `plan`              | Plan mode (read-only exploration)                                  |&para;<br>&para;<br>&lt;Warning&gt;&para;<br>  Use `bypassPermissions` with caution. It skips all permission checks, allowing the subagent to execute any operation without approval.&para;<br>&lt;/Warning&gt;&para;<br>&para;<br>If the parent uses `bypassPermissions`, this takes precedence and cannot be overridden.&para;<br>&para;<br>#### Conditional rules with hooks&para;<br>&para;<br>For more dynamic control over tool usage, use `PreToolUse` hooks to validate operations before they execute. This is useful when you need to allow some operations of a tool while blocking others.&para;<br>&para;<br>This example creates a subagent that only allows read-only database queries by validating commands before execution:&para;<br>&para;<br>```yaml  theme={null}&para;<br>---&para;<br>name: db-reader&para;<br>description: Execute read-only database queries&para;<br>tools: Bash&para;<br>hooks:&para;<br>  PreToolUse:&para;<br>    - matcher: "Bash"&para;<br>      hooks:&para;<br>        - type: command&para;<br>          command: "./scripts/validate-readonly-query.sh"&para;<br>---&para;<br>```&para;<br>&para;<br>The validation script inspects `$TOOL_INPUT` and exits with a non-zero code to block write operations. See [Define hooks for subagents](#define-hooks-for-subagents) for more hook configuration options.&para;<br>&para;<br>#### Disable specific subagents&para;<br>&para;<br>You can prevent Claude from using specific subagents by adding them to the `deny` array in your [settings](/en/settings#permission-settings). Use the format `Task(subagent-name)` where `subagent-name` matches the subagent's name field.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "permissions": {&para;<br>    "deny": ["Task(Explore)", "Task(my-custom-agent)"]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>This works for both built-in and custom subagents. You can also use the `--disallowedTools` CLI flag:&para;<br>&para;<br>```bash  theme={null}&para;<br>claude --disallowedTools "Task(Explore)"&para;<br>```&para;<br>&para;<br>See [IAM documentation](/en/iam#tool-specific-permission-rules) for more details on permission rules.&para;<br>&para;<br>### Define hooks for subagents&para;<br>&para;<br>Subagents can define [hooks](/en/hooks) that run during the subagent's lifecycle. There are two ways to configure hooks:&para;<br>&para;<br>1. **In the subagent's frontmatter**: Define hooks that run only while that subagent is active&para;<br>2. **In `settings.json`**: Define hooks that run in the main session when subagents start or stop&para;<br>&para;<br>#### Hooks in subagent frontmatter&para;<br>&para;<br>Define hooks directly in the subagent's markdown file. These hooks only run while that specific subagent is active and are cleaned up when it finishes.&para;<br>&para;<br>| Event         | Matcher input | When it fires                   |&para;<br>| :------------ | :------------ | :------------------------------ |&para;<br>| `PreToolUse`  | Tool name     | Before the subagent uses a tool |&para;<br>| `PostToolUse` | Tool name     | After the subagent uses a tool  |&para;<br>| `Stop`        | (none)        | When the subagent finishes      |&para;<br>&para;<br>This example validates Bash commands with the `PreToolUse` hook and runs a linter after file edits with `PostToolUse`:&para;<br>&para;<br>```yaml  theme={null}&para;<br>---&para;<br>name: code-reviewer&para;<br>description: Review code changes with automatic linting&para;<br>hooks:&para;<br>  PreToolUse:&para;<br>    - matcher: "Bash"&para;<br>      hooks:&para;<br>        - type: command&para;<br>          command: "./scripts/validate-command.sh $TOOL_INPUT"&para;<br>  PostToolUse:&para;<br>    - matcher: "Edit|Write"&para;<br>      hooks:&para;<br>        - type: command&para;<br>          command: "./scripts/run-linter.sh"&para;<br>---&para;<br>```&para;<br>&para;<br>`Stop` hooks in frontmatter are automatically converted to `SubagentStop` events.&para;<br>&para;<br>#### Project-level hooks for subagent events&para;<br>&para;<br>Configure hooks in `settings.json` that respond to subagent lifecycle events in the main session. Use the `matcher` field to target specific agent types by name.&para;<br>&para;<br>| Event           | Matcher input   | When it fires                    |&para;<br>| :-------------- | :-------------- | :------------------------------- |&para;<br>| `SubagentStart` | Agent type name | When a subagent begins execution |&para;<br>| `SubagentStop`  | Agent type name | When a subagent completes        |&para;<br>&para;<br>This example runs setup and cleanup scripts only when the `db-agent` subagent starts and stops:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "SubagentStart": [&para;<br>      {&para;<br>        "matcher": "db-agent",&para;<br>        "hooks": [&para;<br>          { "type": "command", "command": "./scripts/setup-db-connection.sh" }&para;<br>        ]&para;<br>      }&para;<br>    ],&para;<br>    "SubagentStop": [&para;<br>      {&para;<br>        "matcher": "db-agent",&para;<br>        "hooks": [&para;<br>          { "type": "command", "command": "./scripts/cleanup-db-connection.sh" }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>See [Hooks](/en/hooks) for the complete hook configuration format.&para;<br>&para;<br>## Work with subagents&para;<br>&para;<br>### Understand automatic delegation&para;<br>&para;<br>Claude automatically delegates tasks based on the task description in your request, the `description` field in subagent configurations, and current context. To encourage proactive delegation, include phrases like "use proactively" in your subagent's description field.&para;<br>&para;<br>You can also request a specific subagent explicitly:&para;<br>&para;<br>```&para;<br>Use the test-runner subagent to fix failing tests&para;<br>Have the code-reviewer subagent look at my recent changes&para;<br>```&para;<br>&para;<br>### Run subagents in foreground or background&para;<br>&para;<br>Subagents can run in the foreground (blocking) or background (concurrent):&para;<br>&para;<br>* **Foreground subagents** block the main conversation until complete. Permission prompts and clarifying questions (like [`AskUserQuestion`](/en/settings#tools-available-to-claude)) are passed through to you.&para;<br>* **Background subagents** run concurrently while you continue working. They inherit the parent's permissions and auto-deny anything not pre-approved. If a background subagent needs a permission it doesn't have or needs to ask clarifying questions, that tool call fails but the subagent continues. MCP tools are not available in background subagents.&para;<br>&para;<br>If a background subagent fails due to missing permissions, you can [resume it](#resume-subagents) in the foreground to retry with interactive prompts.&para;<br>&para;<br>Claude decides whether to run subagents in the foreground or background based on the task. You can also:&para;<br>&para;<br>* Ask Claude to "run this in the background"&para;<br>* Press **Ctrl+B** to background a running task&para;<br>&para;<br>### Common patterns&para;<br>&para;<br>#### Isolate high-volume operations&para;<br>&para;<br>One of the most effective uses for subagents is isolating operations that produce large amounts of output. Running tests, fetching documentation, or processing log files can consume significant context. By delegating these to a subagent, the verbose output stays in the subagent's context while only the relevant summary returns to your main conversation.&para;<br>&para;<br>```&para;<br>Use a subagent to run the test suite and report only the failing tests with their error messages&para;<br>```&para;<br>&para;<br>#### Run parallel research&para;<br>&para;<br>For independent investigations, spawn multiple subagents to work simultaneously:&para;<br>&para;<br>```&para;<br>Research the authentication, database, and API modules in parallel using separate subagents&para;<br>```&para;<br>&para;<br>Each subagent explores its area independently, then Claude synthesizes the findings. This works best when the research paths don't depend on each other.&para;<br>&para;<br>&lt;Warning&gt;&para;<br>  When subagents complete, their results return to your main conversation. Running many subagents that each return detailed results can consume significant context.&para;<br>&lt;/Warning&gt;&para;<br>&para;<br>#### Chain subagents&para;<br>&para;<br>For multi-step workflows, ask Claude to use subagents in sequence. Each subagent completes its task and returns results to Claude, which then passes relevant context to the next subagent.&para;<br>&para;<br>```&para;<br>Use the code-reviewer subagent to find performance issues, then use the optimizer subagent to fix them&para;<br>```&para;<br>&para;<br>### Choose between subagents and main conversation&para;<br>&para;<br>Use the **main conversation** when:&para;<br>&para;<br>* The task needs frequent back-and-forth or iterative refinement&para;<br>* Multiple phases share significant context (planning  implementation  testing)&para;<br>* You're making a quick, targeted change&para;<br>* Latency matters. Subagents start fresh and may need time to gather context&para;<br>&para;<br>Use **subagents** when:&para;<br>&para;<br>* The task produces verbose output you don't need in your main context&para;<br>* You want to enforce specific tool restrictions or permissions&para;<br>* The work is self-contained and can return a summary&para;<br>&para;<br>Consider [Skills](/en/skills) instead when you want reusable prompts or workflows that run in the main conversation context rather than isolated subagent context.&para;<br>&para;<br>&lt;Note&gt;&para;<br>  Subagents cannot spawn other subagents. If your workflow requires nested delegation, use [Skills](/en/skills) or [chain subagents](#chain-subagents) from the main conversation.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>### Manage subagent context&para;<br>&para;<br>#### Resume subagents&para;<br>&para;<br>Each subagent invocation creates a new instance with fresh context. To continue an existing subagent's work instead of starting over, ask Claude to resume it.&para;<br>&para;<br>Resumed subagents retain their full conversation history, including all previous tool calls, results, and reasoning. The subagent picks up exactly where it stopped rather than starting fresh.&para;<br>&para;<br>When a subagent completes, Claude receives its agent ID. To resume a subagent, ask Claude to continue the previous work:&para;<br>&para;<br>```&para;<br>Use the code-reviewer subagent to review the authentication module&para;<br>[Agent completes]&para;<br>&para;<br>Continue that code review and now analyze the authorization logic&para;<br>[Claude resumes the subagent with full context from previous conversation]&para;<br>```&para;<br>&para;<br>You can also ask Claude for the agent ID if you want to reference it explicitly, or find IDs in the transcript files at `~/.claude/projects/{project}/{sessionId}/subagents/`. Each transcript is stored as `agent-{agentId}.jsonl`.&para;<br>&para;<br>For programmatic usage, see [Subagents in the Agent SDK](/en/agent-sdk/subagents).&para;<br>&para;<br>Subagent transcripts persist independently of the main conversation:&para;<br>&para;<br>* **Main conversation compaction**: When the main conversation compacts, subagent transcripts are unaffected. They're stored in separate files.&para;<br>* **Session persistence**: Subagent transcripts persist within their session. You can [resume a subagent](#resume-subagents) after restarting Claude Code by resuming the same session.&para;<br>* **Automatic cleanup**: Transcripts are cleaned up based on the `cleanupPeriodDays` setting (default: 30 days).&para;<br>&para;<br>#### Auto-compaction&para;<br>&para;<br>Subagents support automatic compaction using the same logic as the main conversation. When a subagent's context approaches its limit, Claude Code summarizes older messages to free up space while preserving important context.&para;<br>&para;<br>Compaction events are logged in subagent transcript files:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "type": "system",&para;<br>  "subtype": "compact_boundary",&para;<br>  "compactMetadata": {&para;<br>    "trigger": "auto",&para;<br>    "preTokens": 167189&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>The `preTokens` value shows how many tokens were used before compaction occurred.&para;<br>&para;<br>## Example subagents&para;<br>&para;<br>These examples demonstrate effective patterns for building subagents. Use them as starting points, or generate a customized version with Claude.&para;<br>&para;<br>&lt;Tip&gt;&para;<br>  **Best practices:**&para;<br>&para;<br>  * **Design focused subagents:** each subagent should excel at one specific task&para;<br>  * **Write detailed descriptions:** Claude uses the description to decide when to delegate&para;<br>  * **Limit tool access:** grant only necessary permissions for security and focus&para;<br>  * **Check into version control:** share project subagents with your team&para;<br>&lt;/Tip&gt;&para;<br>&para;<br>### Code reviewer&para;<br>&para;<br>A read-only subagent that reviews code without modifying it. This example shows how to design a focused subagent with limited tool access (no Edit or Write) and a detailed prompt that specifies exactly what to look for and how to format output.</ins><span>&para;<br>&para;<br>```markdown  theme={null}&para;<br>---&para;<br>name: code-reviewer&para;<br>description: Expert code review specialist. Proactively reviews code for quality, security, and maintainability. Use immediately after writing or modifying code.&para;<br>tools: Read, Grep, Glob, Bash&para;<br>model: inherit&para;<br>---&para;<br>&para;<br>You are a senior code reviewer ensuring high standards of code quality and security.&para;<br>&para;<br>When invoked:&para;<br>1. Run git diff to see recent changes&para;<br>2. Focus on modified files&para;<br>3. Begin review immediately&para;<br>&para;<br>Review checklist:&para;<br>- Code is clear and readable&para;<br>- Functions and variables are well-named&para;<br>- No duplicated code&para;<br>- Proper error handling&para;<br>- No exposed secrets or API keys&para;<br>- Input validation implemented&para;<br>- Good test coverage&para;<br>- Performance considerations addressed&para;<br>&para;<br>Provide feedback organized by priority:&para;<br>- Critical issues (must fix)&para;<br>- Warnings (should fix)&para;<br>- Suggestions (consider improving)&para;<br>&para;<br>Include specific examples of how to fix issues.&para;<br>```&para;<br>&para;<br>### Debugger&para;<br>&para;<br></span><ins style="background:#e6ffe6;">A subagent that can both analyze and fix issues. Unlike the code reviewer, this one includes Edit because fixing bugs requires modifying code. The prompt provides a clear workflow from diagnosis to verification.&para;<br>&para;<br></ins><span>```markdown  theme={null}&para;<br>---&para;<br>name: debugger&para;<br>description: Debugging specialist for errors, test failures, and unexpected behavior. Use proactively when encountering any issues.&para;<br>tools: Read, Edit, Bash, Grep, Glob&para;<br>---&para;<br>&para;<br>You are an expert debugger specializing in root cause analysis.&para;<br>&para;<br>When invoked:&para;<br>1. Capture error message and stack trace&para;<br>2. Identify reproduction steps&para;<br>3. Isolate the failure location&para;<br>4. Implement minimal fix&para;<br>5. Verify solution works&para;<br>&para;<br>Debugging process:&para;<br>- Analyze error messages and logs&para;<br>- Check recent code changes&para;<br>- Form and test hypotheses&para;<br>- Add strategic debug logging&para;<br>- Inspect variable states&para;<br>&para;<br>For each issue, provide:&para;<br>- Root cause explanation&para;<br>- Evidence supporting the diagnosis&para;<br>- Specific code fix&para;<br>- Testing approach&para;<br>- Prevention recommendations&para;<br>&para;<br>Focus on fixing the underlying issue, not the symptoms.&para;<br>```&para;<br>&para;<br>### Data scientist&para;<br>&para;<br></span><ins style="background:#e6ffe6;">A domain-specific subagent for data analysis work. This example shows how to create subagents for specialized workflows outside of typical coding tasks. It explicitly sets `model: sonnet` for more capable analysis.&para;<br>&para;<br></ins><span>```markdown  theme={null}&para;<br>---&para;<br>name: data-scientist&para;<br>description: Data analysis expert for SQL queries, BigQuery operations, and data insights. Use proactively for data analysis tasks and queries.&para;<br>tools: Bash, Read, Write&para;<br>model: sonnet&para;<br>---&para;<br>&para;<br>You are a data scientist specializing in SQL and BigQuery analysis.&para;<br>&para;<br>When invoked:&para;<br>1. Understand the data analysis requirement&para;<br>2. Write efficient SQL queries&para;<br>3. Use BigQuery command line tools (bq) when appropriate&para;<br>4. Analyze and summarize results&para;<br>5. Present findings clearly&para;<br>&para;<br>Key practices:&para;<br>- Write optimized SQL queries with proper filters&para;<br>- Use appropriate aggregations and joins&para;<br>- Include comments explaining complex logic&para;<br>- Format results for readability&para;<br>- Provide data-driven recommendations&para;<br>&para;<br>For each analysis:&para;<br>- Explain the query approach&para;<br>- Document any assumptions&para;<br>- Highlight key findings&para;<br>- Suggest next steps based on data&para;<br>&para;<br>Always ensure queries are efficient and cost-effective.&para;<br>```&para;<br>&para;<br>## </span><del style="background:#ffe6e6;">Best practices&para;<br>&para;<br>* **Start with Claude-generated agents**: We highly recommend generating your initial subagent with Claude and then iterating on it to make it personally yours. This approach gives you the best results - a solid foundation that you can customize to your specific needs.&para;<br>&para;<br>* **Design focused subagents**: Create subagents with single, clear responsibilities rather than trying to make one subagent do everything. This improves performance and makes subagents more predictable.&para;<br>&para;<br>* **Write detailed prompts**: Include specific instructions, examples, and constraints in your system prompts. The more guidance you provide, the better the subagent will perform.&para;<br>&para;<br>* **Limit tool access**: Only grant tools that are necessary for the subagent's purpose. This improves security and helps the subagent focus on relevant actions.&para;<br>&para;<br>* **Version control**: Check project subagents into version control so your team can benefit from and improve them collaboratively.&para;<br>&para;<br>## Advanced usage&para;<br>&para;<br>### Chaining subagents&para;<br>&para;<br>For complex workflows, you can chain multiple subagents:&para;<br>&para;<br>```&para;<br>&gt; First use the code-analyzer subagent to find performance issues, then use the optimizer subagent to fix them&para;<br>```&para;<br>&para;<br>### Dynamic subagent selection&para;<br>&para;<br>Claude Code intelligently selects subagents based on context. Make your `description` fields specific and action-oriented for best results.&para;<br>&para;<br>### Resumable subagents&para;<br>&para;<br>Subagents can be resumed to continue previous conversations, which is particularly useful for long-running research or analysis tasks that need to be continued across multiple invocations.&para;<br>&para;<br>**How it works:**&para;<br>&para;<br>* Each subagent execution is assigned a unique `agentId`&para;<br>* The agent's conversation is stored in a separate transcript file: `agent-{agentId}.jsonl`&para;<br>* You can resume a previous agent by providing its `agentId` via the `resume` parameter&para;<br>* When resumed, the agent continues with full context from its previous conversation&para;<br>&para;<br>**Example workflow:**&para;<br>&para;<br>Initial invocation:&para;<br>&para;<br>```&para;<br>&gt; Use the code-analyzer agent to start reviewing the authentication module&para;<br>&para;<br>[Agent completes initial analysis and returns agentId: "abc123"]&para;<br>```&para;<br>&para;<br>Resume the agent:&para;<br>&para;<br>```&para;<br>&gt; Resume agent abc123 and now analyze the authorization logic as well&para;<br>&para;<br>[Agent continues with full context from previous conversation]&para;<br>```&para;<br>&para;<br>**Use cases:**&para;<br>&para;<br>* **Long-running research**: Break down large codebase analysis into multiple sessions&para;<br>* **Iterative refinement**: Continue refining a subagent's work without losing context&para;<br>* **Multi-step workflows**: Have a subagent work on related tasks sequentially while maintaining context&para;<br>&para;<br>**Technical details:**&para;<br>&para;<br>* Agent transcripts are stored in your project directory&para;<br>* Recording is disabled during resume to avoid duplicating messages&para;<br>* Both synchronous and asynchronous agents can be resumed&para;<br>* The `resume` parameter accepts the agent ID from a previous execution&para;<br>&para;<br>**Programmatic usage:**&para;<br>&para;<br>If you're using the Agent SDK or interacting with the AgentTool directly, you can pass the `resume` parameter:&para;<br>&para;<br>```typescript  theme={null}&para;<br>{&para;<br>  "description": "Continue analysis",&para;<br>  "prompt": "Now examine the error handling patterns",&para;<br>  "subagent_type": "code-analyzer",&para;<br>  "resume": "abc123"  // Agent ID from previous execution&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;Tip&gt;&para;<br>  Keep track of agent IDs for tasks you may want to resume later. Claude Code displays the agent ID when a subagent completes its work.&para;<br>&lt;/Tip&gt;&para;<br>&para;<br>## Performance considerations&para;<br>&para;<br>* **Context efficiency**: Agents help preserve main context, enabling longer overall sessions&para;<br>* **Latency**: Subagents start off with a clean slate each time they are invoked and may add latency as they gather context that they require to do their job effectively.&para;<br>&para;<br>## Related documentation&para;<br>&para;<br>* [Plugins](/en/plugins) - Extend Claude Code with custom agents through plugins&para;<br>* [Slash commands](/en/slash-commands) - Learn about other built-in commands&para;<br>* [Settings](/en/settings) - Configure Claude Code behavior&para;<br>* [Hooks](/en/hooks) - Automate workflows with event handlers</del><ins style="background:#e6ffe6;">Next steps&para;<br>&para;<br>Now that you understand subagents, explore these related features:&para;<br>&para;<br>* [Distribute subagents with plugins](/en/plugins) to share subagents across teams or projects&para;<br>* [Run Claude Code programmatically](/en/headless) with the Agent SDK for CI/CD and automation&para;<br>* [Use MCP servers](/en/mcp) to give subagents access to external tools and data</ins><span>&para;<br>&para;<br>&para;<br>---&para;<br>&para;<br>&gt; To find navigation and other pages in this documentation, fetch the llms.txt file at: https://code.claude.com/docs/llms.txt</span></div>
        </div>

        <h2 style="margin-top: 2rem; margin-bottom: 1rem;">Unified Diff</h2>
        <pre><code>--- a/sub-agents.md
+++ b/sub-agents.md
@@ -1,105 +1,149 @@
-# Subagents
+# Create custom subagents
 
 &gt; Create and use specialized AI subagents in Claude Code for task-specific workflows and improved context management.
 
-Custom subagents in Claude Code are specialized AI assistants that can be invoked to handle specific types of tasks. They enable more efficient problem-solving by providing task-specific configurations with customized system prompts, tools and a separate context window.
-
-## What are subagents?
-
-Subagents are pre-configured AI personalities that Claude Code can delegate tasks to. Each subagent:
-
-* Has a specific purpose and expertise area
-* Uses its own context window separate from the main conversation
-* Can be configured with specific tools it&#39;s allowed to use
-* Includes a custom system prompt that guides its behavior
-
-When Claude Code encounters a task that matches a subagent&#39;s expertise, it can delegate that task to the specialized subagent, which works independently and returns results.
-
-## Key benefits
-
-&lt;CardGroup cols={2}&gt;
-  &lt;Card title=&#34;Context preservation&#34; icon=&#34;layer-group&#34;&gt;
-    Each subagent operates in its own context, preventing pollution of the main conversation and keeping it focused on high-level objectives.
-  &lt;/Card&gt;
-
-  &lt;Card title=&#34;Specialized expertise&#34; icon=&#34;brain&#34;&gt;
-    Subagents can be fine-tuned with detailed instructions for specific domains, leading to higher success rates on designated tasks.
-  &lt;/Card&gt;
-
-  &lt;Card title=&#34;Reusability&#34; icon=&#34;rotate&#34;&gt;
-    Once created, you can use subagents across different projects and share them with your team for consistent workflows.
-  &lt;/Card&gt;
-
-  &lt;Card title=&#34;Flexible permissions&#34; icon=&#34;shield-check&#34;&gt;
-    Each subagent can have different tool access levels, allowing you to limit powerful tools to specific subagent types.
-  &lt;/Card&gt;
-&lt;/CardGroup&gt;
-
-## Quick start
-
-To create your first subagent:
+Subagents are specialized AI assistants that handle specific types of tasks. Each subagent runs in its own context window with a custom system prompt, specific tool access, and independent permissions. When Claude encounters a task that matches a subagent&#39;s description, it delegates to that subagent, which works independently and returns results.
+
+Subagents help you:
+
+* **Preserve context** by keeping exploration and implementation out of your main conversation
+* **Enforce constraints** by limiting which tools a subagent can use
+* **Reuse configurations** across projects with user-level subagents
+* **Specialize behavior** with focused system prompts for specific domains
+* **Control costs** by routing tasks to faster, cheaper models like Haiku
+
+Claude uses each subagent&#39;s description to decide when to delegate tasks. When you create a subagent, write a clear description so Claude knows when to use it.
+
+Claude Code includes several built-in subagents like **Explore**, **Plan**, and **general-purpose**. You can also create custom subagents to handle specific tasks. This page covers the [built-in subagents](#built-in-subagents), [how to create your own](#quickstart-create-your-first-subagent), [full configuration options](#configure-subagents), [patterns for working with subagents](#work-with-subagents), and [example subagents](#example-subagents).
+
+## Built-in subagents
+
+Claude Code includes built-in subagents that Claude automatically uses when appropriate. Each inherits the parent conversation&#39;s permissions with additional tool restrictions.
+
+&lt;Tabs&gt;
+  &lt;Tab title=&#34;Explore&#34;&gt;
+    A fast, read-only agent optimized for searching and analyzing codebases.
+
+    * **Model**: Haiku (fast, low-latency)
+    * **Tools**: Read-only tools (denied access to Write and Edit tools)
+    * **Purpose**: File discovery, code search, codebase exploration
+
+    Claude delegates to Explore when it needs to search or understand a codebase without making changes. This keeps exploration results out of your main conversation context.
+
+    When invoking Explore, Claude specifies a thoroughness level: **quick** for targeted lookups, **medium** for balanced exploration, or **very thorough** for comprehensive analysis.
+  &lt;/Tab&gt;
+
+  &lt;Tab title=&#34;Plan&#34;&gt;
+    A research agent used during [plan mode](/en/common-workflows#use-plan-mode-for-safe-code-analysis) to gather context before presenting a plan.
+
+    * **Model**: Inherits from main conversation
+    * **Tools**: Read-only tools (denied access to Write and Edit tools)
+    * **Purpose**: Codebase research for planning
+
+    When you&#39;re in plan mode and Claude needs to understand your codebase, it delegates research to the Plan subagent. This prevents infinite nesting (subagents cannot spawn other subagents) while still gathering necessary context.
+  &lt;/Tab&gt;
+
+  &lt;Tab title=&#34;General-purpose&#34;&gt;
+    A capable agent for complex, multi-step tasks that require both exploration and action.
+
+    * **Model**: Inherits from main conversation
+    * **Tools**: All tools
+    * **Purpose**: Complex research, multi-step operations, code modifications
+
+    Claude delegates to general-purpose when the task requires both exploration and modification, complex reasoning to interpret results, or multiple dependent steps.
+  &lt;/Tab&gt;
+&lt;/Tabs&gt;
+
+Beyond these built-in subagents, you can create your own with custom prompts, tool restrictions, permission modes, hooks, and skills. The following sections show how to get started and customize subagents.
+
+## Quickstart: create your first subagent
+
+Subagents are defined in Markdown files with YAML frontmatter. You can [create them manually](#write-subagent-files) or use the `/agents` slash command.
+
+This walkthrough guides you through creating a user-level subagent with the `/agent` command. The subagent reviews code and suggests improvements for the codebase.
 
 &lt;Steps&gt;
   &lt;Step title=&#34;Open the subagents interface&#34;&gt;
-    Run the following command:
+    In Claude Code, run:
 
     ```
     /agents
     ```
   &lt;/Step&gt;
 
-  &lt;Step title=&#34;Select &#39;Create New Agent&#39;&#34;&gt;
-    Choose whether to create a project-level or user-level subagent
+  &lt;Step title=&#34;Create a new user-level agent&#34;&gt;
+    Select **Create new agent**, then choose **User-level**. This saves the subagent to `~/.claude/agents/` so it&#39;s available in all your projects.
   &lt;/Step&gt;
 
-  &lt;Step title=&#34;Define the subagent&#34;&gt;
-    * **Recommended**: generate with Claude first, then customize to make it yours
-    * Describe your subagent in detail, including when Claude should use it
-    * Select the tools you want to grant access to, or leave this blank to inherit all tools
-    * The interface shows all available tools
-    * If you&#39;re generating with Claude, you can also edit the system prompt in your own editor by pressing `e`
+  &lt;Step title=&#34;Generate with Claude&#34;&gt;
+    Select **Generate with Claude**. When prompted, describe the subagent:
+
+    ```
+    A code improvement agent that scans files and suggests improvements
+    for readability, performance, and best practices. It should explain
+    each issue, show the current code, and provide an improved version.
+    ```
+
+    Claude generates the system prompt and configuration. Press `e` to open it in your editor if you want to customize it.
   &lt;/Step&gt;
 
-  &lt;Step title=&#34;Save and use&#34;&gt;
-    Your subagent is now available. Claude uses it automatically when appropriate, or you can invoke it explicitly:
+  &lt;Step title=&#34;Select tools&#34;&gt;
+    For a read-only reviewer, deselect everything except **Read-only tools**. If you keep all tools selected, the subagent inherits all tools available to the main conversation.
+  &lt;/Step&gt;
+
+  &lt;Step title=&#34;Select model&#34;&gt;
+    Choose which model the subagent uses. For this example agent, select **Sonnet**, which balances capability and speed for analyzing code patterns.
+  &lt;/Step&gt;
+
+  &lt;Step title=&#34;Choose a color&#34;&gt;
+    Pick a background color for the subagent. This helps you identify which subagent is running in the UI.
+  &lt;/Step&gt;
+
+  &lt;Step title=&#34;Save and try it out&#34;&gt;
+    Save the subagent. It&#39;s available immediately (no restart needed). Try it:
 
     ```
-    &gt; Use the code-reviewer subagent to check my recent changes
+    Use the code-improver agent to suggest improvements in this project
     ```
+
+    Claude delegates to your new subagent, which scans the codebase and returns improvement suggestions.
   &lt;/Step&gt;
 &lt;/Steps&gt;
 
-## Subagent configuration
-
-### File locations
-
-Subagents are stored as Markdown files with YAML frontmatter in two possible locations:
-
-| Type                  | Location            | Scope                         | Priority |
-| :-------------------- | :------------------ | :---------------------------- | :------- |
-| **Project subagents** | `.claude/agents/`   | Available in current project  | Highest  |
-| **User subagents**    | `~/.claude/agents/` | Available across all projects | Lower    |
-
-When subagent names conflict, project-level subagents take precedence over user-level subagents.
-
-### Plugin agents
-
-[Plugins](/en/plugins) can provide custom subagents that integrate seamlessly with Claude Code. Plugin agents work identically to user-defined agents and appear in the `/agents` interface.
-
-**Plugin agent locations**: plugins include agents in their `agents/` directory (or custom paths specified in the plugin manifest).
-
-**Using plugin agents**:
-
-* Plugin agents appear in `/agents` alongside your custom agents
-* Can be invoked explicitly: &#34;Use the code-reviewer agent from the security-plugin&#34;
-* Can be invoked automatically by Claude when appropriate
-* Can be managed (viewed, inspected) through `/agents` interface
-
-See the [plugin components reference](/en/plugins-reference#agents) for details on creating plugin agents.
-
-### CLI-based configuration
-
-You can also define subagents dynamically using the `--agents` CLI flag, which accepts a JSON object:
+You now have a subagent you can use in any project on your machine to analyze codebases and suggest improvements.
+
+You can also create subagents manually as Markdown files, define them via CLI flags, or distribute them through plugins. The following sections cover all configuration options.
+
+## Configure subagents
+
+### Use the /agents command
+
+The `/agents` command provides an interactive interface for managing subagents. Run `/agents` to:
+
+* View all available subagents (built-in, user, project, and plugin)
+* Create new subagents with guided setup or Claude generation
+* Edit existing subagent configuration and tool access
+* Delete custom subagents
+* See which subagents are active when duplicates exist
+
+This is the recommended way to create and manage subagents. For manual creation or automation, you can also add subagent files directly.
+
+### Choose the subagent scope
+
+Subagents are Markdown files with YAML frontmatter. Store them in different locations depending on scope. When multiple subagents share the same name, the higher-priority location wins.
+
+| Location                     | Scope                   | Priority    | How to create                         |
+| :--------------------------- | :---------------------- | :---------- | :------------------------------------ |
+| `--agents` CLI flag          | Current session         | 1 (highest) | Pass JSON when launching Claude Code  |
+| `.claude/agents/`            | Current project         | 2           | Interactive or manual                 |
+| `~/.claude/agents/`          | All your projects       | 3           | Interactive or manual                 |
+| Plugin&#39;s `agents/` directory | Where plugin is enabled | 4 (lowest)  | Installed with [plugins](/en/plugins) |
+
+**Project subagents** (`.claude/agents/`) are ideal for subagents specific to a codebase. Check them into version control so your team can use and improve them collaboratively.
+
+**User subagents** (`~/.claude/agents/`) are personal subagents available in all your projects.
+
+**CLI-defined subagents** are passed as JSON when launching Claude Code. They exist only for that session and aren&#39;t saved to disk, making them useful for quick testing or automation scripts:
 
 ```bash  theme={null}
 claude --agents &#39;{
@@ -112,87 +156,163 @@
 }&#39;
 ```
 
-**Priority**: CLI-defined subagents have lower priority than project-level subagents but higher priority than user-level subagents.
-
-**Use case**: This approach is useful for:
-
-* Quick testing of subagent configurations
-* Session-specific subagents that don&#39;t need to be saved
-* Automation scripts that need custom subagents
-* Sharing subagent definitions in documentation or scripts
-
-For detailed information about the JSON format and all available options, see the [CLI reference documentation](/en/cli-reference#agents-flag-format).
-
-### File format
-
-Each subagent is defined in a Markdown file with this structure:
+The `--agents` flag accepts JSON with the same fields as [frontmatter](#supported-frontmatter-fields). Use `prompt` for the system prompt (equivalent to the markdown body in file-based subagents). See the [CLI reference](/en/cli-reference#agents-flag-format) for the full JSON format.
+
+**Plugin subagents** come from [plugins](/en/plugins) you&#39;ve installed. They appear in `/agents` alongside your custom subagents. See the [plugin components reference](/en/plugins-reference#agents) for details on creating plugin subagents.
+
+### Write subagent files
+
+Subagent files use YAML frontmatter for configuration, followed by the system prompt in Markdown:
+
+&lt;Note&gt;
+  Subagents are loaded at session start. If you create a subagent by manually adding a file, restart your session or use `/agents` to load it immediately.
+&lt;/Note&gt;
 
 ```markdown  theme={null}
 ---
-name: your-sub-agent-name
-description: Description of when this subagent should be invoked
-tools: tool1, tool2, tool3  # Optional - inherits all tools if omitted
-model: sonnet  # Optional - specify model alias or &#39;inherit&#39;
-permissionMode: default  # Optional - permission mode for the subagent
-skills: skill1, skill2  # Optional - skills to auto-load
----
-
-Your subagent&#39;s system prompt goes here. This can be multiple paragraphs
-and should clearly define the subagent&#39;s role, capabilities, and approach
-to solving problems.
-
-Include specific instructions, best practices, and any constraints
-the subagent should follow.
-```
-
-#### Configuration fields
-
-| Field            | Required | Description                                                                                                                                                                                                     |
-| :--------------- | :------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
-| `name`           | Yes      | Unique identifier using lowercase letters and hyphens                                                                                                                                                           |
-| `description`    | Yes      | Natural language description of the subagent&#39;s purpose                                                                                                                                                          |
-| `tools`          | No       | Comma-separated list of specific tools. If omitted, inherits all tools from the main thread                                                                                                                     |
-| `model`          | No       | Model to use for this subagent. Can be a model alias (`sonnet`, `opus`, `haiku`) or `&#39;inherit&#39;` to use the main conversation&#39;s model. If omitted, defaults to the [configured subagent model](/en/model-config) |
-| `permissionMode` | No       | Permission mode for the subagent. Valid values: `default`, `acceptEdits`, `dontAsk`, `bypassPermissions`, `plan`, `ignore`. Controls how the subagent handles permission requests                               |
-| `skills`         | No       | Comma-separated list of skill names to auto-load when the subagent starts. Subagents do not inherit Skills from the parent conversation. If omitted, no Skills are preloaded.                                   |
-| `hooks`          | No       | Define hooks scoped to this subagent&#39;s lifecycle. Supports `PreToolUse`, `PostToolUse`, and `Stop` events. See [Define hooks for subagents](#define-hooks-for-subagents).                                       |
-
-### Model selection
-
-The `model` field allows you to control which [AI model](/en/model-config) the subagent uses:
+name: code-reviewer
+description: Reviews code for quality and best practices
+tools: Read, Glob, Grep
+model: sonnet
+---
+
+You are a code reviewer. When invoked, analyze the code and provide
+specific, actionable feedback on quality, security, and best practices.
+```
+
+The frontmatter defines the subagent&#39;s metadata and configuration. The body becomes the system prompt that guides the subagent&#39;s behavior. Subagents receive only this system prompt (plus basic environment details like working directory), not the full Claude Code system prompt.
+
+#### Supported frontmatter fields
+
+The following fields can be used in the YAML frontmatter. Only `name` and `description` are required.
+
+| Field             | Required | Description                                                                                                                                                                                                  |
+| :---------------- | :------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
+| `name`            | Yes      | Unique identifier using lowercase letters and hyphens                                                                                                                                                        |
+| `description`     | Yes      | When Claude should delegate to this subagent                                                                                                                                                                 |
+| `tools`           | No       | [Tools](#available-tools) the subagent can use. Inherits all tools if omitted                                                                                                                                |
+| `disallowedTools` | No       | Tools to deny, removed from inherited or specified list                                                                                                                                                      |
+| `model`           | No       | [Model](#choose-a-model) to use: `sonnet`, `opus`, `haiku`, or `inherit`. Defaults to `sonnet`                                                                                                               |
+| `permissionMode`  | No       | [Permission mode](#permission-modes): `default`, `acceptEdits`, `dontAsk`, `bypassPermissions`, or `plan`                                                                                                    |
+| `skills`          | No       | [Skills](/en/skills) to load into the subagent&#39;s context at startup. The full skill content is injected, not just made available for invocation. Subagents don&#39;t inherit skills from the parent conversation |
+| `hooks`           | No       | [Lifecycle hooks](#define-hooks-for-subagents) scoped to this subagent                                                                                                                                       |
+
+### Choose a model
+
+The `model` field controls which [AI model](/en/model-config) the subagent uses:
 
 * **Model alias**: Use one of the available aliases: `sonnet`, `opus`, or `haiku`
-* **`&#39;inherit&#39;`**: Use the same model as the main conversation (useful for consistency)
+* **inherit**: Use the same model as the main conversation (useful for consistency)
 * **Omitted**: If not specified, uses the default model configured for subagents (`sonnet`)
 
-&lt;Note&gt;
-  Using `&#39;inherit&#39;` is particularly useful when you want your subagents to adapt to the model choice of the main conversation, ensuring consistent capabilities and response style throughout your session.
-&lt;/Note&gt;
-
-### Available tools
-
-Subagents can be granted access to any of Claude Code&#39;s internal tools. See the [tools documentation](/en/settings#tools-available-to-claude) for a complete list of available tools.
-
-&lt;Tip&gt;
-  **Recommended:** Use the `/agents` command to modify tool access - it provides an interactive interface that lists all available tools, including any connected MCP server tools, making it easier to select the ones you need.
-&lt;/Tip&gt;
-
-You have two options for configuring tools:
-
-* **Omit the `tools` field** to inherit all tools from the main thread (default), including MCP tools
-* **Specify individual tools** as a comma-separated list for more granular control (can be edited manually or via `/agents`)
-
-**MCP Tools**: Subagents can access MCP tools from configured MCP servers. When the `tools` field is omitted, subagents inherit all MCP tools available to the main thread.
+### Control subagent capabilities
+
+You can control what subagents can do through tool access, permission modes, and conditional rules.
+
+#### Available tools
+
+Subagents can use any of Claude Code&#39;s [internal tools](/en/settings#tools-available-to-claude). By default, subagents inherit all tools from the main conversation, including MCP tools.
+
+To restrict tools, use the `tools` field (allowlist) or `disallowedTools` field (denylist):
+
+```yaml  theme={null}
+---
+name: safe-researcher
+description: Research agent with restricted capabilities
+tools: Read, Grep, Glob, Bash
+disallowedTools: Write, Edit
+---
+```
+
+#### Permission modes
+
+The `permissionMode` field controls how the subagent handles permission prompts. Subagents inherit the permission context from the main conversation but can override the mode.
+
+| Mode                | Behavior                                                           |
+| :------------------ | :----------------------------------------------------------------- |
+| `default`           | Standard permission checking with prompts                          |
+| `acceptEdits`       | Auto-accept file edits                                             |
+| `dontAsk`           | Auto-deny permission prompts (explicitly allowed tools still work) |
+| `bypassPermissions` | Skip all permission checks                                         |
+| `plan`              | Plan mode (read-only exploration)                                  |
+
+&lt;Warning&gt;
+  Use `bypassPermissions` with caution. It skips all permission checks, allowing the subagent to execute any operation without approval.
+&lt;/Warning&gt;
+
+If the parent uses `bypassPermissions`, this takes precedence and cannot be overridden.
+
+#### Conditional rules with hooks
+
+For more dynamic control over tool usage, use `PreToolUse` hooks to validate operations before they execute. This is useful when you need to allow some operations of a tool while blocking others.
+
+This example creates a subagent that only allows read-only database queries by validating commands before execution:
+
+```yaml  theme={null}
+---
+name: db-reader
+description: Execute read-only database queries
+tools: Bash
+hooks:
+  PreToolUse:
+    - matcher: &#34;Bash&#34;
+      hooks:
+        - type: command
+          command: &#34;./scripts/validate-readonly-query.sh&#34;
+---
+```
+
+The validation script inspects `$TOOL_INPUT` and exits with a non-zero code to block write operations. See [Define hooks for subagents](#define-hooks-for-subagents) for more hook configuration options.
+
+#### Disable specific subagents
+
+You can prevent Claude from using specific subagents by adding them to the `deny` array in your [settings](/en/settings#permission-settings). Use the format `Task(subagent-name)` where `subagent-name` matches the subagent&#39;s name field.
+
+```json  theme={null}
+{
+  &#34;permissions&#34;: {
+    &#34;deny&#34;: [&#34;Task(Explore)&#34;, &#34;Task(my-custom-agent)&#34;]
+  }
+}
+```
+
+This works for both built-in and custom subagents. You can also use the `--disallowedTools` CLI flag:
+
+```bash  theme={null}
+claude --disallowedTools &#34;Task(Explore)&#34;
+```
+
+See [IAM documentation](/en/iam#tool-specific-permission-rules) for more details on permission rules.
 
 ### Define hooks for subagents
 
-Subagents can define hooks that run during the subagent&#39;s lifecycle. Use the `hooks` field to specify `PreToolUse`, `PostToolUse`, or `Stop` handlers:
+Subagents can define [hooks](/en/hooks) that run during the subagent&#39;s lifecycle. There are two ways to configure hooks:
+
+1. **In the subagent&#39;s frontmatter**: Define hooks that run only while that subagent is active
+2. **In `settings.json`**: Define hooks that run in the main session when subagents start or stop
+
+#### Hooks in subagent frontmatter
+
+Define hooks directly in the subagent&#39;s markdown file. These hooks only run while that specific subagent is active and are cleaned up when it finishes.
+
+| Event         | Matcher input | When it fires                   |
+| :------------ | :------------ | :------------------------------ |
+| `PreToolUse`  | Tool name     | Before the subagent uses a tool |
+| `PostToolUse` | Tool name     | After the subagent uses a tool  |
+| `Stop`        | (none)        | When the subagent finishes      |
+
+This example validates Bash commands with the `PreToolUse` hook and runs a linter after file edits with `PostToolUse`:
 
 ```yaml  theme={null}
 ---
 name: code-reviewer
 description: Review code changes with automatic linting
 hooks:
+  PreToolUse:
+    - matcher: &#34;Bash&#34;
+      hooks:
+        - type: command
+          command: &#34;./scripts/validate-command.sh $TOOL_INPUT&#34;
   PostToolUse:
     - matcher: &#34;Edit|Write&#34;
       hooks:
@@ -201,214 +321,187 @@
 ---
 ```
 
-Hooks defined in a subagent are scoped to that subagent&#39;s execution and are automatically cleaned up when the subagent finishes.
-
-See [Hooks](/en/hooks) for the complete hook configuration format.
-
-## Managing subagents
-
-### Using the /agents command (Recommended)
-
-The `/agents` command provides a comprehensive interface for subagent management:
-
-```
-/agents
-```
-
-This opens an interactive menu where you can:
-
-* View all available subagents (built-in, user, and project)
-* Create new subagents with guided setup
-* Edit existing custom subagents, including their tool access
-* Delete custom subagents
-* See which subagents are active when duplicates exist
-* **Manage tool permissions** with a complete list of available tools
-
-### Direct file management
-
-You can also manage subagents by working directly with their files:
-
-```bash  theme={null}
-# Create a project subagent
-mkdir -p .claude/agents
-echo &#39;---
-name: test-runner
-description: Use proactively to run tests and fix failures
----
-
-You are a test automation expert. When you see code changes, proactively run the appropriate tests. If tests fail, analyze the failures and fix them while preserving the original test intent.&#39; &gt; .claude/agents/test-runner.md
-
-# Create a user subagent
-mkdir -p ~/.claude/agents
-# ... create subagent file
-```
-
-&lt;Note&gt;
-  Subagents created by manually adding files will be loaded the next time you start a Claude Code session. To create and use a subagent immediately without restarting, use the `/agents` command instead.
-&lt;/Note&gt;
-
-### Disabling specific subagents
-
-You can disable specific built-in or custom subagents using the `Task(AgentName)` permission rule syntax. Add these rules to the `deny` array in your [settings](/en/settings#permission-settings) or use the `--disallowedTools` CLI flag.
-
-**Example settings.json configuration:**
+`Stop` hooks in frontmatter are automatically converted to `SubagentStop` events.
+
+#### Project-level hooks for subagent events
+
+Configure hooks in `settings.json` that respond to subagent lifecycle events in the main session. Use the `matcher` field to target specific agent types by name.
+
+| Event           | Matcher input   | When it fires                    |
+| :-------------- | :-------------- | :------------------------------- |
+| `SubagentStart` | Agent type name | When a subagent begins execution |
+| `SubagentStop`  | Agent type name | When a subagent completes        |
+
+This example runs setup and cleanup scripts only when the `db-agent` subagent starts and stops:
 
 ```json  theme={null}
 {
-  &#34;permissions&#34;: {
-    &#34;deny&#34;: [&#34;Task(Explore)&#34;, &#34;Task(Plan)&#34;]
+  &#34;hooks&#34;: {
+    &#34;SubagentStart&#34;: [
+      {
+        &#34;matcher&#34;: &#34;db-agent&#34;,
+        &#34;hooks&#34;: [
+          { &#34;type&#34;: &#34;command&#34;, &#34;command&#34;: &#34;./scripts/setup-db-connection.sh&#34; }
+        ]
+      }
+    ],
+    &#34;SubagentStop&#34;: [
+      {
+        &#34;matcher&#34;: &#34;db-agent&#34;,
+        &#34;hooks&#34;: [
+          { &#34;type&#34;: &#34;command&#34;, &#34;command&#34;: &#34;./scripts/cleanup-db-connection.sh&#34; }
+        ]
+      }
+    ]
   }
 }
 ```
 
-**Example CLI usage:**
-
-```bash  theme={null}
-claude --disallowedTools &#34;Task(Explore)&#34;
-```
-
-This is useful when you want to prevent Claude from delegating tasks to specific subagents, either for security reasons or to enforce a particular workflow.
-
-See [IAM documentation](/en/iam#tool-specific-permission-rules) for more details on permission rules.
-
-## Using subagents effectively
-
-### Automatic delegation
-
-Claude Code proactively delegates tasks based on:
-
-* The task description in your request
-* The `description` field in subagent configurations
-* Current context and available tools
+See [Hooks](/en/hooks) for the complete hook configuration format.
+
+## Work with subagents
+
+### Understand automatic delegation
+
+Claude automatically delegates tasks based on the task description in your request, the `description` field in subagent configurations, and current context. To encourage proactive delegation, include phrases like &#34;use proactively&#34; in your subagent&#39;s description field.
+
+You can also request a specific subagent explicitly:
+
+```
+Use the test-runner subagent to fix failing tests
+Have the code-reviewer subagent look at my recent changes
+```
+
+### Run subagents in foreground or background
+
+Subagents can run in the foreground (blocking) or background (concurrent):
+
+* **Foreground subagents** block the main conversation until complete. Permission prompts and clarifying questions (like [`AskUserQuestion`](/en/settings#tools-available-to-claude)) are passed through to you.
+* **Background subagents** run concurrently while you continue working. They inherit the parent&#39;s permissions and auto-deny anything not pre-approved. If a background subagent needs a permission it doesn&#39;t have or needs to ask clarifying questions, that tool call fails but the subagent continues. MCP tools are not available in background subagents.
+
+If a background subagent fails due to missing permissions, you can [resume it](#resume-subagents) in the foreground to retry with interactive prompts.
+
+Claude decides whether to run subagents in the foreground or background based on the task. You can also:
+
+* Ask Claude to &#34;run this in the background&#34;
+* Press **Ctrl+B** to background a running task
+
+### Common patterns
+
+#### Isolate high-volume operations
+
+One of the most effective uses for subagents is isolating operations that produce large amounts of output. Running tests, fetching documentation, or processing log files can consume significant context. By delegating these to a subagent, the verbose output stays in the subagent&#39;s context while only the relevant summary returns to your main conversation.
+
+```
+Use a subagent to run the test suite and report only the failing tests with their error messages
+```
+
+#### Run parallel research
+
+For independent investigations, spawn multiple subagents to work simultaneously:
+
+```
+Research the authentication, database, and API modules in parallel using separate subagents
+```
+
+Each subagent explores its area independently, then Claude synthesizes the findings. This works best when the research paths don&#39;t depend on each other.
+
+&lt;Warning&gt;
+  When subagents complete, their results return to your main conversation. Running many subagents that each return detailed results can consume significant context.
+&lt;/Warning&gt;
+
+#### Chain subagents
+
+For multi-step workflows, ask Claude to use subagents in sequence. Each subagent completes its task and returns results to Claude, which then passes relevant context to the next subagent.
+
+```
+Use the code-reviewer subagent to find performance issues, then use the optimizer subagent to fix them
+```
+
+### Choose between subagents and main conversation
+
+Use the **main conversation** when:
+
+* The task needs frequent back-and-forth or iterative refinement
+* Multiple phases share significant context (planning  implementation  testing)
+* You&#39;re making a quick, targeted change
+* Latency matters. Subagents start fresh and may need time to gather context
+
+Use **subagents** when:
+
+* The task produces verbose output you don&#39;t need in your main context
+* You want to enforce specific tool restrictions or permissions
+* The work is self-contained and can return a summary
+
+Consider [Skills](/en/skills) instead when you want reusable prompts or workflows that run in the main conversation context rather than isolated subagent context.
+
+&lt;Note&gt;
+  Subagents cannot spawn other subagents. If your workflow requires nested delegation, use [Skills](/en/skills) or [chain subagents](#chain-subagents) from the main conversation.
+&lt;/Note&gt;
+
+### Manage subagent context
+
+#### Resume subagents
+
+Each subagent invocation creates a new instance with fresh context. To continue an existing subagent&#39;s work instead of starting over, ask Claude to resume it.
+
+Resumed subagents retain their full conversation history, including all previous tool calls, results, and reasoning. The subagent picks up exactly where it stopped rather than starting fresh.
+
+When a subagent completes, Claude receives its agent ID. To resume a subagent, ask Claude to continue the previous work:
+
+```
+Use the code-reviewer subagent to review the authentication module
+[Agent completes]
+
+Continue that code review and now analyze the authorization logic
+[Claude resumes the subagent with full context from previous conversation]
+```
+
+You can also ask Claude for the agent ID if you want to reference it explicitly, or find IDs in the transcript files at `~/.claude/projects/{project}/{sessionId}/subagents/`. Each transcript is stored as `agent-{agentId}.jsonl`.
+
+For programmatic usage, see [Subagents in the Agent SDK](/en/agent-sdk/subagents).
+
+Subagent transcripts persist independently of the main conversation:
+
+* **Main conversation compaction**: When the main conversation compacts, subagent transcripts are unaffected. They&#39;re stored in separate files.
+* **Session persistence**: Subagent transcripts persist within their session. You can [resume a subagent](#resume-subagents) after restarting Claude Code by resuming the same session.
+* **Automatic cleanup**: Transcripts are cleaned up based on the `cleanupPeriodDays` setting (default: 30 days).
+
+#### Auto-compaction
+
+Subagents support automatic compaction using the same logic as the main conversation. When a subagent&#39;s context approaches its limit, Claude Code summarizes older messages to free up space while preserving important context.
+
+Compaction events are logged in subagent transcript files:
+
+```json  theme={null}
+{
+  &#34;type&#34;: &#34;system&#34;,
+  &#34;subtype&#34;: &#34;compact_boundary&#34;,
+  &#34;compactMetadata&#34;: {
+    &#34;trigger&#34;: &#34;auto&#34;,
+    &#34;preTokens&#34;: 167189
+  }
+}
+```
+
+The `preTokens` value shows how many tokens were used before compaction occurred.
+
+## Example subagents
+
+These examples demonstrate effective patterns for building subagents. Use them as starting points, or generate a customized version with Claude.
 
 &lt;Tip&gt;
-  To encourage more proactive subagent use, include phrases like &#34;use PROACTIVELY&#34; or &#34;MUST BE USED&#34; in your `description` field.
+  **Best practices:**
+
+  * **Design focused subagents:** each subagent should excel at one specific task
+  * **Write detailed descriptions:** Claude uses the description to decide when to delegate
+  * **Limit tool access:** grant only necessary permissions for security and focus
+  * **Check into version control:** share project subagents with your team
 &lt;/Tip&gt;
 
-### Explicit invocation
-
-Request a specific subagent by mentioning it in your command:
-
-```
-&gt; Use the test-runner subagent to fix failing tests
-&gt; Have the code-reviewer subagent look at my recent changes
-&gt; Ask the debugger subagent to investigate this error
-```
-
-## Built-in subagents
-
-Claude Code includes built-in subagents that are available out of the box:
-
-### General-purpose subagent
-
-The general-purpose subagent is a capable agent for complex, multi-step tasks that require both exploration and action. Unlike the Explore subagent, it can modify files and execute a wider range of operations.
-
-**Key characteristics:**
-
-* **Model**: Uses Sonnet for more capable reasoning
-* **Tools**: Has access to all tools
-* **Mode**: Can read and write files, execute commands, make changes
-* **Purpose**: Complex research tasks, multi-step operations, code modifications
-
-**When Claude uses it:**
-
-Claude delegates to the general-purpose subagent when:
-
-* The task requires both exploration and modification
-* Complex reasoning is needed to interpret search results
-* Multiple strategies may be needed if initial searches fail
-* The task has multiple steps that depend on each other
-
-**Example scenario:**
-
-```
-User: Find all the places where we handle authentication and update them to use the new token format
-
-Claude: [Invokes general-purpose subagent]
-[Agent searches for auth-related code across codebase]
-[Agent reads and analyzes multiple files]
-[Agent makes necessary edits]
-[Returns detailed writeup of changes made]
-```
-
-### Plan subagent
-
-The Plan subagent is a specialized built-in agent designed for use during plan mode. When Claude is operating in plan mode (non-execution mode), it uses the Plan subagent to conduct research and gather information about your codebase before presenting a plan.
-
-**Key characteristics:**
-
-* **Model**: Uses Sonnet for more capable analysis
-* **Tools**: Has access to Read, Glob, Grep, and Bash tools for codebase exploration
-* **Purpose**: Searches files, analyzes code structure, and gathers context
-* **Automatic invocation**: Claude automatically uses this agent when in plan mode and needs to research the codebase
-
-**How it works:**
-When you&#39;re in plan mode and Claude needs to understand your codebase to create a plan, it delegates research tasks to the Plan subagent. This prevents infinite nesting of agents (subagents cannot spawn other subagents) while still allowing Claude to gather the necessary context.
-
-**Example scenario:**
-
-```
-User: [In plan mode] Help me refactor the authentication module
-
-Claude: Let me research your authentication implementation first...
-[Internally invokes Plan subagent to explore auth-related files]
-[Plan subagent searches codebase and returns findings]
-Claude: Based on my research, here&#39;s my proposed plan...
-```
-
-&lt;Tip&gt;
-  The Plan subagent is only used in plan mode. In normal execution mode, Claude uses the general-purpose agent or other custom subagents you&#39;ve created.
-&lt;/Tip&gt;
-
-### Explore subagent
-
-The Explore subagent is a fast, lightweight agent optimized for searching and analyzing codebases. It operates in strict read-only mode and is designed for rapid file discovery and code exploration.
-
-**Key characteristics:**
-
-* **Model**: Uses Haiku for fast, low-latency searches
-* **Mode**: Strictly read-only - cannot create, modify, or delete files
-* **Tools available**:
-  * Glob - File pattern matching
-  * Grep - Content searching with regular expressions
-  * Read - Reading file contents
-  * Bash - Read-only commands only (ls, git status, git log, git diff, find, cat, head, tail)
-
-**When Claude uses it:**
-
-Claude will delegate to the Explore subagent when it needs to search or understand a codebase but doesn&#39;t need to make changes. This is more efficient than the main agent running multiple search commands directly, as content found during the exploration process doesn&#39;t bloat the main conversation.
-
-**Thoroughness levels:**
-
-When invoking the Explore subagent, Claude specifies a thoroughness level:
-
-* **Quick** - Fast searches with minimal exploration. Good for targeted lookups.
-* **Medium** - Moderate exploration. Balances speed and thoroughness.
-* **Very thorough** - Comprehensive analysis across multiple locations and naming conventions. Used when the target might be in unexpected places.
-
-**Example scenarios:**
-
-```
-User: Where are errors from the client handled?
-
-Claude: [Invokes Explore subagent with &#34;medium&#34; thoroughness]
-[Explore uses Grep to search for error handling patterns]
-[Explore uses Read to examine promising files]
-[Returns findings with absolute file paths]
-Claude: Client errors are handled in src/services/process.ts:712...
-```
-
-```
-User: What&#39;s the codebase structure?
-
-Claude: [Invokes Explore subagent with &#34;quick&#34; thoroughness]
-[Explore uses Glob and ls to map directory structure]
-[Returns overview of key directories and their purposes]
-```
-
-## Example subagents
-
 ### Code reviewer
+
+A read-only subagent that reviews code without modifying it. This example shows how to design a focused subagent with limited tool access (no Edit or Write) and a detailed prompt that specifies exactly what to look for and how to format output.
 
 ```markdown  theme={null}
 ---
@@ -445,6 +538,8 @@
 
 ### Debugger
 
+A subagent that can both analyze and fix issues. Unlike the code reviewer, this one includes Edit because fixing bugs requires modifying code. The prompt provides a clear workflow from diagnosis to verification.
+
 ```markdown  theme={null}
 ---
 name: debugger
@@ -480,6 +575,8 @@
 
 ### Data scientist
 
+A domain-specific subagent for data analysis work. This example shows how to create subagents for specialized workflows outside of typical coding tasks. It explicitly sets `model: sonnet` for more capable analysis.
+
 ```markdown  theme={null}
 ---
 name: data-scientist
@@ -513,102 +610,13 @@
 Always ensure queries are efficient and cost-effective.
 ```
 
-## Best practices
-
-* **Start with Claude-generated agents**: We highly recommend generating your initial subagent with Claude and then iterating on it to make it personally yours. This approach gives you the best results - a solid foundation that you can customize to your specific needs.
-
-* **Design focused subagents**: Create subagents with single, clear responsibilities rather than trying to make one subagent do everything. This improves performance and makes subagents more predictable.
-
-* **Write detailed prompts**: Include specific instructions, examples, and constraints in your system prompts. The more guidance you provide, the better the subagent will perform.
-
-* **Limit tool access**: Only grant tools that are necessary for the subagent&#39;s purpose. This improves security and helps the subagent focus on relevant actions.
-
-* **Version control**: Check project subagents into version control so your team can benefit from and improve them collaboratively.
-
-## Advanced usage
-
-### Chaining subagents
-
-For complex workflows, you can chain multiple subagents:
-
-```
-&gt; First use the code-analyzer subagent to find performance issues, then use the optimizer subagent to fix them
-```
-
-### Dynamic subagent selection
-
-Claude Code intelligently selects subagents based on context. Make your `description` fields specific and action-oriented for best results.
-
-### Resumable subagents
-
-Subagents can be resumed to continue previous conversations, which is particularly useful for long-running research or analysis tasks that need to be continued across multiple invocations.
-
-**How it works:**
-
-* Each subagent execution is assigned a unique `agentId`
-* The agent&#39;s conversation is stored in a separate transcript file: `agent-{agentId}.jsonl`
-* You can resume a previous agent by providing its `agentId` via the `resume` parameter
-* When resumed, the agent continues with full context from its previous conversation
-
-**Example workflow:**
-
-Initial invocation:
-
-```
-&gt; Use the code-analyzer agent to start reviewing the authentication module
-
-[Agent completes initial analysis and returns agentId: &#34;abc123&#34;]
-```
-
-Resume the agent:
-
-```
-&gt; Resume agent abc123 and now analyze the authorization logic as well
-
-[Agent continues with full context from previous conversation]
-```
-
-**Use cases:**
-
-* **Long-running research**: Break down large codebase analysis into multiple sessions
-* **Iterative refinement**: Continue refining a subagent&#39;s work without losing context
-* **Multi-step workflows**: Have a subagent work on related tasks sequentially while maintaining context
-
-**Technical details:**
-
-* Agent transcripts are stored in your project directory
-* Recording is disabled during resume to avoid duplicating messages
-* Both synchronous and asynchronous agents can be resumed
-* The `resume` parameter accepts the agent ID from a previous execution
-
-**Programmatic usage:**
-
-If you&#39;re using the Agent SDK or interacting with the AgentTool directly, you can pass the `resume` parameter:
-
-```typescript  theme={null}
-{
-  &#34;description&#34;: &#34;Continue analysis&#34;,
-  &#34;prompt&#34;: &#34;Now examine the error handling patterns&#34;,
-  &#34;subagent_type&#34;: &#34;code-analyzer&#34;,
-  &#34;resume&#34;: &#34;abc123&#34;  // Agent ID from previous execution
-}
-```
-
-&lt;Tip&gt;
-  Keep track of agent IDs for tasks you may want to resume later. Claude Code displays the agent ID when a subagent completes its work.
-&lt;/Tip&gt;
-
-## Performance considerations
-
-* **Context efficiency**: Agents help preserve main context, enabling longer overall sessions
-* **Latency**: Subagents start off with a clean slate each time they are invoked and may add latency as they gather context that they require to do their job effectively.
-
-## Related documentation
-
-* [Plugins](/en/plugins) - Extend Claude Code with custom agents through plugins
-* [Slash commands](/en/slash-commands) - Learn about other built-in commands
-* [Settings](/en/settings) - Configure Claude Code behavior
-* [Hooks](/en/hooks) - Automate workflows with event handlers
+## Next steps
+
+Now that you understand subagents, explore these related features:
+
+* [Distribute subagents with plugins](/en/plugins) to share subagents across teams or projects
+* [Run Claude Code programmatically](/en/headless) with the Agent SDK for CI/CD and automation
+* [Use MCP servers](/en/mcp) to give subagents access to external tools and data
 
 
 ---
</code></pre>
    </div>
</body>
</html>