<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>build-with-claude/structured-outputs - Diff Report</title>
    <link rel="stylesheet" href="../../css/diff.css">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --card-bg: #16213e;
            --text-color: #eee;
            --accent: #0f3460;
            --add-bg: #1a4d1a;
            --del-bg: #4d1a1a;
            --add-text: #4ade80;
            --del-text: #f87171;
        }
        @media (prefers-color-scheme: light) {
            :root {
                --bg-color: #f5f5f5;
                --card-bg: #fff;
                --text-color: #333;
                --accent: #e0e0e0;
                --add-bg: #d4edda;
                --del-bg: #f8d7da;
                --add-text: #155724;
                --del-text: #721c24;
            }
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 2rem;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        header { margin-bottom: 2rem; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .meta { color: #888; font-size: 0.9rem; }
        .summary {
            background: var(--card-bg);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            display: flex;
            gap: 2rem;
        }
        .stat { display: flex; align-items: center; gap: 0.5rem; }
        .stat.added { color: var(--add-text); }
        .stat.removed { color: var(--del-text); }
        .analysis {
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            border-left: 4px solid #8b5cf6;
        }
        .analysis-header {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #8b5cf6;
        }
        .analysis-content {
            white-space: pre-wrap;
            font-size: 0.95rem;
            line-height: 1.7;
        }
        .diff-container {
            background: var(--card-bg);
            border-radius: 8px;
            overflow: hidden;
        }
        .diff-header {
            background: var(--accent);
            padding: 0.75rem 1rem;
            font-weight: 600;
        }
        .diff-content {
            padding: 1rem;
            overflow-x: auto;
        }
        .diff-content ins {
            background: var(--add-bg);
            color: var(--add-text);
            text-decoration: none;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        .diff-content del {
            background: var(--del-bg);
            color: var(--del-text);
            text-decoration: line-through;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        pre {
            background: var(--accent);
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.85rem;
            margin-top: 2rem;
        }
        a { color: #60a5fa; }
        .back-link { margin-bottom: 1rem; display: inline-block; }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">&larr; Back to daily report</a>

        <header>
            <h1>build-with-claude/structured-outputs.md</h1>
            <p class="meta">Changed on 2026-01-06 14:35:17 UTC</p>
        </header>

        <div class="summary">
            <div class="stat added">
                <span>+485</span> lines added
            </div>
            <div class="stat removed">
                <span>-0</span> lines removed
            </div>
        </div>

        
        <div class="analysis">
            <div class="analysis-header">ðŸ¤– AI Analysis</div>
            <div class="analysis-content"># Documentation Change Analysis

## Summary
The documentation for structured outputs in the Claude API has been significantly expanded, introducing new features for generating validated JSON responses and ensuring strict tool usage. This enhancement aims to improve the reliability and usability of API interactions for developers.

## Key Changes
- **Introduction of Structured Outputs**: New features allow for validated JSON results from agent workflows, ensuring compliance with specified schemas.
- **JSON Outputs**: Developers can now request responses in a specific JSON format, enhancing data extraction and API response formatting.
- **Strict Tool Use**: A new parameter (`strict: true`) guarantees that tool parameters conform to defined schemas, reducing runtime errors.
- **SDK Enhancements**: Python and TypeScript SDKs now include helpers for schema transformation and validation, streamlining integration.
- **Common Use Cases**: Added examples demonstrate practical applications of structured outputs and strict tool use, aiding developers in implementation.

## Impact
**High**: The introduction of structured outputs and strict tool use represents a significant enhancement to the API&#39;s functionality, improving data integrity and reducing error handling overhead for developers.</div>
        </div>
        

        <div class="diff-container">
            <div class="diff-header">Visual Diff</div>
            <div class="diff-content"><ins style="background:#e6ffe6;"># Structured outputs&para;<br>&para;<br>Get validated JSON results from agent workflows&para;<br>&para;<br>---&para;<br>&para;<br>Structured outputs constrain Claude's responses to follow a specific schema, ensuring valid, parseable output for downstream processing. Two complementary features are available:&para;<br>&para;<br>- **JSON outputs** (`output_format`): Get Claude's response in a specific JSON format&para;<br>- **Strict tool use** (`strict: true`): Guarantee schema validation on tool names and inputs&para;<br>&para;<br>These features can be used independently or together in the same request.&para;<br>&para;<br>&lt;Note&gt;&para;<br>Structured outputs are currently available as a public beta feature in the Claude API for Claude Sonnet 4.5, Claude Opus 4.1, Claude Opus 4.5, and Claude Haiku 4.5.&para;<br>&para;<br>To use the feature, set the [beta header](/docs/en/api/beta-headers) `structured-outputs-2025-11-13`.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>&lt;Tip&gt;&para;<br>Share feedback using this [form](https://forms.gle/BFnYc6iCkWoRzFgk7).&para;<br>&lt;/Tip&gt;&para;<br>&para;<br>## Why use structured outputs&para;<br>&para;<br>Without structured outputs, Claude can generate malformed JSON responses or invalid tool inputs that break your applications. Even with careful prompting, you may encounter:&para;<br>- Parsing errors from invalid JSON syntax&para;<br>- Missing required fields&para;<br>- Inconsistent data types&para;<br>- Schema violations requiring error handling and retries&para;<br>&para;<br>Structured outputs guarantee schema-compliant responses through constrained decoding:&para;<br>- **Always valid**: No more `JSON.parse()` errors&para;<br>- **Type safe**: Guaranteed field types and required fields&para;<br>- **Reliable**: No retries needed for schema violations&para;<br>&para;<br>## JSON outputs&para;<br>&para;<br>JSON outputs control Claude's response format, ensuring Claude returns valid JSON matching your schema. Use JSON outputs when you need to:&para;<br>&para;<br>- Control Claude's response format&para;<br>- Extract data from images or text&para;<br>- Generate structured reports&para;<br>- Format API responses&para;<br>&para;<br>### Quick start&para;<br>&para;<br>&lt;CodeGroup&gt;&para;<br>&para;<br>```bash Shell&para;<br>curl https://api.anthropic.com/v1/messages \&para;<br>  -H "content-type: application/json" \&para;<br>  -H "x-api-key: $ANTHROPIC_API_KEY" \&para;<br>  -H "anthropic-version: 2023-06-01" \&para;<br>  -H "anthropic-beta: structured-outputs-2025-11-13" \&para;<br>  -d '{&para;<br>    "model": "claude-sonnet-4-5",&para;<br>    "max_tokens": 1024,&para;<br>    "messages": [&para;<br>      {&para;<br>        "role": "user",&para;<br>        "content": "Extract the key information from this email: John Smith (john@example.com) is interested in our Enterprise plan and wants to schedule a demo for next Tuesday at 2pm."&para;<br>      }&para;<br>    ],&para;<br>    "output_format": {&para;<br>      "type": "json_schema",&para;<br>      "schema": {&para;<br>        "type": "object",&para;<br>        "properties": {&para;<br>          "name": {"type": "string"},&para;<br>          "email": {"type": "string"},&para;<br>          "plan_interest": {"type": "string"},&para;<br>          "demo_requested": {"type": "boolean"}&para;<br>        },&para;<br>        "required": ["name", "email", "plan_interest", "demo_requested"],&para;<br>        "additionalProperties": false&para;<br>      }&para;<br>    }&para;<br>  }'&para;<br>```&para;<br>&para;<br>```python Python&para;<br>import anthropic&para;<br>&para;<br>client = anthropic.Anthropic()&para;<br>&para;<br>response = client.beta.messages.create(&para;<br>    model="claude-sonnet-4-5",&para;<br>    max_tokens=1024,&para;<br>    betas=["structured-outputs-2025-11-13"],&para;<br>    messages=[&para;<br>        {&para;<br>            "role": "user",&para;<br>            "content": "Extract the key information from this email: John Smith (john@example.com) is interested in our Enterprise plan and wants to schedule a demo for next Tuesday at 2pm."&para;<br>        }&para;<br>    ],&para;<br>    output_format={&para;<br>        "type": "json_schema",&para;<br>        "schema": {&para;<br>            "type": "object",&para;<br>            "properties": {&para;<br>                "name": {"type": "string"},&para;<br>                "email": {"type": "string"},&para;<br>                "plan_interest": {"type": "string"},&para;<br>                "demo_requested": {"type": "boolean"}&para;<br>            },&para;<br>            "required": ["name", "email", "plan_interest", "demo_requested"],&para;<br>            "additionalProperties": False&para;<br>        }&para;<br>    }&para;<br>)&para;<br>print(response.content[0].text)&para;<br>```&para;<br>&para;<br>```typescript TypeScript&para;<br>import Anthropic from '@anthropic-ai/sdk';&para;<br>&para;<br>const client = new Anthropic({&para;<br>  apiKey: process.env.ANTHROPIC_API_KEY&para;<br>});&para;<br>&para;<br>const response = await client.beta.messages.create({&para;<br>  model: "claude-sonnet-4-5",&para;<br>  max_tokens: 1024,&para;<br>  betas: ["structured-outputs-2025-11-13"],&para;<br>  messages: [&para;<br>    {&para;<br>      role: "user",&para;<br>      content: "Extract the key information from this email: John Smith (john@example.com) is interested in our Enterprise plan and wants to schedule a demo for next Tuesday at 2pm."&para;<br>    }&para;<br>  ],&para;<br>  output_format: {&para;<br>    type: "json_schema",&para;<br>    schema: {&para;<br>      type: "object",&para;<br>      properties: {&para;<br>        name: { type: "string" },&para;<br>        email: { type: "string" },&para;<br>        plan_interest: { type: "string" },&para;<br>        demo_requested: { type: "boolean" }&para;<br>      },&para;<br>      required: ["name", "email", "plan_interest", "demo_requested"],&para;<br>      additionalProperties: false&para;<br>    }&para;<br>  }&para;<br>});&para;<br>console.log(response.content[0].text);&para;<br>```&para;<br>&para;<br>&lt;/CodeGroup&gt;&para;<br>&para;<br>**Response format:** Valid JSON matching your schema in `response.content[0].text`&para;<br>&para;<br>```json&para;<br>{&para;<br>  "name": "John Smith",&para;<br>  "email": "john@example.com",&para;<br>  "plan_interest": "Enterprise",&para;<br>  "demo_requested": true&para;<br>}&para;<br>```&para;<br>&para;<br>### How it works&para;<br>&para;<br>&lt;Steps&gt;&para;<br>  &lt;Step title="Define your JSON schema"&gt;&para;<br>    Create a JSON schema that describes the structure you want Claude to follow. The schema uses standard JSON Schema format with some limitations (see [JSON Schema limitations](#json-schema-limitations)).&para;<br>  &lt;/Step&gt;&para;<br>  &lt;Step title="Add the output_format parameter"&gt;&para;<br>    Include the `output_format` parameter in your API request with `type: "json_schema"` and your schema definition.&para;<br>  &lt;/Step&gt;&para;<br>  &lt;Step title="Include the beta header"&gt;&para;<br>    Add the `anthropic-beta: structured-outputs-2025-11-13` header to your request.&para;<br>  &lt;/Step&gt;&para;<br>  &lt;Step title="Parse the response"&gt;&para;<br>    Claude's response will be valid JSON matching your schema, returned in `response.content[0].text`.&para;<br>  &lt;/Step&gt;&para;<br>&lt;/Steps&gt;&para;<br>&para;<br>### Working with JSON outputs in SDKs&para;<br>&para;<br>The Python and TypeScript SDKs provide helpers that make it easier to work with JSON outputs, including schema transformation, automatic validation, and integration with popular schema libraries.&para;<br>&para;<br>#### Using Pydantic and Zod&para;<br>&para;<br>For Python and TypeScript developers, you can use familiar schema definition tools like Pydantic and Zod instead of writing raw JSON schemas.&para;<br>&para;<br>&lt;CodeGroup&gt;&para;<br>&para;<br>```python Python&para;<br>from pydantic import BaseModel&para;<br>from anthropic import Anthropic, transform_schema&para;<br>&para;<br>class ContactInfo(BaseModel):&para;<br>    name: str&para;<br>    email: str&para;<br>    plan_interest: str&para;<br>    demo_requested: bool&para;<br>&para;<br>client = Anthropic()&para;<br>&para;<br># With .create() - requires transform_schema()&para;<br>response = client.beta.messages.create(&para;<br>    model="claude-sonnet-4-5",&para;<br>    max_tokens=1024,&para;<br>    betas=["structured-outputs-2025-11-13"],&para;<br>    messages=[&para;<br>        {&para;<br>            "role": "user",&para;<br>            "content": "Extract the key information from this email: John Smith (john@example.com) is interested in our Enterprise plan and wants to schedule a demo for next Tuesday at 2pm."&para;<br>        }&para;<br>    ],&para;<br>    output_format={&para;<br>        "type": "json_schema",&para;<br>        "schema": transform_schema(ContactInfo),&para;<br>    }&para;<br>)&para;<br>&para;<br>print(response.content[0].text)&para;<br>&para;<br># With .parse() - can pass Pydantic model directly&para;<br>response = client.beta.messages.parse(&para;<br>    model="claude-sonnet-4-5",&para;<br>    max_tokens=1024,&para;<br>    betas=["structured-outputs-2025-11-13"],&para;<br>    messages=[&para;<br>        {&para;<br>            "role": "user",&para;<br>            "content": "Extract the key information from this email: John Smith (john@example.com) is interested in our Enterprise plan and wants to schedule a demo for next Tuesday at 2pm."&para;<br>        }&para;<br>    ],&para;<br>    output_format=ContactInfo,&para;<br>)&para;<br>&para;<br>print(response.parsed_output)&para;<br>```&para;<br>&para;<br>```typescript TypeScript&para;<br>import Anthropic from '@anthropic-ai/sdk';&para;<br>import { z } from 'zod';&para;<br>import { betaZodOutputFormat } from '@anthropic-ai/sdk/helpers/beta/zod';&para;<br>&para;<br>const ContactInfoSchema = z.object({&para;<br>  name: z.string(),&para;<br>  email: z.string(),&para;<br>  plan_interest: z.string(),&para;<br>  demo_requested: z.boolean(),&para;<br>});&para;<br>&para;<br>const client = new Anthropic();&para;<br>&para;<br>const response = await client.beta.messages.parse({&para;<br>  model: "claude-sonnet-4-5",&para;<br>  max_tokens: 1024,&para;<br>  betas: ["structured-outputs-2025-11-13"],&para;<br>  messages: [&para;<br>    {&para;<br>      role: "user",&para;<br>      content: "Extract the key information from this email: John Smith (john@example.com) is interested in our Enterprise plan and wants to schedule a demo for next Tuesday at 2pm."&para;<br>    }&para;<br>  ],&para;<br>  output_format: betaZodOutputFormat(ContactInfoSchema),&para;<br>});&para;<br>&para;<br>// Automatically parsed and validated&para;<br>console.log(response.parsed_output);&para;<br>```&para;<br>&para;<br>&lt;/CodeGroup&gt;&para;<br>&para;<br>#### SDK-specific methods&para;<br>&para;<br>**Python: `client.beta.messages.parse()` (Recommended)**&para;<br>&para;<br>The `parse()` method automatically transforms your Pydantic model, validates the response, and returns a `parsed_output` attribute.&para;<br>&para;<br>&lt;Note&gt;&para;<br>The `parse()` method is available on `client.beta.messages`, not `client.messages`.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>&lt;section title="Example usage"&gt;&para;<br>&para;<br>```python&para;<br>from pydantic import BaseModel&para;<br>import anthropic&para;<br>&para;<br>class ContactInfo(BaseModel):&para;<br>    name: str&para;<br>    email: str&para;<br>    plan_interest: str&para;<br>&para;<br>client = anthropic.Anthropic()&para;<br>&para;<br>response = client.beta.messages.parse(&para;<br>    model="claude-sonnet-4-5",&para;<br>    betas=["structured-outputs-2025-11-13"],&para;<br>    max_tokens=1024,&para;<br>    messages=[{"role": "user", "content": "..."}],&para;<br>    output_format=ContactInfo,&para;<br>)&para;<br>&para;<br># Access the parsed output directly&para;<br>contact = response.parsed_output&para;<br>print(contact.name, contact.email)&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>**Python: `transform_schema()` helper**&para;<br>&para;<br>For when you need to manually transform schemas before sending, or when you want to modify a Pydantic-generated schema. Unlike `client.beta.messages.parse()`, which transforms provided schemas automatically, this gives you the transformed schema so you can further customize it.&para;<br>&para;<br>&lt;section title="Example usage"&gt;&para;<br>&para;<br>```python&para;<br>from anthropic import transform_schema&para;<br>from pydantic import TypeAdapter&para;<br>&para;<br># First convert Pydantic model to JSON schema, then transform&para;<br>schema = TypeAdapter(ContactInfo).json_schema()&para;<br>schema = transform_schema(schema)&para;<br># Modify schema if needed&para;<br>schema["properties"]["custom_field"] = {"type": "string"}&para;<br>&para;<br>response = client.beta.messages.create(&para;<br>    model="claude-sonnet-4-5",&para;<br>    betas=["structured-outputs-2025-11-13"],&para;<br>    max_tokens=1024,&para;<br>    output_format=schema,&para;<br>    messages=[{"role": "user", "content": "..."}],&para;<br>)&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>#### How SDK transformation works&para;<br>&para;<br>Both Python and TypeScript SDKs automatically transform schemas with unsupported features:&para;<br>&para;<br>1. **Remove unsupported constraints** (e.g., `minimum`, `maximum`, `minLength`, `maxLength`)&para;<br>2. **Update descriptions** with constraint info (e.g., "Must be at least 100"), when the constraint is not directly supported with structured outputs&para;<br>3. **Add `additionalProperties: false`** to all objects&para;<br>4. **Filter string formats** to supported list only&para;<br>5. **Validate responses** against your original schema (with all constraints)&para;<br>&para;<br>This means Claude receives a simplified schema, but your code still enforces all constraints through validation.&para;<br>&para;<br>**Example:** A Pydantic field with `minimum: 100` becomes a plain integer in the sent schema, but the description is updated to "Must be at least 100", and the SDK validates the response against the original constraint.&para;<br>&para;<br>### Common use cases&para;<br>&para;<br>&lt;section title="Data extraction"&gt;&para;<br>&para;<br>Extract structured data from unstructured text:&para;<br>&para;<br>&lt;CodeGroup&gt;&para;<br>&para;<br>```python Python&para;<br>from pydantic import BaseModel&para;<br>from typing import List&para;<br>&para;<br>class Invoice(BaseModel):&para;<br>    invoice_number: str&para;<br>    date: str&para;<br>    total_amount: float&para;<br>    line_items: List[dict]&para;<br>    customer_name: str&para;<br>&para;<br>response = client.beta.messages.parse(&para;<br>    model="claude-sonnet-4-5",&para;<br>    betas=["structured-outputs-2025-11-13"],&para;<br>    output_format=Invoice,&para;<br>    messages=[{"role": "user", "content": f"Extract invoice data from: {invoice_text}"}]&para;<br>)&para;<br>```&para;<br>&para;<br>```typescript TypeScript&para;<br>import { z } from 'zod';&para;<br>&para;<br>const InvoiceSchema = z.object({&para;<br>  invoice_number: z.string(),&para;<br>  date: z.string(),&para;<br>  total_amount: z.number(),&para;<br>  line_items: z.array(z.record(z.any())),&para;<br>  customer_name: z.string(),&para;<br>});&para;<br>&para;<br>const response = await client.beta.messages.parse({&para;<br>  model: "claude-sonnet-4-5",&para;<br>  betas: ["structured-outputs-2025-11-13"],&para;<br>  output_format: InvoiceSchema,&para;<br>  messages: [{"role": "user", "content": `Extract invoice data from: ${invoiceText}`}]&para;<br>});&para;<br>```&para;<br>&para;<br>&lt;/CodeGroup&gt;&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Classification"&gt;&para;<br>&para;<br>Classify content with structured categories:&para;<br>&para;<br>&lt;CodeGroup&gt;&para;<br>&para;<br>```python Python&para;<br>from pydantic import BaseModel&para;<br>from typing import List&para;<br>&para;<br>class Classification(BaseModel):&para;<br>    category: str&para;<br>    confidence: float&para;<br>    tags: List[str]&para;<br>    sentiment: str&para;<br>&para;<br>response = client.beta.messages.parse(&para;<br>    model="claude-sonnet-4-5",&para;<br>    betas=["structured-outputs-2025-11-13"],&para;<br>    output_format=Classification,&para;<br>    messages=[{"role": "user", "content": f"Classify this feedback: {feedback_text}"}]&para;<br>)&para;<br>```&para;<br>&para;<br>```typescript TypeScript&para;<br>import { z } from 'zod';&para;<br>&para;<br>const ClassificationSchema = z.object({&para;<br>  category: z.string(),&para;<br>  confidence: z.number(),&para;<br>  tags: z.array(z.string()),&para;<br>  sentiment: z.string(),&para;<br>});&para;<br>&para;<br>const response = await client.beta.messages.parse({&para;<br>  model: "claude-sonnet-4-5",&para;<br>  betas: ["structured-outputs-2025-11-13"],&para;<br>  output_format: ClassificationSchema,&para;<br>  messages: [{"role": "user", "content": `Classify this feedback: ${feedbackText}`}]&para;<br>});&para;<br>```&para;<br>&para;<br>&lt;/CodeGroup&gt;&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="API response formatting"&gt;&para;<br>&para;<br>Generate API-ready responses:&para;<br>&para;<br>&lt;CodeGroup&gt;&para;<br>&para;<br>```python Python&para;<br>from pydantic import BaseModel&para;<br>from typing import List, Optional&para;<br>&para;<br>class APIResponse(BaseModel):&para;<br>    status: str&para;<br>    data: dict&para;<br>    errors: Optional[List[dict]]&para;<br>    metadata: dict&para;<br>&para;<br>response = client.beta.messages.parse(&para;<br>    model="claude-sonnet-4-5",&para;<br>    betas=["structured-outputs-2025-11-13"],&para;<br>    output_format=APIResponse,&para;<br>    messages=[{"role": "user", "content": "Process this request: ..."}]&para;<br>)&para;<br>```&para;<br>&para;<br>```typescript TypeScript&para;<br>import { z } from 'zod';&para;<br>&para;<br>const APIResponseSchema = z.object({&para;<br>  status: z.string(),&para;<br>  data: z.record(z.any()),&para;<br>  errors: z.array(z.record(z.any())).optional(),&para;<br>  metadata: z.record(z.any()),&para;<br>});&para;<br>&para;<br>const response = await client.beta.messages.parse({&para;<br>  model: "claude-sonnet-4-5",&para;<br>  betas: ["structured-outputs-2025-11-13"],&para;<br>  output_format: APIResponseSchema,&para;<br>  messages: [{"role": "user", "content": "Process this request: ..."}]&para;<br>});&para;<br>```&para;<br>&para;<br>&lt;/CodeGroup&gt;&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>## Strict tool use&para;<br>&para;<br>Strict tool use validates tool parameters, ensuring Claude calls your functions with correctly-typed arguments. Use strict tool use when you need to:&para;<br>&para;<br>- Validate tool parameters&para;<br>- Build agentic workflows&para;<br>- Ensure type-safe function calls&para;<br>- Handle complex tools with nested properties&para;<br>&para;<br>### Why strict tool use matters for agents&para;<br>&para;<br>Building reliable agentic systems requires guaranteed schema conformance. Without strict mode, Claude might return incompatible types (`"2"` instead of `2`) or missing required fields, breaking your functions and causing runtime errors.&para;<br>&para;<br>Strict tool use guarantees type-safe parameters:&para;<br>- Functions receive correctly-typed arguments every time&para;<br>- No need to validate and retry tool calls&para;<br>- Production-ready agents that work consistently at scale&para;<br>&para;<br>For example, suppose a booking system needs `passengers: int`. Without strict mode, Claude might provide `passengers: "two"` or `passengers: "2"`. With `strict: true`, the response will always contain `passengers: 2`.&para;<br>&para;<br>### Quick start&para;<br>&para;<br>&lt;CodeGroup&gt;&para;<br>&para;<br>```bash Shell&para;<br>curl https://api.anthropic.com/v1/messages \&para;<br>  -H "content-type: application/json" \&para;<br>  -H "x-api-key: $ANTHROPIC_API_KEY" \&para;<br>  -H "anthropic-version: 2023-06-01" \&para;<br>  -H "anthropic-beta: structured-outputs-2025-11-13" \&para;<br>  -d '{&para;<br>    "model": "claude-sonnet-4-5",&para;<br>    "max_tokens": 1024,&para;<br>    "messages": [&para;<br>      {"role": "user", "content": "What is the weather in San Francisco?"}&para;<br>    ],&para;<br>    "tools": [{&para;<br>      "name": "get_weather",&para;<br>      "description": "Get the current weather in a given location",&para;<br>      "strict": true,&para;<br>      "input_schema": {&para;<br>        "type": "object",&para;<br>        "properties": {&para;<br>          "location": {&para;<br>            "type": "string",&para;<br>            "description": "The city and state, e.g. San Francisco, CA"&para;<br>          },&para;<br>          "unit": {&para;<br>            "type": "string",&para;<br>            "enum": ["celsius", "fahrenheit"]&para;<br>          }&para;<br>        },&para;<br>        "required": ["location"],&para;<br>        "additionalProperties": false&para;<br>      }&para;<br>    }]&para;<br>  }'&para;<br>```&para;<br>&para;<br>```python Python&para;<br>import anthropic&para;<br>&para;<br>client = anthropic.Anthropic()&para;<br>&para;<br>response = client.beta.messages.create(&para;<br>    model="claude-sonnet-4-5",&para;<br>    max_tokens=1024,&para;<br>    betas=["structured-outputs-2025-11-13"],&para;<br>    messages=[&para;<br>        {"role": "user", "content": "What's the weather like in San Francisco?"}&para;<br>    ],&para;<br>    tools=[&para;<br>        {&para;<br>            "name": "get_weather",&para;<br>            "description": "Get the current weather in a given location",&para;<br>            "strict": True,  # Enable strict mode&para;<br>            "input_schema": {&para;<br>                "type": "object",&para;<br>                "properties": {&para;<br>                    "location": {&para;<br>                        "type": "string",&para;<br>                        "description": "The city and state, e.g. San Francisco, CA"&para;<br>                    },&para;<br>                    "unit": {&para;<br>                        "type": "string",&para;<br>                        "enum": ["celsius", "fahrenheit"],&para;<br>                        "description": "The unit of temperature, either 'celsius' or 'fahrenheit'"&para;<br>                    }&para;<br>                },&para;<br>                "required": ["location"],&para;<br>                "additionalProperties": False&para;<br>            }&para;<br>        }&para;<br>    ]&para;<br>)&para;<br>print(response.content)&para;<br>```&para;<br>&para;<br>```typescript TypeScript&para;<br>import Anthropic from '@anthropic-ai/sdk';&para;<br>&para;<br>const client = new Anthropic({&para;<br>  apiKey: process.env.ANTHROPIC_API_KEY&para;<br>});&para;<br>&para;<br>const response = await client.beta.messages.create({&para;<br>  model: "claude-sonnet-4-5",&para;<br>  max_tokens: 1024,&para;<br>  betas: ["structured-outputs-2025-11-13"],&para;<br>  messages: [&para;<br>    {&para;<br>      role: "user",&para;<br>      content: "What's the weather like in San Francisco?"&para;<br>    }&para;<br>  ],&para;<br>  tools: [{&para;<br>    name: "get_weather",&para;<br>    description: "Get the current weather in a given location",&para;<br>    strict: true,  // Enable strict mode&para;<br>    input_schema: {&para;<br>      type: "object",&para;<br>      properties: {&para;<br>        location: {&para;<br>          type: "string",&para;<br>          description: "The city and state, e.g. San Francisco, CA"&para;<br>        },&para;<br>        unit: {&para;<br>          type: "string",&para;<br>          enum: ["celsius", "fahrenheit"]&para;<br>        }&para;<br>      },&para;<br>      required: ["location"],&para;<br>      additionalProperties: false&para;<br>    }&para;<br>  }]&para;<br>});&para;<br>console.log(response.content);&para;<br>```&para;<br>&para;<br>&lt;/CodeGroup&gt;&para;<br>&para;<br>**Response format:** Tool use blocks with validated inputs in `response.content[x].input`&para;<br>&para;<br>```json&para;<br>{&para;<br>  "type": "tool_use",&para;<br>  "name": "get_weather",&para;<br>  "input": {&para;<br>    "location": "San Francisco, CA"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>**Guarantees:**&para;<br>- Tool `input` strictly follows the `input_schema`&para;<br>- Tool `name` is always valid (from provided tools or server tools)&para;<br>&para;<br>### How it works&para;<br>&para;<br>&lt;Steps&gt;&para;<br>  &lt;Step title="Define your tool schema"&gt;&para;<br>    Create a JSON schema for your tool's `input_schema`. The schema uses standard JSON Schema format with some limitations (see [JSON Schema limitations](#json-schema-limitations)).&para;<br>  &lt;/Step&gt;&para;<br>  &lt;Step title="Add strict: true"&gt;&para;<br>    Set `"strict": true` as a top-level property in your tool definition, alongside `name`, `description`, and `input_schema`.&para;<br>  &lt;/Step&gt;&para;<br>  &lt;Step title="Include the beta header"&gt;&para;<br>    Add the `anthropic-beta: structured-outputs-2025-11-13` header to your request.&para;<br>  &lt;/Step&gt;&para;<br>  &lt;Step title="Handle tool calls"&gt;&para;<br>    When Claude uses the tool, the `input` field in the tool_use block will strictly follow your `input_schema`, and the `name` will always be valid.&para;<br>  &lt;/Step&gt;&para;<br>&lt;/Steps&gt;&para;<br>&para;<br>### Common use cases&para;<br>&para;<br>&lt;section title="Validated tool inputs"&gt;&para;<br>&para;<br>Ensure tool parameters exactly match your schema:&para;<br>&para;<br>&lt;CodeGroup&gt;&para;<br>&para;<br>```python Python&para;<br>response = client.beta.messages.create(&para;<br>    model="claude-sonnet-4-5",&para;<br>    betas=["structured-outputs-2025-11-13"],&para;<br>    messages=[{"role": "user", "content": "Search for flights to Tokyo"}],&para;<br>    tools=[{&para;<br>        "name": "search_flights",&para;<br>        "strict": True,&para;<br>        "input_schema": {&para;<br>            "type": "object",&para;<br>            "properties": {&para;<br>                "destination": {"type": "string"},&para;<br>                "departure_date": {"type": "string", "format": "date"},&para;<br>                "passengers": {"type": "integer", "enum": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}&para;<br>            },&para;<br>            "required": ["destination", "departure_date"],&para;<br>            "additionalProperties": False&para;<br>        }&para;<br>    }]&para;<br>)&para;<br>```&para;<br>&para;<br>```typescript TypeScript&para;<br>const response = await client.beta.messages.create({&para;<br>  model: "claude-sonnet-4-5",&para;<br>  betas: ["structured-outputs-2025-11-13"],&para;<br>  messages: [{"role": "user", "content": "Search for flights to Tokyo"}],&para;<br>  tools: [{&para;<br>    name: "search_flights",&para;<br>    strict: true,&para;<br>    input_schema: {&para;<br>      type: "object",&para;<br>      properties: {&para;<br>        destination: {type: "string"},&para;<br>        departure_date: {type: "string", format: "date"},&para;<br>        passengers: {type: "integer", enum: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}&para;<br>      },&para;<br>      required: ["destination", "departure_date"],&para;<br>      additionalProperties: false&para;<br>    }&para;<br>  }]&para;<br>});&para;<br>```&para;<br>&para;<br>&lt;/CodeGroup&gt;&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Agentic workflow with multiple validated tools"&gt;&para;<br>&para;<br>Build reliable multi-step agents with guaranteed tool parameters:&para;<br>&para;<br>&lt;CodeGroup&gt;&para;<br>&para;<br>```python Python&para;<br>response = client.beta.messages.create(&para;<br>    model="claude-sonnet-4-5",&para;<br>    betas=["structured-outputs-2025-11-13"],&para;<br>    messages=[{"role": "user", "content": "Help me plan a trip to Paris for 2 people"}],&para;<br>    tools=[&para;<br>        {&para;<br>            "name": "search_flights",&para;<br>            "strict": True,&para;<br>            "input_schema": {&para;<br>                "type": "object",&para;<br>                "properties": {&para;<br>                    "origin": {"type": "string"},&para;<br>                    "destination": {"type": "string"},&para;<br>                    "departure_date": {"type": "string", "format": "date"},&para;<br>                    "travelers": {"type": "integer", "enum": [1, 2, 3, 4, 5, 6]}&para;<br>                },&para;<br>                "required": ["origin", "destination", "departure_date"],&para;<br>                "additionalProperties": False&para;<br>            }&para;<br>        },&para;<br>        {&para;<br>            "name": "search_hotels",&para;<br>            "strict": True,&para;<br>            "input_schema": {&para;<br>                "type": "object",&para;<br>                "properties": {&para;<br>                    "city": {"type": "string"},&para;<br>                    "check_in": {"type": "string", "format": "date"},&para;<br>                    "guests": {"type": "integer", "enum": [1, 2, 3, 4]}&para;<br>                },&para;<br>                "required": ["city", "check_in"],&para;<br>                "additionalProperties": False&para;<br>            }&para;<br>        }&para;<br>    ]&para;<br>)&para;<br>```&para;<br>&para;<br>```typescript TypeScript&para;<br>const response = await client.beta.messages.create({&para;<br>  model: "claude-sonnet-4-5",&para;<br>  betas: ["structured-outputs-2025-11-13"],&para;<br>  messages: [{"role": "user", "content": "Help me plan a trip to Paris for 2 people"}],&para;<br>  tools: [&para;<br>    {&para;<br>      name: "search_flights",&para;<br>      strict: true,&para;<br>      input_schema: {&para;<br>        type: "object",&para;<br>        properties: {&para;<br>          origin: {type: "string"},&para;<br>          destination: {type: "string"},&para;<br>          departure_date: {type: "string", format: "date"},&para;<br>          travelers: {type: "integer", enum: [1, 2, 3, 4, 5, 6]}&para;<br>        },&para;<br>        required: ["origin", "destination", "departure_date"],&para;<br>        additionalProperties: false&para;<br>      }&para;<br>    },&para;<br>    {&para;<br>      name: "search_hotels",&para;<br>      strict: true,&para;<br>      input_schema: {&para;<br>        type: "object",&para;<br>        properties: {&para;<br>          city: {type: "string"},&para;<br>          check_in: {type: "string", format: "date"},&para;<br>          guests: {type: "integer", enum: [1, 2, 3, 4]}&para;<br>        },&para;<br>        required: ["city", "check_in"],&para;<br>        additionalProperties: false&para;<br>      }&para;<br>    }&para;<br>  ]&para;<br>});&para;<br>```&para;<br>&para;<br>&lt;/CodeGroup&gt;&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>## Using both features together&para;<br>&para;<br>JSON outputs and strict tool use solve different problems and can be used together:&para;<br>&para;<br>- **JSON outputs** control Claude's response format (what Claude says)&para;<br>- **Strict tool use** validates tool parameters (how Claude calls your functions)&para;<br>&para;<br>When combined, Claude can call tools with guaranteed-valid parameters AND return structured JSON responses. This is useful for agentic workflows where you need both reliable tool calls and structured final outputs.&para;<br>&para;<br>&lt;CodeGroup&gt;&para;<br>&para;<br>```python Python&para;<br>response = client.beta.messages.create(&para;<br>    model="claude-sonnet-4-5",&para;<br>    betas=["structured-outputs-2025-11-13"],&para;<br>    max_tokens=1024,&para;<br>    messages=[{"role": "user", "content": "Help me plan a trip to Paris for next month"}],&para;<br>    # JSON outputs: structured response format&para;<br>    output_format={&para;<br>        "type": "json_schema",&para;<br>        "schema": {&para;<br>            "type": "object",&para;<br>            "properties": {&para;<br>                "summary": {"type": "string"},&para;<br>                "next_steps": {"type": "array", "items": {"type": "string"}}&para;<br>            },&para;<br>            "required": ["summary", "next_steps"],&para;<br>            "additionalProperties": False&para;<br>        }&para;<br>    },&para;<br>    # Strict tool use: guaranteed tool parameters&para;<br>    tools=[{&para;<br>        "name": "search_flights",&para;<br>        "strict": True,&para;<br>        "input_schema": {&para;<br>            "type": "object",&para;<br>            "properties": {&para;<br>                "destination": {"type": "string"},&para;<br>                "date": {"type": "string", "format": "date"}&para;<br>            },&para;<br>            "required": ["destination", "date"],&para;<br>            "additionalProperties": False&para;<br>        }&para;<br>    }]&para;<br>)&para;<br>```&para;<br>&para;<br>```typescript TypeScript&para;<br>const response = await client.beta.messages.create({&para;<br>  model: "claude-sonnet-4-5",&para;<br>  betas: ["structured-outputs-2025-11-13"],&para;<br>  max_tokens: 1024,&para;<br>  messages: [{ role: "user", content: "Help me plan a trip to Paris for next month" }],&para;<br>  // JSON outputs: structured response format&para;<br>  output_format: {&para;<br>    type: "json_schema",&para;<br>    schema: {&para;<br>      type: "object",&para;<br>      properties: {&para;<br>        summary: { type: "string" },&para;<br>        next_steps: { type: "array", items: { type: "string" } }&para;<br>      },&para;<br>      required: ["summary", "next_steps"],&para;<br>      additionalProperties: false&para;<br>    }&para;<br>  },&para;<br>  // Strict tool use: guaranteed tool parameters&para;<br>  tools: [{&para;<br>    name: "search_flights",&para;<br>    strict: true,&para;<br>    input_schema: {&para;<br>      type: "object",&para;<br>      properties: {&para;<br>        destination: { type: "string" },&para;<br>        date: { type: "string", format: "date" }&para;<br>      },&para;<br>      required: ["destination", "date"],&para;<br>      additionalProperties: false&para;<br>    }&para;<br>  }]&para;<br>});&para;<br>```&para;<br>&para;<br>&lt;/CodeGroup&gt;&para;<br>&para;<br>## Important considerations&para;<br>&para;<br>### Grammar compilation and caching&para;<br>&para;<br>Structured outputs use constrained sampling with compiled grammar artifacts. This introduces some performance characteristics to be aware of:&para;<br>&para;<br>- **First request latency**: The first time you use a specific schema, there will be additional latency while the grammar is compiled&para;<br>- **Automatic caching**: Compiled grammars are cached for 24 hours from last use, making subsequent requests much faster&para;<br>- **Cache invalidation**: The cache is invalidated if you change:&para;<br>  - The JSON schema structure&para;<br>  - The set of tools in your request (when using both structured outputs and tool use)&para;<br>  - Changing only `name` or `description` fields does not invalidate the cache&para;<br>&para;<br>### Prompt modification and token costs&para;<br>&para;<br>When using structured outputs, Claude automatically receives an additional system prompt explaining the expected output format. This means:&para;<br>&para;<br>- Your input token count will be slightly higher&para;<br>- The injected prompt costs you tokens like any other system prompt&para;<br>- Changing the `output_format` parameter will invalidate any [prompt cache](/docs/en/build-with-claude/prompt-caching) for that conversation thread&para;<br>&para;<br>### JSON Schema limitations&para;<br>&para;<br>Structured outputs support standard JSON Schema with some limitations. Both JSON outputs and strict tool use share these limitations.&para;<br>&para;<br>&lt;section title="Supported features"&gt;&para;<br>&para;<br>- All basic types: object, array, string, integer, number, boolean, null&para;<br>- `enum` (strings, numbers, bools, or nulls only - no complex types)&para;<br>- `const`&para;<br>- `anyOf` and `allOf` (with limitations - `allOf` with `$ref` not supported)&para;<br>- `$ref`, `$def`, and `definitions` (external `$ref` not supported)&para;<br>- `default` property for all supported types&para;<br>- `required` and `additionalProperties` (must be set to `false` for objects)&para;<br>- String formats: `date-time`, `time`, `date`, `duration`, `email`, `hostname`, `uri`, `ipv4`, `ipv6`, `uuid`&para;<br>- Array `minItems` (only values 0 and 1 supported)&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Not supported"&gt;&para;<br>&para;<br>- Recursive schemas&para;<br>- Complex types within enums&para;<br>- External `$ref` (e.g., `'$ref': 'http://...'`)&para;<br>- Numerical constraints (`minimum`, `maximum`, `multipleOf`, etc.)&para;<br>- String constraints (`minLength`, `maxLength`)&para;<br>- Array constraints beyond `minItems` of 0 or 1&para;<br>- `additionalProperties` set to anything other than `false`&para;<br>&para;<br>If you use an unsupported feature, you'll receive a 400 error with details.&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Pattern support (regex)"&gt;&para;<br>&para;<br>**Supported regex features:**&para;<br>- Full matching (`^...$`) and partial matching&para;<br>- Quantifiers: `*`, `+`, `?`, simple `{n,m}` cases&para;<br>- Character classes: `[]`, `.`, `\d`, `\w`, `\s`&para;<br>- Groups: `(...)`&para;<br>&para;<br>**NOT supported:**&para;<br>- Backreferences to groups (e.g., `\1`, `\2`)&para;<br>- Lookahead/lookbehind assertions (e.g., `(?=...)`, `(?!...)`)&para;<br>- Word boundaries: `\b`, `\B`&para;<br>- Complex `{n,m}` quantifiers with large ranges&para;<br>&para;<br>Simple regex patterns work well. Complex patterns may result in 400 errors.&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;Tip&gt;&para;<br>The Python and TypeScript SDKs can automatically transform schemas with unsupported features by removing them and adding constraints to field descriptions. See [SDK-specific methods](#sdk-specific-methods) for details.&para;<br>&lt;/Tip&gt;&para;<br>&para;<br>### Invalid outputs&para;<br>&para;<br>While structured outputs guarantee schema compliance in most cases, there are scenarios where the output may not match your schema:&para;<br>&para;<br>**Refusals** (`stop_reason: "refusal"`)&para;<br>&para;<br>Claude maintains its safety and helpfulness properties even when using structured outputs. If Claude refuses a request for safety reasons:&para;<br>&para;<br>- The response will have `stop_reason: "refusal"`&para;<br>- You'll receive a 200 status code&para;<br>- You'll be billed for the tokens generated&para;<br>- The output may not match your schema because the refusal message takes precedence over schema constraints&para;<br>&para;<br>**Token limit reached** (`stop_reason: "max_tokens"`)&para;<br>&para;<br>If the response is cut off due to reaching the `max_tokens` limit:&para;<br>&para;<br>- The response will have `stop_reason: "max_tokens"`&para;<br>- The output may be incomplete and not match your schema&para;<br>- Retry with a higher `max_tokens` value to get the complete structured output&para;<br>&para;<br>### Schema validation errors&para;<br>&para;<br>If your schema uses unsupported features or is too complex, you'll receive a 400 error:&para;<br>&para;<br>**"Too many recursive definitions in schema"**&para;<br>- Cause: Schema has excessive or cyclic recursive definitions&para;<br>- Solution: Simplify schema structure, reduce nesting depth&para;<br>&para;<br>**"Schema is too complex"**&para;<br>- Cause: Schema exceeds complexity limits&para;<br>- Solution: Break into smaller schemas, simplify structure, or reduce the number of tools marked as `strict: true`&para;<br>&para;<br>For persistent issues with valid schemas, [contact support](https://support.claude.com/en/articles/9015913-how-to-get-support) with your schema definition.&para;<br>&para;<br>## Feature compatibility&para;<br>&para;<br>**Works with:**&para;<br>- **[Batch processing](/docs/en/build-with-claude/batch-processing)**: Process structured outputs at scale with 50% discount&para;<br>- **[Token counting](/docs/en/build-with-claude/token-counting)**: Count tokens without compilation&para;<br>- **[Streaming](/docs/en/build-with-claude/streaming)**: Stream structured outputs like normal responses&para;<br>- **Combined usage**: Use JSON outputs (`output_format`) and strict tool use (`strict: true`) together in the same request&para;<br>&para;<br>**Incompatible with:**&para;<br>- **[Citations](/docs/en/build-with-claude/citations)**: Citations require interleaving citation blocks with text, which conflicts with strict JSON schema constraints. Returns 400 error if citations enabled with `output_format`.&para;<br>- **[Message Prefilling](/docs/en/build-with-claude/prompt-engineering/prefill-claudes-response)**: Incompatible with JSON outputs&para;<br>&para;<br>&lt;Tip&gt;&para;<br>**Grammar scope**: Grammars apply only to Claude's direct output, not to tool use calls, tool results, or thinking tags (when using [Extended Thinking](/docs/en/build-with-claude/extended-thinking)). Grammar state resets between sections, allowing Claude to think freely while still producing structured output in the final response.&para;<br>&lt;/Tip&gt;</ins></div>
        </div>

        <h2 style="margin-top: 2rem; margin-bottom: 1rem;">Unified Diff</h2>
        <pre><code>--- a/build-with-claude/structured-outputs.md
+++ b/build-with-claude/structured-outputs.md
@@ -0,0 +1,1019 @@
+# Structured outputs
+
+Get validated JSON results from agent workflows
+
+---
+
+Structured outputs constrain Claude&#39;s responses to follow a specific schema, ensuring valid, parseable output for downstream processing. Two complementary features are available:
+
+- **JSON outputs** (`output_format`): Get Claude&#39;s response in a specific JSON format
+- **Strict tool use** (`strict: true`): Guarantee schema validation on tool names and inputs
+
+These features can be used independently or together in the same request.
+
+&lt;Note&gt;
+Structured outputs are currently available as a public beta feature in the Claude API for Claude Sonnet 4.5, Claude Opus 4.1, Claude Opus 4.5, and Claude Haiku 4.5.
+
+To use the feature, set the [beta header](/docs/en/api/beta-headers) `structured-outputs-2025-11-13`.
+&lt;/Note&gt;
+
+&lt;Tip&gt;
+Share feedback using this [form](https://forms.gle/BFnYc6iCkWoRzFgk7).
+&lt;/Tip&gt;
+
+## Why use structured outputs
+
+Without structured outputs, Claude can generate malformed JSON responses or invalid tool inputs that break your applications. Even with careful prompting, you may encounter:
+- Parsing errors from invalid JSON syntax
+- Missing required fields
+- Inconsistent data types
+- Schema violations requiring error handling and retries
+
+Structured outputs guarantee schema-compliant responses through constrained decoding:
+- **Always valid**: No more `JSON.parse()` errors
+- **Type safe**: Guaranteed field types and required fields
+- **Reliable**: No retries needed for schema violations
+
+## JSON outputs
+
+JSON outputs control Claude&#39;s response format, ensuring Claude returns valid JSON matching your schema. Use JSON outputs when you need to:
+
+- Control Claude&#39;s response format
+- Extract data from images or text
+- Generate structured reports
+- Format API responses
+
+### Quick start
+
+&lt;CodeGroup&gt;
+
+```bash Shell
+curl https://api.anthropic.com/v1/messages \
+  -H &#34;content-type: application/json&#34; \
+  -H &#34;x-api-key: $ANTHROPIC_API_KEY&#34; \
+  -H &#34;anthropic-version: 2023-06-01&#34; \
+  -H &#34;anthropic-beta: structured-outputs-2025-11-13&#34; \
+  -d &#39;{
+    &#34;model&#34;: &#34;claude-sonnet-4-5&#34;,
+    &#34;max_tokens&#34;: 1024,
+    &#34;messages&#34;: [
+      {
+        &#34;role&#34;: &#34;user&#34;,
+        &#34;content&#34;: &#34;Extract the key information from this email: John Smith (john@example.com) is interested in our Enterprise plan and wants to schedule a demo for next Tuesday at 2pm.&#34;
+      }
+    ],
+    &#34;output_format&#34;: {
+      &#34;type&#34;: &#34;json_schema&#34;,
+      &#34;schema&#34;: {
+        &#34;type&#34;: &#34;object&#34;,
+        &#34;properties&#34;: {
+          &#34;name&#34;: {&#34;type&#34;: &#34;string&#34;},
+          &#34;email&#34;: {&#34;type&#34;: &#34;string&#34;},
+          &#34;plan_interest&#34;: {&#34;type&#34;: &#34;string&#34;},
+          &#34;demo_requested&#34;: {&#34;type&#34;: &#34;boolean&#34;}
+        },
+        &#34;required&#34;: [&#34;name&#34;, &#34;email&#34;, &#34;plan_interest&#34;, &#34;demo_requested&#34;],
+        &#34;additionalProperties&#34;: false
+      }
+    }
+  }&#39;
+```
+
+```python Python
+import anthropic
+
+client = anthropic.Anthropic()
+
+response = client.beta.messages.create(
+    model=&#34;claude-sonnet-4-5&#34;,
+    max_tokens=1024,
+    betas=[&#34;structured-outputs-2025-11-13&#34;],
+    messages=[
+        {
+            &#34;role&#34;: &#34;user&#34;,
+            &#34;content&#34;: &#34;Extract the key information from this email: John Smith (john@example.com) is interested in our Enterprise plan and wants to schedule a demo for next Tuesday at 2pm.&#34;
+        }
+    ],
+    output_format={
+        &#34;type&#34;: &#34;json_schema&#34;,
+        &#34;schema&#34;: {
+            &#34;type&#34;: &#34;object&#34;,
+            &#34;properties&#34;: {
+                &#34;name&#34;: {&#34;type&#34;: &#34;string&#34;},
+                &#34;email&#34;: {&#34;type&#34;: &#34;string&#34;},
+                &#34;plan_interest&#34;: {&#34;type&#34;: &#34;string&#34;},
+                &#34;demo_requested&#34;: {&#34;type&#34;: &#34;boolean&#34;}
+            },
+            &#34;required&#34;: [&#34;name&#34;, &#34;email&#34;, &#34;plan_interest&#34;, &#34;demo_requested&#34;],
+            &#34;additionalProperties&#34;: False
+        }
+    }
+)
+print(response.content[0].text)
+```
+
+```typescript TypeScript
+import Anthropic from &#39;@anthropic-ai/sdk&#39;;
+
+const client = new Anthropic({
+  apiKey: process.env.ANTHROPIC_API_KEY
+});
+
+const response = await client.beta.messages.create({
+  model: &#34;claude-sonnet-4-5&#34;,
+  max_tokens: 1024,
+  betas: [&#34;structured-outputs-2025-11-13&#34;],
+  messages: [
+    {
+      role: &#34;user&#34;,
+      content: &#34;Extract the key information from this email: John Smith (john@example.com) is interested in our Enterprise plan and wants to schedule a demo for next Tuesday at 2pm.&#34;
+    }
+  ],
+  output_format: {
+    type: &#34;json_schema&#34;,
+    schema: {
+      type: &#34;object&#34;,
+      properties: {
+        name: { type: &#34;string&#34; },
+        email: { type: &#34;string&#34; },
+        plan_interest: { type: &#34;string&#34; },
+        demo_requested: { type: &#34;boolean&#34; }
+      },
+      required: [&#34;name&#34;, &#34;email&#34;, &#34;plan_interest&#34;, &#34;demo_requested&#34;],
+      additionalProperties: false
+    }
+  }
+});
+console.log(response.content[0].text);
+```
+
+&lt;/CodeGroup&gt;
+
+**Response format:** Valid JSON matching your schema in `response.content[0].text`
+
+```json
+{
+  &#34;name&#34;: &#34;John Smith&#34;,
+  &#34;email&#34;: &#34;john@example.com&#34;,
+  &#34;plan_interest&#34;: &#34;Enterprise&#34;,
+  &#34;demo_requested&#34;: true
+}
+```
+
+### How it works
+
+&lt;Steps&gt;
+  &lt;Step title=&#34;Define your JSON schema&#34;&gt;
+    Create a JSON schema that describes the structure you want Claude to follow. The schema uses standard JSON Schema format with some limitations (see [JSON Schema limitations](#json-schema-limitations)).
+  &lt;/Step&gt;
+  &lt;Step title=&#34;Add the output_format parameter&#34;&gt;
+    Include the `output_format` parameter in your API request with `type: &#34;json_schema&#34;` and your schema definition.
+  &lt;/Step&gt;
+  &lt;Step title=&#34;Include the beta header&#34;&gt;
+    Add the `anthropic-beta: structured-outputs-2025-11-13` header to your request.
+  &lt;/Step&gt;
+  &lt;Step title=&#34;Parse the response&#34;&gt;
+    Claude&#39;s response will be valid JSON matching your schema, returned in `response.content[0].text`.
+  &lt;/Step&gt;
+&lt;/Steps&gt;
+
+### Working with JSON outputs in SDKs
+
+The Python and TypeScript SDKs provide helpers that make it easier to work with JSON outputs, including schema transformation, automatic validation, and integration with popular schema libraries.
+
+#### Using Pydantic and Zod
+
+For Python and TypeScript developers, you can use familiar schema definition tools like Pydantic and Zod instead of writing raw JSON schemas.
+
+&lt;CodeGroup&gt;
+
+```python Python
+from pydantic import BaseModel
+from anthropic import Anthropic, transform_schema
+
+class ContactInfo(BaseModel):
+    name: str
+    email: str
+    plan_interest: str
+    demo_requested: bool
+
+client = Anthropic()
+
+# With .create() - requires transform_schema()
+response = client.beta.messages.create(
+    model=&#34;claude-sonnet-4-5&#34;,
+    max_tokens=1024,
+    betas=[&#34;structured-outputs-2025-11-13&#34;],
+    messages=[
+        {
+            &#34;role&#34;: &#34;user&#34;,
+            &#34;content&#34;: &#34;Extract the key information from this email: John Smith (john@example.com) is interested in our Enterprise plan and wants to schedule a demo for next Tuesday at 2pm.&#34;
+        }
+    ],
+    output_format={
+        &#34;type&#34;: &#34;json_schema&#34;,
+        &#34;schema&#34;: transform_schema(ContactInfo),
+    }
+)
+
+print(response.content[0].text)
+
+# With .parse() - can pass Pydantic model directly
+response = client.beta.messages.parse(
+    model=&#34;claude-sonnet-4-5&#34;,
+    max_tokens=1024,
+    betas=[&#34;structured-outputs-2025-11-13&#34;],
+    messages=[
+        {
+            &#34;role&#34;: &#34;user&#34;,
+            &#34;content&#34;: &#34;Extract the key information from this email: John Smith (john@example.com) is interested in our Enterprise plan and wants to schedule a demo for next Tuesday at 2pm.&#34;
+        }
+    ],
+    output_format=ContactInfo,
+)
+
+print(response.parsed_output)
+```
+
+```typescript TypeScript
+import Anthropic from &#39;@anthropic-ai/sdk&#39;;
+import { z } from &#39;zod&#39;;
+import { betaZodOutputFormat } from &#39;@anthropic-ai/sdk/helpers/beta/zod&#39;;
+
+const ContactInfoSchema = z.object({
+  name: z.string(),
+  email: z.string(),
+  plan_interest: z.string(),
+  demo_requested: z.boolean(),
+});
+
+const client = new Anthropic();
+
+const response = await client.beta.messages.parse({
+  model: &#34;claude-sonnet-4-5&#34;,
+  max_tokens: 1024,
+  betas: [&#34;structured-outputs-2025-11-13&#34;],
+  messages: [
+    {
+      role: &#34;user&#34;,
+      content: &#34;Extract the key information from this email: John Smith (john@example.com) is interested in our Enterprise plan and wants to schedule a demo for next Tuesday at 2pm.&#34;
+    }
+  ],
+  output_format: betaZodOutputFormat(ContactInfoSchema),
+});
+
+// Automatically parsed and validated
+console.log(response.parsed_output);
+```
+
+&lt;/CodeGroup&gt;
+
+#### SDK-specific methods
+
+**Python: `client.beta.messages.parse()` (Recommended)**
+
+The `parse()` method automatically transforms your Pydantic model, validates the response, and returns a `parsed_output` attribute.
+
+&lt;Note&gt;
+The `parse()` method is available on `client.beta.messages`, not `client.messages`.
+&lt;/Note&gt;
+
+&lt;section title=&#34;Example usage&#34;&gt;
+
+```python
+from pydantic import BaseModel
+import anthropic
+
+class ContactInfo(BaseModel):
+    name: str
+    email: str
+    plan_interest: str
+
+client = anthropic.Anthropic()
+
+response = client.beta.messages.parse(
+    model=&#34;claude-sonnet-4-5&#34;,
+    betas=[&#34;structured-outputs-2025-11-13&#34;],
+    max_tokens=1024,
+    messages=[{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;...&#34;}],
+    output_format=ContactInfo,
+)
+
+# Access the parsed output directly
+contact = response.parsed_output
+print(contact.name, contact.email)
+```
+
+&lt;/section&gt;
+
+**Python: `transform_schema()` helper**
+
+For when you need to manually transform schemas before sending, or when you want to modify a Pydantic-generated schema. Unlike `client.beta.messages.parse()`, which transforms provided schemas automatically, this gives you the transformed schema so you can further customize it.
+
+&lt;section title=&#34;Example usage&#34;&gt;
+
+```python
+from anthropic import transform_schema
+from pydantic import TypeAdapter
+
+# First convert Pydantic model to JSON schema, then transform
+schema = TypeAdapter(ContactInfo).json_schema()
+schema = transform_schema(schema)
+# Modify schema if needed
+schema[&#34;properties&#34;][&#34;custom_field&#34;] = {&#34;type&#34;: &#34;string&#34;}
+
+response = client.beta.messages.create(
+    model=&#34;claude-sonnet-4-5&#34;,
+    betas=[&#34;structured-outputs-2025-11-13&#34;],
+    max_tokens=1024,
+    output_format=schema,
+    messages=[{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;...&#34;}],
+)
+```
+
+&lt;/section&gt;
+
+#### How SDK transformation works
+
+Both Python and TypeScript SDKs automatically transform schemas with unsupported features:
+
+1. **Remove unsupported constraints** (e.g., `minimum`, `maximum`, `minLength`, `maxLength`)
+2. **Update descriptions** with constraint info (e.g., &#34;Must be at least 100&#34;), when the constraint is not directly supported with structured outputs
+3. **Add `additionalProperties: false`** to all objects
+4. **Filter string formats** to supported list only
+5. **Validate responses** against your original schema (with all constraints)
+
+This means Claude receives a simplified schema, but your code still enforces all constraints through validation.
+
+**Example:** A Pydantic field with `minimum: 100` becomes a plain integer in the sent schema, but the description is updated to &#34;Must be at least 100&#34;, and the SDK validates the response against the original constraint.
+
+### Common use cases
+
+&lt;section title=&#34;Data extraction&#34;&gt;
+
+Extract structured data from unstructured text:
+
+&lt;CodeGroup&gt;
+
+```python Python
+from pydantic import BaseModel
+from typing import List
+
+class Invoice(BaseModel):
+    invoice_number: str
+    date: str
+    total_amount: float
+    line_items: List[dict]
+    customer_name: str
+
+response = client.beta.messages.parse(
+    model=&#34;claude-sonnet-4-5&#34;,
+    betas=[&#34;structured-outputs-2025-11-13&#34;],
+    output_format=Invoice,
+    messages=[{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: f&#34;Extract invoice data from: {invoice_text}&#34;}]
+)
+```
+
+```typescript TypeScript
+import { z } from &#39;zod&#39;;
+
+const InvoiceSchema = z.object({
+  invoice_number: z.string(),
+  date: z.string(),
+  total_amount: z.number(),
+  line_items: z.array(z.record(z.any())),
+  customer_name: z.string(),
+});
+
+const response = await client.beta.messages.parse({
+  model: &#34;claude-sonnet-4-5&#34;,
+  betas: [&#34;structured-outputs-2025-11-13&#34;],
+  output_format: InvoiceSchema,
+  messages: [{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: `Extract invoice data from: ${invoiceText}`}]
+});
+```
+
+&lt;/CodeGroup&gt;
+
+&lt;/section&gt;
+
+&lt;section title=&#34;Classification&#34;&gt;
+
+Classify content with structured categories:
+
+&lt;CodeGroup&gt;
+
+```python Python
+from pydantic import BaseModel
+from typing import List
+
+class Classification(BaseModel):
+    category: str
+    confidence: float
+    tags: List[str]
+    sentiment: str
+
+response = client.beta.messages.parse(
+    model=&#34;claude-sonnet-4-5&#34;,
+    betas=[&#34;structured-outputs-2025-11-13&#34;],
+    output_format=Classification,
+    messages=[{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: f&#34;Classify this feedback: {feedback_text}&#34;}]
+)
+```
+
+```typescript TypeScript
+import { z } from &#39;zod&#39;;
+
+const ClassificationSchema = z.object({
+  category: z.string(),
+  confidence: z.number(),
+  tags: z.array(z.string()),
+  sentiment: z.string(),
+});
+
+const response = await client.beta.messages.parse({
+  model: &#34;claude-sonnet-4-5&#34;,
+  betas: [&#34;structured-outputs-2025-11-13&#34;],
+  output_format: ClassificationSchema,
+  messages: [{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: `Classify this feedback: ${feedbackText}`}]
+});
+```
+
+&lt;/CodeGroup&gt;
+
+&lt;/section&gt;
+
+&lt;section title=&#34;API response formatting&#34;&gt;
+
+Generate API-ready responses:
+
+&lt;CodeGroup&gt;
+
+```python Python
+from pydantic import BaseModel
+from typing import List, Optional
+
+class APIResponse(BaseModel):
+    status: str
+    data: dict
+    errors: Optional[List[dict]]
+    metadata: dict
+
+response = client.beta.messages.parse(
+    model=&#34;claude-sonnet-4-5&#34;,
+    betas=[&#34;structured-outputs-2025-11-13&#34;],
+    output_format=APIResponse,
+    messages=[{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Process this request: ...&#34;}]
+)
+```
+
+```typescript TypeScript
+import { z } from &#39;zod&#39;;
+
+const APIResponseSchema = z.object({
+  status: z.string(),
+  data: z.record(z.any()),
+  errors: z.array(z.record(z.any())).optional(),
+  metadata: z.record(z.any()),
+});
+
+const response = await client.beta.messages.parse({
+  model: &#34;claude-sonnet-4-5&#34;,
+  betas: [&#34;structured-outputs-2025-11-13&#34;],
+  output_format: APIResponseSchema,
+  messages: [{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Process this request: ...&#34;}]
+});
+```
+
+&lt;/CodeGroup&gt;
+
+&lt;/section&gt;
+
+## Strict tool use
+
+Strict tool use validates tool parameters, ensuring Claude calls your functions with correctly-typed arguments. Use strict tool use when you need to:
+
+- Validate tool parameters
+- Build agentic workflows
+- Ensure type-safe function calls
+- Handle complex tools with nested properties
+
+### Why strict tool use matters for agents
+
+Building reliable agentic systems requires guaranteed schema conformance. Without strict mode, Claude might return incompatible types (`&#34;2&#34;` instead of `2`) or missing required fields, breaking your functions and causing runtime errors.
+
+Strict tool use guarantees type-safe parameters:
+- Functions receive correctly-typed arguments every time
+- No need to validate and retry tool calls
+- Production-ready agents that work consistently at scale
+
+For example, suppose a booking system needs `passengers: int`. Without strict mode, Claude might provide `passengers: &#34;two&#34;` or `passengers: &#34;2&#34;`. With `strict: true`, the response will always contain `passengers: 2`.
+
+### Quick start
+
+&lt;CodeGroup&gt;
+
+```bash Shell
+curl https://api.anthropic.com/v1/messages \
+  -H &#34;content-type: application/json&#34; \
+  -H &#34;x-api-key: $ANTHROPIC_API_KEY&#34; \
+  -H &#34;anthropic-version: 2023-06-01&#34; \
+  -H &#34;anthropic-beta: structured-outputs-2025-11-13&#34; \
+  -d &#39;{
+    &#34;model&#34;: &#34;claude-sonnet-4-5&#34;,
+    &#34;max_tokens&#34;: 1024,
+    &#34;messages&#34;: [
+      {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;What is the weather in San Francisco?&#34;}
+    ],
+    &#34;tools&#34;: [{
+      &#34;name&#34;: &#34;get_weather&#34;,
+      &#34;description&#34;: &#34;Get the current weather in a given location&#34;,
+      &#34;strict&#34;: true,
+      &#34;input_schema&#34;: {
+        &#34;type&#34;: &#34;object&#34;,
+        &#34;properties&#34;: {
+          &#34;location&#34;: {
+            &#34;type&#34;: &#34;string&#34;,
+            &#34;description&#34;: &#34;The city and state, e.g. San Francisco, CA&#34;
+          },
+          &#34;unit&#34;: {
+            &#34;type&#34;: &#34;string&#34;,
+            &#34;enum&#34;: [&#34;celsius&#34;, &#34;fahrenheit&#34;]
+          }
+        },
+        &#34;required&#34;: [&#34;location&#34;],
+        &#34;additionalProperties&#34;: false
+      }
+    }]
+  }&#39;
+```
+
+```python Python
+import anthropic
+
+client = anthropic.Anthropic()
+
+response = client.beta.messages.create(
+    model=&#34;claude-sonnet-4-5&#34;,
+    max_tokens=1024,
+    betas=[&#34;structured-outputs-2025-11-13&#34;],
+    messages=[
+        {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;What&#39;s the weather like in San Francisco?&#34;}
+    ],
+    tools=[
+        {
+            &#34;name&#34;: &#34;get_weather&#34;,
+            &#34;description&#34;: &#34;Get the current weather in a given location&#34;,
+            &#34;strict&#34;: True,  # Enable strict mode
+            &#34;input_schema&#34;: {
+                &#34;type&#34;: &#34;object&#34;,
+                &#34;properties&#34;: {
+                    &#34;location&#34;: {
+                        &#34;type&#34;: &#34;string&#34;,
+                        &#34;description&#34;: &#34;The city and state, e.g. San Francisco, CA&#34;
+                    },
+                    &#34;unit&#34;: {
+                        &#34;type&#34;: &#34;string&#34;,
+                        &#34;enum&#34;: [&#34;celsius&#34;, &#34;fahrenheit&#34;],
+                        &#34;description&#34;: &#34;The unit of temperature, either &#39;celsius&#39; or &#39;fahrenheit&#39;&#34;
+                    }
+                },
+                &#34;required&#34;: [&#34;location&#34;],
+                &#34;additionalProperties&#34;: False
+            }
+        }
+    ]
+)
+print(response.content)
+```
+
+```typescript TypeScript
+import Anthropic from &#39;@anthropic-ai/sdk&#39;;
+
+const client = new Anthropic({
+  apiKey: process.env.ANTHROPIC_API_KEY
+});
+
+const response = await client.beta.messages.create({
+  model: &#34;claude-sonnet-4-5&#34;,
+  max_tokens: 1024,
+  betas: [&#34;structured-outputs-2025-11-13&#34;],
+  messages: [
+    {
+      role: &#34;user&#34;,
+      content: &#34;What&#39;s the weather like in San Francisco?&#34;
+    }
+  ],
+  tools: [{
+    name: &#34;get_weather&#34;,
+    description: &#34;Get the current weather in a given location&#34;,
+    strict: true,  // Enable strict mode
+    input_schema: {
+      type: &#34;object&#34;,
+      properties: {
+        location: {
+          type: &#34;string&#34;,
+          description: &#34;The city and state, e.g. San Francisco, CA&#34;
+        },
+        unit: {
+          type: &#34;string&#34;,
+          enum: [&#34;celsius&#34;, &#34;fahrenheit&#34;]
+        }
+      },
+      required: [&#34;location&#34;],
+      additionalProperties: false
+    }
+  }]
+});
+console.log(response.content);
+```
+
+&lt;/CodeGroup&gt;
+
+**Response format:** Tool use blocks with validated inputs in `response.content[x].input`
+
+```json
+{
+  &#34;type&#34;: &#34;tool_use&#34;,
+  &#34;name&#34;: &#34;get_weather&#34;,
+  &#34;input&#34;: {
+    &#34;location&#34;: &#34;San Francisco, CA&#34;
+  }
+}
+```
+
+**Guarantees:**
+- Tool `input` strictly follows the `input_schema`
+- Tool `name` is always valid (from provided tools or server tools)
+
+### How it works
+
+&lt;Steps&gt;
+  &lt;Step title=&#34;Define your tool schema&#34;&gt;
+    Create a JSON schema for your tool&#39;s `input_schema`. The schema uses standard JSON Schema format with some limitations (see [JSON Schema limitations](#json-schema-limitations)).
+  &lt;/Step&gt;
+  &lt;Step title=&#34;Add strict: true&#34;&gt;
+    Set `&#34;strict&#34;: true` as a top-level property in your tool definition, alongside `name`, `description`, and `input_schema`.
+  &lt;/Step&gt;
+  &lt;Step title=&#34;Include the beta header&#34;&gt;
+    Add the `anthropic-beta: structured-outputs-2025-11-13` header to your request.
+  &lt;/Step&gt;
+  &lt;Step title=&#34;Handle tool calls&#34;&gt;
+    When Claude uses the tool, the `input` field in the tool_use block will strictly follow your `input_schema`, and the `name` will always be valid.
+  &lt;/Step&gt;
+&lt;/Steps&gt;
+
+### Common use cases
+
+&lt;section title=&#34;Validated tool inputs&#34;&gt;
+
+Ensure tool parameters exactly match your schema:
+
+&lt;CodeGroup&gt;
+
+```python Python
+response = client.beta.messages.create(
+    model=&#34;claude-sonnet-4-5&#34;,
+    betas=[&#34;structured-outputs-2025-11-13&#34;],
+    messages=[{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Search for flights to Tokyo&#34;}],
+    tools=[{
+        &#34;name&#34;: &#34;search_flights&#34;,
+        &#34;strict&#34;: True,
+        &#34;input_schema&#34;: {
+            &#34;type&#34;: &#34;object&#34;,
+            &#34;properties&#34;: {
+                &#34;destination&#34;: {&#34;type&#34;: &#34;string&#34;},
+                &#34;departure_date&#34;: {&#34;type&#34;: &#34;string&#34;, &#34;format&#34;: &#34;date&#34;},
+                &#34;passengers&#34;: {&#34;type&#34;: &#34;integer&#34;, &#34;enum&#34;: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}
+            },
+            &#34;required&#34;: [&#34;destination&#34;, &#34;departure_date&#34;],
+            &#34;additionalProperties&#34;: False
+        }
+    }]
+)
+```
+
+```typescript TypeScript
+const response = await client.beta.messages.create({
+  model: &#34;claude-sonnet-4-5&#34;,
+  betas: [&#34;structured-outputs-2025-11-13&#34;],
+  messages: [{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Search for flights to Tokyo&#34;}],
+  tools: [{
+    name: &#34;search_flights&#34;,
+    strict: true,
+    input_schema: {
+      type: &#34;object&#34;,
+      properties: {
+        destination: {type: &#34;string&#34;},
+        departure_date: {type: &#34;string&#34;, format: &#34;date&#34;},
+        passengers: {type: &#34;integer&#34;, enum: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}
+      },
+      required: [&#34;destination&#34;, &#34;departure_date&#34;],
+      additionalProperties: false
+    }
+  }]
+});
+```
+
+&lt;/CodeGroup&gt;
+
+&lt;/section&gt;
+
+&lt;section title=&#34;Agentic workflow with multiple validated tools&#34;&gt;
+
+Build reliable multi-step agents with guaranteed tool parameters:
+
+&lt;CodeGroup&gt;
+
+```python Python
+response = client.beta.messages.create(
+    model=&#34;claude-sonnet-4-5&#34;,
+    betas=[&#34;structured-outputs-2025-11-13&#34;],
+    messages=[{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Help me plan a trip to Paris for 2 people&#34;}],
+    tools=[
+        {
+            &#34;name&#34;: &#34;search_flights&#34;,
+            &#34;strict&#34;: True,
+            &#34;input_schema&#34;: {
+                &#34;type&#34;: &#34;object&#34;,
+                &#34;properties&#34;: {
+                    &#34;origin&#34;: {&#34;type&#34;: &#34;string&#34;},
+                    &#34;destination&#34;: {&#34;type&#34;: &#34;string&#34;},
+                    &#34;departure_date&#34;: {&#34;type&#34;: &#34;string&#34;, &#34;format&#34;: &#34;date&#34;},
+                    &#34;travelers&#34;: {&#34;type&#34;: &#34;integer&#34;, &#34;enum&#34;: [1, 2, 3, 4, 5, 6]}
+                },
+                &#34;required&#34;: [&#34;origin&#34;, &#34;destination&#34;, &#34;departure_date&#34;],
+                &#34;additionalProperties&#34;: False
+            }
+        },
+        {
+            &#34;name&#34;: &#34;search_hotels&#34;,
+            &#34;strict&#34;: True,
+            &#34;input_schema&#34;: {
+                &#34;type&#34;: &#34;object&#34;,
+                &#34;properties&#34;: {
+                    &#34;city&#34;: {&#34;type&#34;: &#34;string&#34;},
+                    &#34;check_in&#34;: {&#34;type&#34;: &#34;string&#34;, &#34;format&#34;: &#34;date&#34;},
+                    &#34;guests&#34;: {&#34;type&#34;: &#34;integer&#34;, &#34;enum&#34;: [1, 2, 3, 4]}
+                },
+                &#34;required&#34;: [&#34;city&#34;, &#34;check_in&#34;],
+                &#34;additionalProperties&#34;: False
+            }
+        }
+    ]
+)
+```
+
+```typescript TypeScript
+const response = await client.beta.messages.create({
+  model: &#34;claude-sonnet-4-5&#34;,
+  betas: [&#34;structured-outputs-2025-11-13&#34;],
+  messages: [{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Help me plan a trip to Paris for 2 people&#34;}],
+  tools: [
+    {
+      name: &#34;search_flights&#34;,
+      strict: true,
+      input_schema: {
+        type: &#34;object&#34;,
+        properties: {
+          origin: {type: &#34;string&#34;},
+          destination: {type: &#34;string&#34;},
+          departure_date: {type: &#34;string&#34;, format: &#34;date&#34;},
+          travelers: {type: &#34;integer&#34;, enum: [1, 2, 3, 4, 5, 6]}
+        },
+        required: [&#34;origin&#34;, &#34;destination&#34;, &#34;departure_date&#34;],
+        additionalProperties: false
+      }
+    },
+    {
+      name: &#34;search_hotels&#34;,
+      strict: true,
+      input_schema: {
+        type: &#34;object&#34;,
+        properties: {
+          city: {type: &#34;string&#34;},
+          check_in: {type: &#34;string&#34;, format: &#34;date&#34;},
+          guests: {type: &#34;integer&#34;, enum: [1, 2, 3, 4]}
+        },
+        required: [&#34;city&#34;, &#34;check_in&#34;],
+        additionalProperties: false
+      }
+    }
+  ]
+});
+```
+
+&lt;/CodeGroup&gt;
+
+&lt;/section&gt;
+
+## Using both features together
+
+JSON outputs and strict tool use solve different problems and can be used together:
+
+- **JSON outputs** control Claude&#39;s response format (what Claude says)
+- **Strict tool use** validates tool parameters (how Claude calls your functions)
+
+When combined, Claude can call tools with guaranteed-valid parameters AND return structured JSON responses. This is useful for agentic workflows where you need both reliable tool calls and structured final outputs.
+
+&lt;CodeGroup&gt;
+
+```python Python
+response = client.beta.messages.create(
+    model=&#34;claude-sonnet-4-5&#34;,
+    betas=[&#34;structured-outputs-2025-11-13&#34;],
+    max_tokens=1024,
+    messages=[{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Help me plan a trip to Paris for next month&#34;}],
+    # JSON outputs: structured response format
+    output_format={
+        &#34;type&#34;: &#34;json_schema&#34;,
+        &#34;schema&#34;: {
+            &#34;type&#34;: &#34;object&#34;,
+            &#34;properties&#34;: {
+                &#34;summary&#34;: {&#34;type&#34;: &#34;string&#34;},
+                &#34;next_steps&#34;: {&#34;type&#34;: &#34;array&#34;, &#34;items&#34;: {&#34;type&#34;: &#34;string&#34;}}
+            },
+            &#34;required&#34;: [&#34;summary&#34;, &#34;next_steps&#34;],
+            &#34;additionalProperties&#34;: False
+        }
+    },
+    # Strict tool use: guaranteed tool parameters
+    tools=[{
+        &#34;name&#34;: &#34;search_flights&#34;,
+        &#34;strict&#34;: True,
+        &#34;input_schema&#34;: {
+            &#34;type&#34;: &#34;object&#34;,
+            &#34;properties&#34;: {
+                &#34;destination&#34;: {&#34;type&#34;: &#34;string&#34;},
+                &#34;date&#34;: {&#34;type&#34;: &#34;string&#34;, &#34;format&#34;: &#34;date&#34;}
+            },
+            &#34;required&#34;: [&#34;destination&#34;, &#34;date&#34;],
+            &#34;additionalProperties&#34;: False
+        }
+    }]
+)
+```
+
+```typescript TypeScript
+const response = await client.beta.messages.create({
+  model: &#34;claude-sonnet-4-5&#34;,
+  betas: [&#34;structured-outputs-2025-11-13&#34;],
+  max_tokens: 1024,
+  messages: [{ role: &#34;user&#34;, content: &#34;Help me plan a trip to Paris for next month&#34; }],
+  // JSON outputs: structured response format
+  output_format: {
+    type: &#34;json_schema&#34;,
+    schema: {
+      type: &#34;object&#34;,
+      properties: {
+        summary: { type: &#34;string&#34; },
+        next_steps: { type: &#34;array&#34;, items: { type: &#34;string&#34; } }
+      },
+      required: [&#34;summary&#34;, &#34;next_steps&#34;],
+      additionalProperties: false
+    }
+  },
+  // Strict tool use: guaranteed tool parameters
+  tools: [{
+    name: &#34;search_flights&#34;,
+    strict: true,
+    input_schema: {
+      type: &#34;object&#34;,
+      properties: {
+        destination: { type: &#34;string&#34; },
+        date: { type: &#34;string&#34;, format: &#34;date&#34; }
+      },
+      required: [&#34;destination&#34;, &#34;date&#34;],
+      additionalProperties: false
+    }
+  }]
+});
+```
+
+&lt;/CodeGroup&gt;
+
+## Important considerations
+
+### Grammar compilation and caching
+
+Structured outputs use constrained sampling with compiled grammar artifacts. This introduces some performance characteristics to be aware of:
+
+- **First request latency**: The first time you use a specific schema, there will be additional latency while the grammar is compiled
+- **Automatic caching**: Compiled grammars are cached for 24 hours from last use, making subsequent requests much faster
+- **Cache invalidation**: The cache is invalidated if you change:
+  - The JSON schema structure
+  - The set of tools in your request (when using both structured outputs and tool use)
+  - Changing only `name` or `description` fields does not invalidate the cache
+
+### Prompt modification and token costs
+
+When using structured outputs, Claude automatically receives an additional system prompt explaining the expected output format. This means:
+
+- Your input token count will be slightly higher
+- The injected prompt costs you tokens like any other system prompt
+- Changing the `output_format` parameter will invalidate any [prompt cache](/docs/en/build-with-claude/prompt-caching) for that conversation thread
+
+### JSON Schema limitations
+
+Structured outputs support standard JSON Schema with some limitations. Both JSON outputs and strict tool use share these limitations.
+
+&lt;section title=&#34;Supported features&#34;&gt;
+
+- All basic types: object, array, string, integer, number, boolean, null
+- `enum` (strings, numbers, bools, or nulls only - no complex types)
+- `const`
+- `anyOf` and `allOf` (with limitations - `allOf` with `$ref` not supported)
+- `$ref`, `$def`, and `definitions` (external `$ref` not supported)
+- `default` property for all supported types
+- `required` and `additionalProperties` (must be set to `false` for objects)
+- String formats: `date-time`, `time`, `date`, `duration`, `email`, `hostname`, `uri`, `ipv4`, `ipv6`, `uuid`
+- Array `minItems` (only values 0 and 1 supported)
+
+&lt;/section&gt;
+
+&lt;section title=&#34;Not supported&#34;&gt;
+
+- Recursive schemas
+- Complex types within enums
+- External `$ref` (e.g., `&#39;$ref&#39;: &#39;http://...&#39;`)
+- Numerical constraints (`minimum`, `maximum`, `multipleOf`, etc.)
+- String constraints (`minLength`, `maxLength`)
+- Array constraints beyond `minItems` of 0 or 1
+- `additionalProperties` set to anything other than `false`
+
+If you use an unsupported feature, you&#39;ll receive a 400 error with details.
+
+&lt;/section&gt;
+
+&lt;section title=&#34;Pattern support (regex)&#34;&gt;
+
+**Supported regex features:**
+- Full matching (`^...$`) and partial matching
+- Quantifiers: `*`, `+`, `?`, simple `{n,m}` cases
+- Character classes: `[]`, `.`, `\d`, `\w`, `\s`
+- Groups: `(...)`
+
+**NOT supported:**
+- Backreferences to groups (e.g., `\1`, `\2`)
+- Lookahead/lookbehind assertions (e.g., `(?=...)`, `(?!...)`)
+- Word boundaries: `\b`, `\B`
+- Complex `{n,m}` quantifiers with large ranges
+
+Simple regex patterns work well. Complex patterns may result in 400 errors.
+
+&lt;/section&gt;
+
+&lt;Tip&gt;
+The Python and TypeScript SDKs can automatically transform schemas with unsupported features by removing them and adding constraints to field descriptions. See [SDK-specific methods](#sdk-specific-methods) for details.
+&lt;/Tip&gt;
+
+### Invalid outputs
+
+While structured outputs guarantee schema compliance in most cases, there are scenarios where the output may not match your schema:
+
+**Refusals** (`stop_reason: &#34;refusal&#34;`)
+
+Claude maintains its safety and helpfulness properties even when using structured outputs. If Claude refuses a request for safety reasons:
+
+- The response will have `stop_reason: &#34;refusal&#34;`
+- You&#39;ll receive a 200 status code
+- You&#39;ll be billed for the tokens generated
+- The output may not match your schema because the refusal message takes precedence over schema constraints
+
+**Token limit reached** (`stop_reason: &#34;max_tokens&#34;`)
+
+If the response is cut off due to reaching the `max_tokens` limit:
+
+- The response will have `stop_reason: &#34;max_tokens&#34;`
+- The output may be incomplete and not match your schema
+- Retry with a higher `max_tokens` value to get the complete structured output
+
+### Schema validation errors
+
+If your schema uses unsupported features or is too complex, you&#39;ll receive a 400 error:
+
+**&#34;Too many recursive definitions in schema&#34;**
+- Cause: Schema has excessive or cyclic recursive definitions
+- Solution: Simplify schema structure, reduce nesting depth
+
+**&#34;Schema is too complex&#34;**
+- Cause: Schema exceeds complexity limits
+- Solution: Break into smaller schemas, simplify structure, or reduce the number of tools marked as `strict: true`
+
+For persistent issues with valid schemas, [contact support](https://support.claude.com/en/articles/9015913-how-to-get-support) with your schema definition.
+
+## Feature compatibility
+
+**Works with:**
+- **[Batch processing](/docs/en/build-with-claude/batch-processing)**: Process structured outputs at scale with 50% discount
+- **[Token counting](/docs/en/build-with-claude/token-counting)**: Count tokens without compilation
+- **[Streaming](/docs/en/build-with-claude/streaming)**: Stream structured outputs like normal responses
+- **Combined usage**: Use JSON outputs (`output_format`) and strict tool use (`strict: true`) together in the same request
+
+**Incompatible with:**
+- **[Citations](/docs/en/build-with-claude/citations)**: Citations require interleaving citation blocks with text, which conflicts with strict JSON schema constraints. Returns 400 error if citations enabled with `output_format`.
+- **[Message Prefilling](/docs/en/build-with-claude/prompt-engineering/prefill-claudes-response)**: Incompatible with JSON outputs
+
+&lt;Tip&gt;
+**Grammar scope**: Grammars apply only to Claude&#39;s direct output, not to tool use calls, tool results, or thinking tags (when using [Extended Thinking](/docs/en/build-with-claude/extended-thinking)). Grammar state resets between sections, allowing Claude to think freely while still producing structured output in the final response.
+&lt;/Tip&gt;</code></pre>
    </div>
</body>
</html>