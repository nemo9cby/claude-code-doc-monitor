<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>agents-and-tools/tool-use/bash-tool - Diff Report</title>
    <link rel="stylesheet" href="../../css/diff.css">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --card-bg: #16213e;
            --text-color: #eee;
            --accent: #0f3460;
            --add-bg: #1a4d1a;
            --del-bg: #4d1a1a;
            --add-text: #4ade80;
            --del-text: #f87171;
        }
        @media (prefers-color-scheme: light) {
            :root {
                --bg-color: #f5f5f5;
                --card-bg: #fff;
                --text-color: #333;
                --accent: #e0e0e0;
                --add-bg: #d4edda;
                --del-bg: #f8d7da;
                --add-text: #155724;
                --del-text: #721c24;
            }
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 2rem;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        header { margin-bottom: 2rem; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .meta { color: #888; font-size: 0.9rem; }
        .summary {
            background: var(--card-bg);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            display: flex;
            gap: 2rem;
        }
        .stat { display: flex; align-items: center; gap: 0.5rem; }
        .stat.added { color: var(--add-text); }
        .stat.removed { color: var(--del-text); }
        .analysis {
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            border-left: 4px solid #8b5cf6;
        }
        .analysis-header {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #8b5cf6;
        }
        .analysis-content {
            white-space: pre-wrap;
            font-size: 0.95rem;
            line-height: 1.7;
        }
        .diff-container {
            background: var(--card-bg);
            border-radius: 8px;
            overflow: hidden;
        }
        .diff-header {
            background: var(--accent);
            padding: 0.75rem 1rem;
            font-weight: 600;
        }
        .diff-content {
            padding: 1rem;
            overflow-x: auto;
        }
        .diff-content ins {
            background: var(--add-bg);
            color: var(--add-text);
            text-decoration: none;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        .diff-content del {
            background: var(--del-bg);
            color: var(--del-text);
            text-decoration: line-through;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        pre {
            background: var(--accent);
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.85rem;
            margin-top: 2rem;
        }
        a { color: #60a5fa; }
        .back-link { margin-bottom: 1rem; display: inline-block; }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">&larr; Back to daily report</a>

        <header>
            <h1>agents-and-tools/tool-use/bash-tool.md</h1>
            <p class="meta">Changed on 2026-01-06 14:35:17 UTC</p>
        </header>

        <div class="summary">
            <div class="stat added">
                <span>+274</span> lines added
            </div>
            <div class="stat removed">
                <span>-0</span> lines removed
            </div>
        </div>

        
        <div class="analysis">
            <div class="analysis-header">ðŸ¤– AI Analysis</div>
            <div class="analysis-content"># Documentation Change Analysis

## Summary
The documentation for the Bash tool has been significantly expanded, detailing its functionality, use cases, and implementation guidelines. This addition provides developers with a comprehensive understanding of how to leverage the Bash tool within the Claude environment.

## Key Changes
- **Overview Section**: Introduced a clear overview of the Bash tool&#39;s capabilities, including persistent sessions and command execution.
- **Use Cases**: Added practical examples of how the Bash tool can be utilized in development workflows, system automation, data processing, and environment setup.
- **Quick Start Guide**: Provided code snippets for both Python and Bash to facilitate quick integration and usage of the Bash tool.
- **Implementation Steps**: Detailed instructions on setting up a Bash environment, executing commands, and handling errors, including safety measures and best practices.
- **Security and Pricing Information**: Included warnings about security risks and the token pricing model for using the Bash tool.

## Impact
**High**: This change introduces a new feature that allows developers to execute shell commands within a persistent session, significantly enhancing automation capabilities and system interaction within the Claude framework. The detailed documentation will aid in faster adoption and implementation by developers.</div>
        </div>
        

        <div class="diff-container">
            <div class="diff-header">Visual Diff</div>
            <div class="diff-content"><ins style="background:#e6ffe6;"># Bash tool&para;<br>&para;<br>---&para;<br>&para;<br>The bash tool enables Claude to execute shell commands in a persistent bash session, allowing system operations, script execution, and command-line automation.&para;<br>&para;<br>## Overview&para;<br>&para;<br>The bash tool provides Claude with:&para;<br>- Persistent bash session that maintains state&para;<br>- Ability to run any shell command&para;<br>- Access to environment variables and working directory&para;<br>- Command chaining and scripting capabilities&para;<br>&para;<br>## Model compatibility&para;<br>&para;<br>| Model | Tool Version |&para;<br>|-------|--------------|&para;<br>| Claude 4 models and Sonnet 3.7 ([deprecated](/docs/en/about-claude/model-deprecations)) | `bash_20250124` |&para;<br>&para;<br>&lt;Warning&gt;&para;<br>Older tool versions are not guaranteed to be backwards-compatible with newer models. Always use the tool version that corresponds to your model version.&para;<br>&lt;/Warning&gt;&para;<br>&para;<br>## Use cases&para;<br>&para;<br>- **Development workflows**: Run build commands, tests, and development tools&para;<br>- **System automation**: Execute scripts, manage files, automate tasks&para;<br>- **Data processing**: Process files, run analysis scripts, manage datasets&para;<br>- **Environment setup**: Install packages, configure environments&para;<br>&para;<br>## Quick start&para;<br>&para;<br>&lt;CodeGroup&gt;&para;<br>```python Python&para;<br>import anthropic&para;<br>&para;<br>client = anthropic.Anthropic()&para;<br>&para;<br>response = client.messages.create(&para;<br>    model="claude-sonnet-4-5",&para;<br>    max_tokens=1024,&para;<br>    tools=[&para;<br>        {&para;<br>            "type": "bash_20250124",&para;<br>            "name": "bash"&para;<br>        }&para;<br>    ],&para;<br>    messages=[&para;<br>        {"role": "user", "content": "List all Python files in the current directory."}&para;<br>    ]&para;<br>)&para;<br>```&para;<br>&para;<br>```bash Shell&para;<br>curl https://api.anthropic.com/v1/messages \&para;<br>  -H "content-type: application/json" \&para;<br>  -H "x-api-key: $ANTHROPIC_API_KEY" \&para;<br>  -H "anthropic-version: 2023-06-01" \&para;<br>  -d '{&para;<br>    "model": "claude-sonnet-4-5",&para;<br>    "max_tokens": 1024,&para;<br>    "tools": [&para;<br>      {&para;<br>        "type": "bash_20250124",&para;<br>        "name": "bash"&para;<br>      }&para;<br>    ],&para;<br>    "messages": [&para;<br>      {&para;<br>        "role": "user",&para;<br>        "content": "List all Python files in the current directory."&para;<br>      }&para;<br>    ]&para;<br>  }'&para;<br>```&para;<br>&lt;/CodeGroup&gt;&para;<br>&para;<br>## How it works&para;<br>&para;<br>The bash tool maintains a persistent session:&para;<br>&para;<br>1. Claude determines what command to run&para;<br>2. You execute the command in a bash shell&para;<br>3. Return the output (stdout and stderr) to Claude&para;<br>4. Session state persists between commands (environment variables, working directory)&para;<br>&para;<br>## Parameters&para;<br>&para;<br>| Parameter | Required | Description |&para;<br>|-----------|----------|-------------|&para;<br>| `command` | Yes* | The bash command to run |&para;<br>| `restart` | No | Set to `true` to restart the bash session |&para;<br>&para;<br>*Required unless using `restart`&para;<br>&para;<br>&lt;section title="Example usage"&gt;&para;<br>&para;<br>```json&para;<br>// Run a command&para;<br>{&para;<br>  "command": "ls -la *.py"&para;<br>}&para;<br>&para;<br>// Restart the session&para;<br>{&para;<br>  "restart": true&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>## Example: Multi-step automation&para;<br>&para;<br>Claude can chain commands to complete complex tasks:&para;<br>&para;<br>```python&para;<br># User request&para;<br>"Install the requests library and create a simple Python script that fetches a joke from an API, then run it."&para;<br>&para;<br># Claude's tool uses:&para;<br># 1. Install package&para;<br>{"command": "pip install requests"}&para;<br>&para;<br># 2. Create script&para;<br>{"command": "cat &gt; fetch_joke.py &lt;&lt; 'EOF'\nimport requests\nresponse = requests.get('https://official-joke-api.appspot.com/random_joke')\njoke = response.json()\nprint(f\"Setup: {joke['setup']}\")\nprint(f\"Punchline: {joke['punchline']}\")\nEOF"}&para;<br>&para;<br># 3. Run script&para;<br>{"command": "python fetch_joke.py"}&para;<br>```&para;<br>&para;<br>The session maintains state between commands, so files created in step 2 are available in step 3.&para;<br>&para;<br>***&para;<br>&para;<br>## Implement the bash tool&para;<br>&para;<br>The bash tool is implemented as a schema-less tool. When using this tool, you don't need to provide an input schema as with other tools; the schema is built into Claude's model and can't be modified.&para;<br>&para;<br>&lt;Steps&gt;&para;<br>  &lt;Step title="Set up a bash environment"&gt;&para;<br>    Create a persistent bash session that Claude can interact with:&para;<br>    ```python&para;<br>    import subprocess&para;<br>    import threading&para;<br>    import queue&para;<br>    &para;<br>    class BashSession:&para;<br>        def __init__(self):&para;<br>            self.process = subprocess.Popen(&para;<br>                ['/bin/bash'],&para;<br>                stdin=subprocess.PIPE,&para;<br>                stdout=subprocess.PIPE,&para;<br>                stderr=subprocess.PIPE,&para;<br>                text=True,&para;<br>                bufsize=0&para;<br>            )&para;<br>            self.output_queue = queue.Queue()&para;<br>            self.error_queue = queue.Queue()&para;<br>            self._start_readers()&para;<br>    ```&para;<br>  &lt;/Step&gt;&para;<br>  &lt;Step title="Handle command execution"&gt;&para;<br>    Create a function to execute commands and capture output:&para;<br>    ```python&para;<br>    def execute_command(self, command):&para;<br>        # Send command to bash&para;<br>        self.process.stdin.write(command + '\n')&para;<br>        self.process.stdin.flush()&para;<br>        &para;<br>        # Capture output with timeout&para;<br>        output = self._read_output(timeout=10)&para;<br>        return output&para;<br>    ```&para;<br>  &lt;/Step&gt;&para;<br>  &lt;Step title="Process Claude's tool calls"&gt;&para;<br>    Extract and execute commands from Claude's responses:&para;<br>    ```python&para;<br>    for content in response.content:&para;<br>        if content.type == "tool_use" and content.name == "bash":&para;<br>            if content.input.get("restart"):&para;<br>                bash_session.restart()&para;<br>                result = "Bash session restarted"&para;<br>            else:&para;<br>                command = content.input.get("command")&para;<br>                result = bash_session.execute_command(command)&para;<br>            &para;<br>            # Return result to Claude&para;<br>            tool_result = {&para;<br>                "type": "tool_result",&para;<br>                "tool_use_id": content.id,&para;<br>                "content": result&para;<br>            }&para;<br>    ```&para;<br>  &lt;/Step&gt;&para;<br>  &lt;Step title="Implement safety measures"&gt;&para;<br>    Add validation and restrictions:&para;<br>    ```python&para;<br>    def validate_command(command):&para;<br>        # Block dangerous commands&para;<br>        dangerous_patterns = ['rm -rf /', 'format', ':(){:|:&amp;};:']&para;<br>        for pattern in dangerous_patterns:&para;<br>            if pattern in command:&para;<br>                return False, f"Command contains dangerous pattern: {pattern}"&para;<br>        &para;<br>        # Add more validation as needed&para;<br>        return True, None&para;<br>    ```&para;<br>  &lt;/Step&gt;&para;<br>&lt;/Steps&gt;&para;<br>&para;<br>### Handle errors&para;<br>&para;<br>When implementing the bash tool, handle various error scenarios:&para;<br>&para;<br>&lt;section title="Command execution timeout"&gt;&para;<br>&para;<br>If a command takes too long to execute:&para;<br>&para;<br>```json&para;<br>{&para;<br>  "role": "user",&para;<br>  "content": [&para;<br>    {&para;<br>      "type": "tool_result",&para;<br>      "tool_use_id": "toolu_01A09q90qw90lq917835lq9",&para;<br>      "content": "Error: Command timed out after 30 seconds",&para;<br>      "is_error": true&para;<br>    }&para;<br>  ]&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Command not found"&gt;&para;<br>&para;<br>If a command doesn't exist:&para;<br>&para;<br>```json&para;<br>{&para;<br>  "role": "user",&para;<br>  "content": [&para;<br>    {&para;<br>      "type": "tool_result",&para;<br>      "tool_use_id": "toolu_01A09q90qw90lq917835lq9",&para;<br>      "content": "bash: nonexistentcommand: command not found",&para;<br>      "is_error": true&para;<br>    }&para;<br>  ]&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Permission denied"&gt;&para;<br>&para;<br>If there are permission issues:&para;<br>&para;<br>```json&para;<br>{&para;<br>  "role": "user",&para;<br>  "content": [&para;<br>    {&para;<br>      "type": "tool_result",&para;<br>      "tool_use_id": "toolu_01A09q90qw90lq917835lq9",&para;<br>      "content": "bash: /root/sensitive-file: Permission denied",&para;<br>      "is_error": true&para;<br>    }&para;<br>  ]&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>### Follow implementation best practices&para;<br>&para;<br>&lt;section title="Use command timeouts"&gt;&para;<br>&para;<br>Implement timeouts to prevent hanging commands:&para;<br>```python&para;<br>def execute_with_timeout(command, timeout=30):&para;<br>    try:&para;<br>        result = subprocess.run(&para;<br>            command, &para;<br>            shell=True, &para;<br>            capture_output=True, &para;<br>            text=True, &para;<br>            timeout=timeout&para;<br>        )&para;<br>        return result.stdout + result.stderr&para;<br>    except subprocess.TimeoutExpired:&para;<br>        return f"Command timed out after {timeout} seconds"&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Maintain session state"&gt;&para;<br>&para;<br>Keep the bash session persistent to maintain environment variables and working directory:&para;<br>```python&para;<br># Commands run in the same session maintain state&para;<br>commands = [&para;<br>    "cd /tmp",&para;<br>    "echo 'Hello' &gt; test.txt",&para;<br>    "cat test.txt"  # This works because we're still in /tmp&para;<br>]&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Handle large outputs"&gt;&para;<br>&para;<br>Truncate very large outputs to prevent token limit issues:&para;<br>```python&para;<br>def truncate_output(output, max_lines=100):&para;<br>    lines = output.split('\n')&para;<br>    if len(lines) &gt; max_lines:&para;<br>        truncated = '\n'.join(lines[:max_lines])&para;<br>        return f"{truncated}\n\n... Output truncated ({len(lines)} total lines) ..."&para;<br>    return output&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Log all commands"&gt;&para;<br>&para;<br>Keep an audit trail of executed commands:&para;<br>```python&para;<br>import logging&para;<br>&para;<br>def log_command(command, output, user_id):&para;<br>    logging.info(f"User {user_id} executed: {command}")&para;<br>    logging.info(f"Output: {output[:200]}...")  # Log first 200 chars&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>&lt;section title="Sanitize outputs"&gt;&para;<br>&para;<br>Remove sensitive information from command outputs:&para;<br>```python&para;<br>def sanitize_output(output):&para;<br>    # Remove potential secrets or credentials&para;<br>    import re&para;<br>    # Example: Remove AWS credentials&para;<br>    output = re.sub(r'aws_access_key_id\s*=\s*\S+', 'aws_access_key_id=***', output)&para;<br>    output = re.sub(r'aws_secret_access_key\s*=\s*\S+', 'aws_secret_access_key=***', output)&para;<br>    return output&para;<br>```&para;<br>&para;<br>&lt;/section&gt;&para;<br>&para;<br>## Security&para;<br>&para;<br>&lt;Warning&gt;&para;<br>The bash tool provides direct system access. Implement these essential safety measures:&para;<br>- Running in isolated environments (Docker/VM)&para;<br>- Implementing command filtering and allowlists&para;<br>- Setting resource limits (CPU, memory, disk)&para;<br>- Logging all executed commands&para;<br>&lt;/Warning&gt;&para;<br>&para;<br>### Key recommendations&para;<br>- Use `ulimit` to set resource constraints&para;<br>- Filter dangerous commands (`sudo`, `rm -rf`, etc.)&para;<br>- Run with minimal user permissions&para;<br>- Monitor and log all command execution&para;<br>&para;<br>## Pricing&para;<br>&para;<br>The bash tool adds **245 input tokens** to your API calls.&para;<br>&para;<br>Additional tokens are consumed by:&para;<br>- Command outputs (stdout/stderr)&para;<br>- Error messages&para;<br>- Large file contents&para;<br>&para;<br>See [tool use pricing](/docs/en/agents-and-tools/tool-use/overview#pricing) for complete pricing details.&para;<br>&para;<br>## Common patterns&para;<br>&para;<br>### Development workflows&para;<br>- Running tests: `pytest &amp;&amp; coverage report`&para;<br>- Building projects: `npm install &amp;&amp; npm run build`&para;<br>- Git operations: `git status &amp;&amp; git add . &amp;&amp; git commit -m "message"`&para;<br>&para;<br>### File operations&para;<br>- Processing data: `wc -l *.csv &amp;&amp; ls -lh *.csv`&para;<br>- Searching files: `find . -name "*.py" | xargs grep "pattern"`&para;<br>- Creating backups: `tar -czf backup.tar.gz ./data`&para;<br>&para;<br>### System tasks&para;<br>- Checking resources: `df -h &amp;&amp; free -m`&para;<br>- Process management: `ps aux | grep python`&para;<br>- Environment setup: `export PATH=$PATH:/new/path &amp;&amp; echo $PATH`&para;<br>&para;<br>## Limitations&para;<br>&para;<br>- **No interactive commands**: Cannot handle `vim`, `less`, or password prompts&para;<br>- **No GUI applications**: Command-line only&para;<br>- **Session scope**: Persists within conversation, lost between API calls&para;<br>- **Output limits**: Large outputs may be truncated&para;<br>- **No streaming**: Results returned after completion&para;<br>&para;<br>## Combining with other tools&para;<br>&para;<br>The bash tool is most powerful when combined with the [text editor](/docs/en/agents-and-tools/tool-use/text-editor-tool) and other tools.&para;<br>&para;<br>## Next steps&para;<br>&para;<br>&lt;CardGroup cols={2}&gt;&para;<br>  &lt;Card&para;<br>    title="Tool use overview"&para;<br>    icon="tool"&para;<br>    href="/docs/en/agents-and-tools/tool-use/overview"&para;<br>  &gt;&para;<br>    Learn about tool use with Claude&para;<br>  &lt;/Card&gt;&para;<br>&para;<br>  &lt;Card&para;<br>    title="Text editor tool"&para;<br>    icon="file"&para;<br>    href="/docs/en/agents-and-tools/tool-use/text-editor-tool"&para;<br>  &gt;&para;<br>    View and edit text files with Claude&para;<br>  &lt;/Card&gt;&para;<br>&lt;/CardGroup&gt;</ins></div>
        </div>

        <h2 style="margin-top: 2rem; margin-bottom: 1rem;">Unified Diff</h2>
        <pre><code>--- a/agents-and-tools/tool-use/bash-tool.md
+++ b/agents-and-tools/tool-use/bash-tool.md
@@ -0,0 +1,428 @@
+# Bash tool
+
+---
+
+The bash tool enables Claude to execute shell commands in a persistent bash session, allowing system operations, script execution, and command-line automation.
+
+## Overview
+
+The bash tool provides Claude with:
+- Persistent bash session that maintains state
+- Ability to run any shell command
+- Access to environment variables and working directory
+- Command chaining and scripting capabilities
+
+## Model compatibility
+
+| Model | Tool Version |
+|-------|--------------|
+| Claude 4 models and Sonnet 3.7 ([deprecated](/docs/en/about-claude/model-deprecations)) | `bash_20250124` |
+
+&lt;Warning&gt;
+Older tool versions are not guaranteed to be backwards-compatible with newer models. Always use the tool version that corresponds to your model version.
+&lt;/Warning&gt;
+
+## Use cases
+
+- **Development workflows**: Run build commands, tests, and development tools
+- **System automation**: Execute scripts, manage files, automate tasks
+- **Data processing**: Process files, run analysis scripts, manage datasets
+- **Environment setup**: Install packages, configure environments
+
+## Quick start
+
+&lt;CodeGroup&gt;
+```python Python
+import anthropic
+
+client = anthropic.Anthropic()
+
+response = client.messages.create(
+    model=&#34;claude-sonnet-4-5&#34;,
+    max_tokens=1024,
+    tools=[
+        {
+            &#34;type&#34;: &#34;bash_20250124&#34;,
+            &#34;name&#34;: &#34;bash&#34;
+        }
+    ],
+    messages=[
+        {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;List all Python files in the current directory.&#34;}
+    ]
+)
+```
+
+```bash Shell
+curl https://api.anthropic.com/v1/messages \
+  -H &#34;content-type: application/json&#34; \
+  -H &#34;x-api-key: $ANTHROPIC_API_KEY&#34; \
+  -H &#34;anthropic-version: 2023-06-01&#34; \
+  -d &#39;{
+    &#34;model&#34;: &#34;claude-sonnet-4-5&#34;,
+    &#34;max_tokens&#34;: 1024,
+    &#34;tools&#34;: [
+      {
+        &#34;type&#34;: &#34;bash_20250124&#34;,
+        &#34;name&#34;: &#34;bash&#34;
+      }
+    ],
+    &#34;messages&#34;: [
+      {
+        &#34;role&#34;: &#34;user&#34;,
+        &#34;content&#34;: &#34;List all Python files in the current directory.&#34;
+      }
+    ]
+  }&#39;
+```
+&lt;/CodeGroup&gt;
+
+## How it works
+
+The bash tool maintains a persistent session:
+
+1. Claude determines what command to run
+2. You execute the command in a bash shell
+3. Return the output (stdout and stderr) to Claude
+4. Session state persists between commands (environment variables, working directory)
+
+## Parameters
+
+| Parameter | Required | Description |
+|-----------|----------|-------------|
+| `command` | Yes* | The bash command to run |
+| `restart` | No | Set to `true` to restart the bash session |
+
+*Required unless using `restart`
+
+&lt;section title=&#34;Example usage&#34;&gt;
+
+```json
+// Run a command
+{
+  &#34;command&#34;: &#34;ls -la *.py&#34;
+}
+
+// Restart the session
+{
+  &#34;restart&#34;: true
+}
+```
+
+&lt;/section&gt;
+
+## Example: Multi-step automation
+
+Claude can chain commands to complete complex tasks:
+
+```python
+# User request
+&#34;Install the requests library and create a simple Python script that fetches a joke from an API, then run it.&#34;
+
+# Claude&#39;s tool uses:
+# 1. Install package
+{&#34;command&#34;: &#34;pip install requests&#34;}
+
+# 2. Create script
+{&#34;command&#34;: &#34;cat &gt; fetch_joke.py &lt;&lt; &#39;EOF&#39;\nimport requests\nresponse = requests.get(&#39;https://official-joke-api.appspot.com/random_joke&#39;)\njoke = response.json()\nprint(f\&#34;Setup: {joke[&#39;setup&#39;]}\&#34;)\nprint(f\&#34;Punchline: {joke[&#39;punchline&#39;]}\&#34;)\nEOF&#34;}
+
+# 3. Run script
+{&#34;command&#34;: &#34;python fetch_joke.py&#34;}
+```
+
+The session maintains state between commands, so files created in step 2 are available in step 3.
+
+***
+
+## Implement the bash tool
+
+The bash tool is implemented as a schema-less tool. When using this tool, you don&#39;t need to provide an input schema as with other tools; the schema is built into Claude&#39;s model and can&#39;t be modified.
+
+&lt;Steps&gt;
+  &lt;Step title=&#34;Set up a bash environment&#34;&gt;
+    Create a persistent bash session that Claude can interact with:
+    ```python
+    import subprocess
+    import threading
+    import queue
+    
+    class BashSession:
+        def __init__(self):
+            self.process = subprocess.Popen(
+                [&#39;/bin/bash&#39;],
+                stdin=subprocess.PIPE,
+                stdout=subprocess.PIPE,
+                stderr=subprocess.PIPE,
+                text=True,
+                bufsize=0
+            )
+            self.output_queue = queue.Queue()
+            self.error_queue = queue.Queue()
+            self._start_readers()
+    ```
+  &lt;/Step&gt;
+  &lt;Step title=&#34;Handle command execution&#34;&gt;
+    Create a function to execute commands and capture output:
+    ```python
+    def execute_command(self, command):
+        # Send command to bash
+        self.process.stdin.write(command + &#39;\n&#39;)
+        self.process.stdin.flush()
+        
+        # Capture output with timeout
+        output = self._read_output(timeout=10)
+        return output
+    ```
+  &lt;/Step&gt;
+  &lt;Step title=&#34;Process Claude&#39;s tool calls&#34;&gt;
+    Extract and execute commands from Claude&#39;s responses:
+    ```python
+    for content in response.content:
+        if content.type == &#34;tool_use&#34; and content.name == &#34;bash&#34;:
+            if content.input.get(&#34;restart&#34;):
+                bash_session.restart()
+                result = &#34;Bash session restarted&#34;
+            else:
+                command = content.input.get(&#34;command&#34;)
+                result = bash_session.execute_command(command)
+            
+            # Return result to Claude
+            tool_result = {
+                &#34;type&#34;: &#34;tool_result&#34;,
+                &#34;tool_use_id&#34;: content.id,
+                &#34;content&#34;: result
+            }
+    ```
+  &lt;/Step&gt;
+  &lt;Step title=&#34;Implement safety measures&#34;&gt;
+    Add validation and restrictions:
+    ```python
+    def validate_command(command):
+        # Block dangerous commands
+        dangerous_patterns = [&#39;rm -rf /&#39;, &#39;format&#39;, &#39;:(){:|:&amp;};:&#39;]
+        for pattern in dangerous_patterns:
+            if pattern in command:
+                return False, f&#34;Command contains dangerous pattern: {pattern}&#34;
+        
+        # Add more validation as needed
+        return True, None
+    ```
+  &lt;/Step&gt;
+&lt;/Steps&gt;
+
+### Handle errors
+
+When implementing the bash tool, handle various error scenarios:
+
+&lt;section title=&#34;Command execution timeout&#34;&gt;
+
+If a command takes too long to execute:
+
+```json
+{
+  &#34;role&#34;: &#34;user&#34;,
+  &#34;content&#34;: [
+    {
+      &#34;type&#34;: &#34;tool_result&#34;,
+      &#34;tool_use_id&#34;: &#34;toolu_01A09q90qw90lq917835lq9&#34;,
+      &#34;content&#34;: &#34;Error: Command timed out after 30 seconds&#34;,
+      &#34;is_error&#34;: true
+    }
+  ]
+}
+```
+
+&lt;/section&gt;
+
+&lt;section title=&#34;Command not found&#34;&gt;
+
+If a command doesn&#39;t exist:
+
+```json
+{
+  &#34;role&#34;: &#34;user&#34;,
+  &#34;content&#34;: [
+    {
+      &#34;type&#34;: &#34;tool_result&#34;,
+      &#34;tool_use_id&#34;: &#34;toolu_01A09q90qw90lq917835lq9&#34;,
+      &#34;content&#34;: &#34;bash: nonexistentcommand: command not found&#34;,
+      &#34;is_error&#34;: true
+    }
+  ]
+}
+```
+
+&lt;/section&gt;
+
+&lt;section title=&#34;Permission denied&#34;&gt;
+
+If there are permission issues:
+
+```json
+{
+  &#34;role&#34;: &#34;user&#34;,
+  &#34;content&#34;: [
+    {
+      &#34;type&#34;: &#34;tool_result&#34;,
+      &#34;tool_use_id&#34;: &#34;toolu_01A09q90qw90lq917835lq9&#34;,
+      &#34;content&#34;: &#34;bash: /root/sensitive-file: Permission denied&#34;,
+      &#34;is_error&#34;: true
+    }
+  ]
+}
+```
+
+&lt;/section&gt;
+
+### Follow implementation best practices
+
+&lt;section title=&#34;Use command timeouts&#34;&gt;
+
+Implement timeouts to prevent hanging commands:
+```python
+def execute_with_timeout(command, timeout=30):
+    try:
+        result = subprocess.run(
+            command, 
+            shell=True, 
+            capture_output=True, 
+            text=True, 
+            timeout=timeout
+        )
+        return result.stdout + result.stderr
+    except subprocess.TimeoutExpired:
+        return f&#34;Command timed out after {timeout} seconds&#34;
+```
+
+&lt;/section&gt;
+
+&lt;section title=&#34;Maintain session state&#34;&gt;
+
+Keep the bash session persistent to maintain environment variables and working directory:
+```python
+# Commands run in the same session maintain state
+commands = [
+    &#34;cd /tmp&#34;,
+    &#34;echo &#39;Hello&#39; &gt; test.txt&#34;,
+    &#34;cat test.txt&#34;  # This works because we&#39;re still in /tmp
+]
+```
+
+&lt;/section&gt;
+
+&lt;section title=&#34;Handle large outputs&#34;&gt;
+
+Truncate very large outputs to prevent token limit issues:
+```python
+def truncate_output(output, max_lines=100):
+    lines = output.split(&#39;\n&#39;)
+    if len(lines) &gt; max_lines:
+        truncated = &#39;\n&#39;.join(lines[:max_lines])
+        return f&#34;{truncated}\n\n... Output truncated ({len(lines)} total lines) ...&#34;
+    return output
+```
+
+&lt;/section&gt;
+
+&lt;section title=&#34;Log all commands&#34;&gt;
+
+Keep an audit trail of executed commands:
+```python
+import logging
+
+def log_command(command, output, user_id):
+    logging.info(f&#34;User {user_id} executed: {command}&#34;)
+    logging.info(f&#34;Output: {output[:200]}...&#34;)  # Log first 200 chars
+```
+
+&lt;/section&gt;
+
+&lt;section title=&#34;Sanitize outputs&#34;&gt;
+
+Remove sensitive information from command outputs:
+```python
+def sanitize_output(output):
+    # Remove potential secrets or credentials
+    import re
+    # Example: Remove AWS credentials
+    output = re.sub(r&#39;aws_access_key_id\s*=\s*\S+&#39;, &#39;aws_access_key_id=***&#39;, output)
+    output = re.sub(r&#39;aws_secret_access_key\s*=\s*\S+&#39;, &#39;aws_secret_access_key=***&#39;, output)
+    return output
+```
+
+&lt;/section&gt;
+
+## Security
+
+&lt;Warning&gt;
+The bash tool provides direct system access. Implement these essential safety measures:
+- Running in isolated environments (Docker/VM)
+- Implementing command filtering and allowlists
+- Setting resource limits (CPU, memory, disk)
+- Logging all executed commands
+&lt;/Warning&gt;
+
+### Key recommendations
+- Use `ulimit` to set resource constraints
+- Filter dangerous commands (`sudo`, `rm -rf`, etc.)
+- Run with minimal user permissions
+- Monitor and log all command execution
+
+## Pricing
+
+The bash tool adds **245 input tokens** to your API calls.
+
+Additional tokens are consumed by:
+- Command outputs (stdout/stderr)
+- Error messages
+- Large file contents
+
+See [tool use pricing](/docs/en/agents-and-tools/tool-use/overview#pricing) for complete pricing details.
+
+## Common patterns
+
+### Development workflows
+- Running tests: `pytest &amp;&amp; coverage report`
+- Building projects: `npm install &amp;&amp; npm run build`
+- Git operations: `git status &amp;&amp; git add . &amp;&amp; git commit -m &#34;message&#34;`
+
+### File operations
+- Processing data: `wc -l *.csv &amp;&amp; ls -lh *.csv`
+- Searching files: `find . -name &#34;*.py&#34; | xargs grep &#34;pattern&#34;`
+- Creating backups: `tar -czf backup.tar.gz ./data`
+
+### System tasks
+- Checking resources: `df -h &amp;&amp; free -m`
+- Process management: `ps aux | grep python`
+- Environment setup: `export PATH=$PATH:/new/path &amp;&amp; echo $PATH`
+
+## Limitations
+
+- **No interactive commands**: Cannot handle `vim`, `less`, or password prompts
+- **No GUI applications**: Command-line only
+- **Session scope**: Persists within conversation, lost between API calls
+- **Output limits**: Large outputs may be truncated
+- **No streaming**: Results returned after completion
+
+## Combining with other tools
+
+The bash tool is most powerful when combined with the [text editor](/docs/en/agents-and-tools/tool-use/text-editor-tool) and other tools.
+
+## Next steps
+
+&lt;CardGroup cols={2}&gt;
+  &lt;Card
+    title=&#34;Tool use overview&#34;
+    icon=&#34;tool&#34;
+    href=&#34;/docs/en/agents-and-tools/tool-use/overview&#34;
+  &gt;
+    Learn about tool use with Claude
+  &lt;/Card&gt;
+
+  &lt;Card
+    title=&#34;Text editor tool&#34;
+    icon=&#34;file&#34;
+    href=&#34;/docs/en/agents-and-tools/tool-use/text-editor-tool&#34;
+  &gt;
+    View and edit text files with Claude
+  &lt;/Card&gt;
+&lt;/CardGroup&gt;</code></pre>
    </div>
</body>
</html>