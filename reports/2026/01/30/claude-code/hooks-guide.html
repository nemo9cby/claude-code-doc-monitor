<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hooks-guide - Diff Report</title>
    <link rel="stylesheet" href="../../css/diff.css">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --card-bg: #16213e;
            --text-color: #eee;
            --accent: #0f3460;
            --add-bg: #1a4d1a;
            --del-bg: #4d1a1a;
            --add-text: #4ade80;
            --del-text: #f87171;
        }
        @media (prefers-color-scheme: light) {
            :root {
                --bg-color: #f5f5f5;
                --card-bg: #fff;
                --text-color: #333;
                --accent: #e0e0e0;
                --add-bg: #d4edda;
                --del-bg: #f8d7da;
                --add-text: #155724;
                --del-text: #721c24;
            }
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 2rem;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        header { margin-bottom: 2rem; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .meta { color: #888; font-size: 0.9rem; }
        .summary {
            background: var(--card-bg);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            display: flex;
            gap: 2rem;
        }
        .stat { display: flex; align-items: center; gap: 0.5rem; }
        .stat.added { color: var(--add-text); }
        .stat.removed { color: var(--del-text); }
        .analysis {
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            border-left: 4px solid #8b5cf6;
        }
        .analysis-header {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #8b5cf6;
        }
        .analysis-content {
            white-space: pre-wrap;
            font-size: 0.95rem;
            line-height: 1.7;
        }
        .diff-container {
            background: var(--card-bg);
            border-radius: 8px;
            overflow: hidden;
        }
        .diff-header {
            background: var(--accent);
            padding: 0.75rem 1rem;
            font-weight: 600;
        }
        .diff-content {
            padding: 1rem;
            overflow-x: auto;
        }
        .diff-content ins {
            background: var(--add-bg);
            color: var(--add-text);
            text-decoration: none;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        .diff-content del {
            background: var(--del-bg);
            color: var(--del-text);
            text-decoration: line-through;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        pre {
            background: var(--accent);
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.85rem;
            margin-top: 2rem;
        }
        a { color: #60a5fa; }
        .back-link { margin-bottom: 1rem; display: inline-block; }
    </style>
</head>
<body>
    <div class="container">
        <a href="../index.html" class="back-link">&larr; Back to daily report</a>

        <header>
            <h1>hooks-guide.md</h1>
            <p class="meta">Changed on 2026-01-30 23:01:27 EST</p>
        </header>

        <div class="summary">
            <div class="stat added">
                <span>+270</span> lines added
            </div>
            <div class="stat removed">
                <span>-170</span> lines removed
            </div>
        </div>

        

        <div class="diff-container">
            <div class="diff-header">Visual Diff</div>
            <div class="diff-content"><span>&gt; ## Documentation Index&para;<br>&gt; Fetch the complete documentation index at: https://code.claude.com/docs/llms.txt&para;<br>&gt; Use this file to discover all available pages before exploring further.&para;<br>&para;<br># </span><del style="background:#ffe6e6;">Get started with Claude Code hooks&para;<br>&para;<br>&gt; Learn how to customize and extend Claude Code's behavior by registering shell commands&para;<br>&para;<br>Claude Code hooks are user-defined shell commands that execute at various points&para;<br>in Claude Code's lifecycle. Hooks provide deterministic control over Claude&para;<br>Code's behavior, ensuring certain actions always happen rather than relying on&para;<br>the LLM to choose to run them.&para;<br>&para;<br>&lt;Tip&gt;&para;<br>  For reference documentation on hooks, see [Hooks reference](/en/hooks).&para;<br>&lt;/Tip&gt;&para;<br>&para;<br>Example use cases for hooks include:&para;<br>&para;<br>* **Notifications**: Customize how you get notified when Claude Code is awaiting&para;<br>  your input or permission to run something.&para;<br>* **Automatic formatting**: Run `prettier` on .ts files, `gofmt` on .go files,&para;<br>  etc. after every file edit.&para;<br>* **Logging**: Track and count all executed commands for compliance or&para;<br>  debugging.&para;<br>* **Feedback**: Provide automated feedback when Claude Code produces code that&para;<br>  does not follow your codebase conventions.&para;<br>* **Custom permissions**: Block modifications to production files or sensitive&para;<br>  directories.&para;<br>&para;<br>By encoding these rules as hooks rather than prompting instructions, you turn&para;<br>suggestions into app-level code that executes every time it is expected to run.&para;<br>&para;<br>&lt;Warning&gt;&para;<br>  You must consider the security implication of hooks as you add them, because hooks run automatically during the agent loop with your current environment's credentials.&para;<br>  For example, malicious hooks code can exfiltrate your data. Always review your hooks implementation before registering them.&para;<br>&para;<br>  For full security best practices, see [Security Considerations](/en/hooks#security-considerations) in the hooks reference documentation.&para;<br>&lt;/Warning&gt;&para;<br>&para;<br>## Hook Events Overview&para;<br>&para;<br>Claude Code provides several hook events that run at different points in the&para;<br>workflow:&para;<br>&para;<br>* **PreToolUse**: Runs before tool calls (can block them)&para;<br>* **PermissionRequest**: Runs when a permission dialog is shown (can allow or deny)&para;<br>* **PostToolUse**: Runs after tool calls complete&para;<br>* **UserPromptSubmit**: Runs when the user submits a prompt, before Claude processes it&para;<br>* **Notification**: Runs when Claude Code sends notifications&para;<br>* **Stop**: Runs when Claude Code finishes responding&para;<br>* **SubagentStop**: Runs when subagent tasks complete&para;<br>* **PreCompact**: Runs before Claude Code is about to run a compact operation&para;<br>* **Setup**: Runs when Claude Code is invoked with `--init`, `--init-only`, or `--maintenance` flags&para;<br>* **SessionStart**: Runs when Claude Code starts a new session or resumes an existing session&para;<br>* **SessionEnd**: Runs when Claude Code session ends&para;<br>&para;<br>Each event receives different data and can control Claude's behavior in&para;<br>different ways.&para;<br>&para;<br>## Quickstart&para;<br>&para;<br>In this quickstart, you'll add a hook that logs the shell commands that Claude&para;<br>Code runs.&para;<br>&para;<br>### Prerequisites&para;<br>&para;<br>Install `jq` for JSON processing in the command line.&para;<br>&para;<br>### Step 1: Open hooks configuration&para;<br>&para;<br>Run the `/hooks` command and select&para;<br>the `PreToolUse` hook event.&para;<br>&para;<br>`PreToolUse` hooks run before tool calls and can block them while providing&para;<br>Claude feedback on what to do differently.&para;<br>&para;<br>### Step 2: Add a matcher&para;<br>&para;<br>Select `+ Add new matcher…` to run your hook only on Bash tool calls.&para;<br>&para;<br>Type `Bash` for the matcher.&para;<br>&para;<br>&lt;Note&gt;You can use `*` to match all tools.&lt;/Note&gt;&para;<br>&para;<br>### Step 3: Add the hook&para;<br>&para;<br>Select `+ Add new hook…` and enter this command:&para;<br>&para;<br>```bash  theme={null}&para;<br>jq -r '"\(.tool_input.command) - \(.tool_input.description // "No description")"' &gt;&gt; ~/.claude/bash-command-log.txt&para;<br>```&para;<br>&para;<br>### Step 4: Save your configuration&para;<br>&para;<br>For storage location, select `User settings` since you're logging to your home&para;<br>directory. This hook will then apply to all projects, not just your current&para;<br>project.&para;<br>&para;<br>Then press `Esc` until you return to the REPL. Your hook is now registered.&para;<br>&para;<br>### Step 5: Verify your hook&para;<br>&para;<br>Run `/hooks` again or check `~/.claude/settings.json` to see your configuration:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PreToolUse": [&para;<br>      {&para;<br>        "matcher": "Bash",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "jq -r '\"\\(.tool_input.command) - \\(.tool_input.description // \"No description\")\"' &gt;&gt; ~/.claude/bash-command-log.txt"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### Step 6: Test your hook&para;<br>&para;<br>Ask Claude to run a simple command like `ls` and check your log file:&para;<br>&para;<br>```bash  theme={null}&para;<br>cat ~/.claude/bash-command-log.txt&para;<br>```&para;<br>&para;<br>You should see entries like:&para;<br>&para;<br>```&para;<br>ls - Lists files and directories&para;<br>```&para;<br>&para;<br>## More Examples&para;<br>&para;<br>&lt;Note&gt;&para;<br>  For a complete example implementation, see the [bash command validator example](https://github.com/anthropics/claude-code/blob/main/examples/hooks/bash_command_validator_example.py) in our public codebase.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>### Code Formatting Hook&para;<br>&para;<br>Automatically format TypeScript files after editing:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PostToolUse": [&para;<br>      {&para;<br>        "matcher": "Edit|Write",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "jq -r '.tool_input.file_path' | { read file_path; if echo \"$file_path\" | grep -q '\\.ts$'; then npx prettier --write \"$file_path\"; fi; }"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### Markdown Formatting Hook&para;<br>&para;<br>Automatically fix missing language tags and formatting issues in markdown files:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PostToolUse": [&para;<br>      {&para;<br>        "matcher": "Edit|Write",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/markdown_formatter.py"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>Create `.claude/hooks/markdown_formatter.py` with this content:&para;<br>&para;<br>````python  theme={null}&para;<br>#!/usr/bin/env python3&para;<br>"""&para;<br>Markdown formatter for Claude Code output.&para;<br>Fixes missing language tags and spacing issues while preserving code content.&para;<br>"""&para;<br>import json&para;<br>import sys&para;<br>import re&para;<br>import os&para;<br>&para;<br>def detect_language(code):&para;<br>    """Best-effort language detection from code content."""&para;<br>    s = code.strip()&para;<br>    &para;<br>    # JSON detection&para;<br>    if re.search(r'^\s*[{\[]', s):&para;<br>        try:&para;<br>            json.loads(s)&para;<br>            return 'json'&para;<br>        except:&para;<br>            pass&para;<br>    &para;<br>    # Python detection&para;<br>    if re.search(r'^\s*def\s+\w+\s*\(', s, re.M) or \&para;<br>       re.search(r'^\s*(import|from)\s+\w+', s, re.M):&para;<br>        return 'python'&para;<br>    &para;<br>    # JavaScript detection  &para;<br>    if re.search(r'\b(function\s+\w+\s*\(|const\s+\w+\s*=)', s) or \&para;<br>       re.search(r'=&gt;|console\.(log|error)', s):&para;<br>        return 'javascript'&para;<br>    &para;<br>    # Bash detection&para;<br>    if re.search(r'^#!.*\b(bash|sh)\b', s, re.M) or \&para;<br>       re.search(r'\b(if|then|fi|for|in|do|done)\b', s):&para;<br>        return 'bash'&para;<br>    &para;<br>    # SQL detection&para;<br>    if re.search(r'\b(SELECT|INSERT|UPDATE|DELETE|CREATE)\s+', s, re.I):&para;<br>        return 'sql'&para;<br>        &para;<br>    return 'text'&para;<br>&para;<br>def format_markdown(content):&para;<br>    """Format markdown content with language detection."""&para;<br>    # Fix unlabeled code fences&para;<br>    def add_lang_to_fence(match):&para;<br>        indent, info, body, closing = match.groups()&para;<br>        if not info.strip():&para;<br>            lang = detect_language(body)&para;<br>            return f"{indent}```{lang}\n{body}{closing}\n"&para;<br>        return match.group(0)&para;<br>    &para;<br>    fence_pattern = r'(?ms)^([ \t]{0,3})```([^\n]*)\n(.*?)(\n\1```)\s*$'&para;<br>    content = re.sub(fence_pattern, add_lang_to_fence, content)&para;<br>    &para;<br>    # Fix excessive blank lines (only outside code fences)&para;<br>    content = re.sub(r'\n{3,}', '\n\n', content)&para;<br>    &para;<br>    return content.rstrip() + '\n'&para;<br>&para;<br># Main execution&para;<br>try:&para;<br>    input_data = json.load(sys.stdin)&para;<br>    file_path = input_data.get('tool_input', {}).get('file_path', '')&para;<br>    &para;<br>    if not file_path.endswith(('.md', '.mdx')):&para;<br>        sys.exit(0)  # Not a markdown file&para;<br>    &para;<br>    if os.path.exists(file_path):&para;<br>        with open(file_path, 'r', encoding='utf-8') as f:&para;<br>            content = f.read()&para;<br>        &para;<br>        formatted = format_markdown(content)&para;<br>        &para;<br>        if formatted != content:&para;<br>            with open(file_path, 'w', encoding='utf-8') as f:&para;<br>                f.write(formatted)&para;<br>            print(f"✓ Fixed markdown formatting in {file_path}")&para;<br>    &para;<br>except Exception as e:&para;<br>    print(f"Error formatting markdown: {e}", file=sys.stderr)&para;<br>    sys.exit(1)&para;<br>````&para;<br>&para;<br>Make the script executable:&para;<br>&para;<br>```bash  theme={null}&para;<br>chmod +x .claude/hooks/markdown_formatter.py&para;<br>```&para;<br>&para;<br>This hook automatically:&para;<br>&para;<br>* Detects programming languages in unlabeled code blocks&para;<br>* Adds appropriate language tags for syntax highlighting&para;<br>* Fixes excessive blank lines while preserving code content&para;<br>* Only processes markdown files (`.md`, `.mdx`)&para;<br>&para;<br>### Custom Notification Hook&para;<br>&para;<br>Get desktop notifications when Claude needs input:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "Notification": [&para;<br>      {&para;<br>        "matcher": "",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "notify-send 'Claude Code' 'Awaiting your input'"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### File Protection Hook&para;<br>&para;<br>Block edits to sensitive files:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PreToolUse": [&para;<br>      {&para;<br>        "matcher": "Edit|Write",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "python3 -c \"import json, sys; data=json.load(sys.stdin); path=data.get('tool_input',{}).get('file_path',''); sys.exit(2 if any(p in path for p in ['.env', 'package-lock.json', '.git/']) else 0)\""&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>## Learn more&para;<br>&para;<br>* For reference documentation on hooks, see [Hooks reference](/en/hooks).&para;<br>* For comprehensive security best practices and safety guidelines, see [Security Considerations](/en/hooks#security-considerations) in the hooks reference documentation.&para;<br>* For troubleshooting steps and debugging techniques, see [Debugging](/en/hooks#debugging) in the hooks reference&para;<br>  documentation.</del><ins style="background:#e6ffe6;">Automate workflows with hooks&para;<br>&para;<br>&gt; Run shell commands automatically when Claude Code edits files, finishes tasks, or needs input. Format code, send notifications, validate commands, and enforce project rules.&para;<br>&para;<br>Hooks are user-defined shell commands that execute at specific points in Claude Code's lifecycle. They provide deterministic control over Claude Code's behavior, ensuring certain actions always happen rather than relying on the LLM to choose to run them. Use hooks to enforce project rules, automate repetitive tasks, and integrate Claude Code with your existing tools.&para;<br>&para;<br>For decisions that require judgment rather than deterministic rules, you can also use [prompt-based hooks](#prompt-based-hooks) or [agent-based hooks](#agent-based-hooks) that use a Claude model to evaluate conditions.&para;<br>&para;<br>For other ways to extend Claude Code, see [skills](/en/skills) for giving Claude additional instructions and executable commands, [subagents](/en/sub-agents) for running tasks in isolated contexts, and [plugins](/en/plugins) for packaging extensions to share across projects.&para;<br>&para;<br>&lt;Tip&gt;&para;<br>  This guide covers common use cases and how to get started. For full event schemas, JSON input/output formats, and advanced features like async hooks and MCP tool hooks, see the [Hooks reference](/en/hooks).&para;<br>&lt;/Tip&gt;&para;<br>&para;<br>## Set up your first hook&para;<br>&para;<br>The fastest way to create a hook is through the `/hooks` interactive menu in Claude Code. This walkthrough creates a desktop notification hook, so you get alerted whenever Claude is waiting for your input instead of watching the terminal.&para;<br>&para;<br>&lt;Steps&gt;&para;<br>  &lt;Step title="Open the hooks menu"&gt;&para;<br>    Type `/hooks` in the Claude Code CLI. You'll see a list of all available hook events, plus an option to disable all hooks. Each event corresponds to a point in Claude's lifecycle where you can run custom code. Select `Notification` to create a hook that fires when Claude needs your attention.&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Configure the matcher"&gt;&para;<br>    The menu shows a list of matchers, which filter when the hook fires. Set the matcher to `*` to fire on all notification types. You can narrow it later by changing the matcher to a specific value like `permission_prompt` or `idle_prompt`.&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Add your command"&gt;&para;<br>    Select `+ Add new hook…`. The menu prompts you for a shell command to run when the event fires. Hooks run any shell command you provide, so you can use your platform's built-in notification tool. Copy the command for your OS:&para;<br>&para;<br>    &lt;Tabs&gt;&para;<br>      &lt;Tab title="macOS"&gt;&para;<br>        Uses [`osascript`](https://ss64.com/mac/osascript.html) to trigger a native macOS notification through AppleScript:&para;<br>&para;<br>        ```&para;<br>        osascript -e 'display notification "Claude Code needs your attention" with title "Claude Code"'&para;<br>        ```&para;<br>      &lt;/Tab&gt;&para;<br>&para;<br>      &lt;Tab title="Linux"&gt;&para;<br>        Uses `notify-send`, which is pre-installed on most Linux desktops with a notification daemon:&para;<br>&para;<br>        ```&para;<br>        notify-send 'Claude Code' 'Claude Code needs your attention'&para;<br>        ```&para;<br>      &lt;/Tab&gt;&para;<br>&para;<br>      &lt;Tab title="Windows (PowerShell)"&gt;&para;<br>        Uses PowerShell to show a native message box through .NET's Windows Forms:&para;<br>&para;<br>        ```&para;<br>        powershell.exe -Command "[System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms'); [System.Windows.Forms.MessageBox]::Show('Claude Code needs your attention', 'Claude Code')"&para;<br>        ```&para;<br>      &lt;/Tab&gt;&para;<br>    &lt;/Tabs&gt;&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Choose a storage location"&gt;&para;<br>    The menu asks where to save the hook configuration. Select `User settings` to store it in `~/.claude/settings.json`, which applies the hook to all your projects. You could also choose `Project settings` to scope it to the current project. See [Configure hook location](#configure-hook-location) for all available scopes.&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Test the hook"&gt;&para;<br>    Press `Esc` to return to the CLI. Ask Claude to do something that requires permission, then switch away from the terminal. You should receive a desktop notification.&para;<br>  &lt;/Step&gt;&para;<br>&lt;/Steps&gt;&para;<br>&para;<br>## What you can automate&para;<br>&para;<br>Hooks let you run code at key points in Claude Code's lifecycle: format files after edits, block commands before they execute, send notifications when Claude needs input, inject context at session start, and more. For the full list of hook events, see the [Hooks reference](/en/hooks#hook-lifecycle).&para;<br>&para;<br>Each example includes a ready-to-use configuration block that you add to a [settings file](#configure-hook-location). The most common patterns:&para;<br>&para;<br>* [Get notified when Claude needs input](#get-notified-when-claude-needs-input)&para;<br>* [Auto-format code after edits](#auto-format-code-after-edits)&para;<br>* [Block edits to protected files](#block-edits-to-protected-files)&para;<br>* [Re-inject context after compaction](#re-inject-context-after-compaction)&para;<br>&para;<br>### Get notified when Claude needs input&para;<br>&para;<br>Get a desktop notification whenever Claude finishes working and needs your input, so you can switch to other tasks without checking the terminal.&para;<br>&para;<br>This hook uses the `Notification` event, which fires when Claude is waiting for input or permission. Each tab below uses the platform's native notification command. Add this to `~/.claude/settings.json`, or use the [interactive walkthrough](#set-up-your-first-hook) above to configure it with `/hooks`:&para;<br>&para;<br>&lt;Tabs&gt;&para;<br>  &lt;Tab title="macOS"&gt;&para;<br>    ```json  theme={null}&para;<br>    {&para;<br>      "hooks": {&para;<br>        "Notification": [&para;<br>          {&para;<br>            "matcher": "",&para;<br>            "hooks": [&para;<br>              {&para;<br>                "type": "command",&para;<br>                "command": "osascript -e 'display notification \"Claude Code needs your attention\" with title \"Claude Code\"'"&para;<br>              }&para;<br>            ]&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    }&para;<br>    ```&para;<br>  &lt;/Tab&gt;&para;<br>&para;<br>  &lt;Tab title="Linux"&gt;&para;<br>    ```json  theme={null}&para;<br>    {&para;<br>      "hooks": {&para;<br>        "Notification": [&para;<br>          {&para;<br>            "matcher": "",&para;<br>            "hooks": [&para;<br>              {&para;<br>                "type": "command",&para;<br>                "command": "notify-send 'Claude Code' 'Claude Code needs your attention'"&para;<br>              }&para;<br>            ]&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    }&para;<br>    ```&para;<br>  &lt;/Tab&gt;&para;<br>&para;<br>  &lt;Tab title="Windows (PowerShell)"&gt;&para;<br>    ```json  theme={null}&para;<br>    {&para;<br>      "hooks": {&para;<br>        "Notification": [&para;<br>          {&para;<br>            "matcher": "",&para;<br>            "hooks": [&para;<br>              {&para;<br>                "type": "command",&para;<br>                "command": "powershell.exe -Command \"[System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms'); [System.Windows.Forms.MessageBox]::Show('Claude Code needs your attention', 'Claude Code')\""&para;<br>              }&para;<br>            ]&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    }&para;<br>    ```&para;<br>  &lt;/Tab&gt;&para;<br>&lt;/Tabs&gt;&para;<br>&para;<br>### Auto-format code after edits&para;<br>&para;<br>Automatically run [Prettier](https://prettier.io/) on every file Claude edits, so formatting stays consistent without manual intervention.&para;<br>&para;<br>This hook uses the `PostToolUse` event with an `Edit|Write` matcher, so it runs only after file-editing tools. The command extracts the edited file path with [`jq`](https://jqlang.github.io/jq/) and passes it to Prettier. Add this to `.claude/settings.json` in your project root:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PostToolUse": [&para;<br>      {&para;<br>        "matcher": "Edit|Write",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "jq -r '.tool_input.file_path' | xargs npx prettier --write"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;Note&gt;&para;<br>  The Bash examples on this page use `jq` for JSON parsing. Install it with `brew install jq` (macOS), `apt-get install jq` (Debian/Ubuntu), or see [`jq` downloads](https://jqlang.github.io/jq/download/).&para;<br>&lt;/Note&gt;&para;<br>&para;<br>### Block edits to protected files&para;<br>&para;<br>Prevent Claude from modifying sensitive files like `.env`, `package-lock.json`, or anything in `.git/`. Claude receives feedback explaining why the edit was blocked, so it can adjust its approach.&para;<br>&para;<br>This example uses a separate script file that the hook calls. The script checks the target file path against a list of protected patterns and exits with code 2 to block the edit.&para;<br>&para;<br>&lt;Steps&gt;&para;<br>  &lt;Step title="Create the hook script"&gt;&para;<br>    Save this to `.claude/hooks/protect-files.sh`:&para;<br>&para;<br>    ```bash  theme={null}&para;<br>    #!/bin/bash&para;<br>    # protect-files.sh&para;<br>&para;<br>    INPUT=$(cat)&para;<br>    FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // empty')&para;<br>&para;<br>    PROTECTED_PATTERNS=(".env" "package-lock.json" ".git/")&para;<br>&para;<br>    for pattern in "${PROTECTED_PATTERNS[@]}"; do&para;<br>      if [[ "$FILE_PATH" == *"$pattern"* ]]; then&para;<br>        echo "Blocked: $FILE_PATH matches protected pattern '$pattern'" &gt;&amp;2&para;<br>        exit 2&para;<br>      fi&para;<br>    done&para;<br>&para;<br>    exit 0&para;<br>    ```&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Make the script executable (macOS/Linux)"&gt;&para;<br>    Hook scripts must be executable for Claude Code to run them:&para;<br>&para;<br>    ```bash  theme={null}&para;<br>    chmod +x .claude/hooks/protect-files.sh&para;<br>    ```&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Register the hook"&gt;&para;<br>    Add a `PreToolUse` hook to `.claude/settings.json` that runs the script before any `Edit` or `Write` tool call:&para;<br>&para;<br>    ```json  theme={null}&para;<br>    {&para;<br>      "hooks": {&para;<br>        "PreToolUse": [&para;<br>          {&para;<br>            "matcher": "Edit|Write",&para;<br>            "hooks": [&para;<br>              {&para;<br>                "type": "command",&para;<br>                "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/protect-files.sh"&para;<br>              }&para;<br>            ]&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    }&para;<br>    ```&para;<br>  &lt;/Step&gt;&para;<br>&lt;/Steps&gt;&para;<br>&para;<br>### Re-inject context after compaction&para;<br>&para;<br>When Claude's context window fills up, compaction summarizes the conversation to free space. This can lose important details. Use a `SessionStart` hook with a `compact` matcher to re-inject critical context after every compaction.&para;<br>&para;<br>Any text your command writes to stdout is added to Claude's context. This example reminds Claude of project conventions and recent work. Add this to `.claude/settings.json` in your project root:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "SessionStart": [&para;<br>      {&para;<br>        "matcher": "compact",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "echo 'Reminder: use Bun, not npm. Run bun test before committing. Current sprint: auth refactor.'"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>You can replace the `echo` with any command that produces dynamic output, like `git log --oneline -5` to show recent commits. For injecting context on every session start, consider using [CLAUDE.md](/en/memory) instead. For environment variables, see [`CLAUDE_ENV_FILE`](/en/hooks#persist-environment-variables) in the reference.&para;<br>&para;<br>## How hooks work&para;<br>&para;<br>Hook events fire at specific lifecycle points in Claude Code. When an event fires, all matching hooks run in parallel, and identical hook commands are automatically deduplicated. The table below shows each event and when it triggers:&para;<br>&para;<br>| Event                | When it fires                                        |&para;<br>| :------------------- | :--------------------------------------------------- |&para;<br>| `SessionStart`       | When a session begins or resumes                     |&para;<br>| `UserPromptSubmit`   | When you submit a prompt, before Claude processes it |&para;<br>| `PreToolUse`         | Before a tool call executes. Can block it            |&para;<br>| `PermissionRequest`  | When a permission dialog appears                     |&para;<br>| `PostToolUse`        | After a tool call succeeds                           |&para;<br>| `PostToolUseFailure` | After a tool call fails                              |&para;<br>| `Notification`       | When Claude Code sends a notification                |&para;<br>| `SubagentStart`      | When a subagent is spawned                           |&para;<br>| `SubagentStop`       | When a subagent finishes                             |&para;<br>| `Stop`               | When Claude finishes responding                      |&para;<br>| `PreCompact`         | Before context compaction                            |&para;<br>| `SessionEnd`         | When a session terminates                            |&para;<br>&para;<br>Each hook has a `type` that determines how it runs. Most hooks use `"type": "command"`, which runs a shell command. Two other options use a Claude model to make decisions: `"type": "prompt"` for single-turn evaluation and `"type": "agent"` for multi-turn verification with tool access. See [Prompt-based hooks](#prompt-based-hooks) and [Agent-based hooks](#agent-based-hooks) for details.&para;<br>&para;<br>### Read input and return output&para;<br>&para;<br>Hooks communicate with Claude Code through stdin, stdout, stderr, and exit codes. When an event fires, Claude Code passes event-specific data as JSON to your script's stdin. Your script reads that data, does its work, and tells Claude Code what to do next via the exit code.&para;<br>&para;<br>#### Hook input&para;<br>&para;<br>Every event includes common fields like `session_id` and `cwd`, but each event type adds different data. For example, when Claude runs a Bash command, a `PreToolUse` hook receives something like this on stdin:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",          // unique ID for this session&para;<br>  "cwd": "/Users/sarah/myproject", // working directory when the event fired&para;<br>  "hook_event_name": "PreToolUse", // which event triggered this hook&para;<br>  "tool_name": "Bash",             // the tool Claude is about to use&para;<br>  "tool_input": {                  // the arguments Claude passed to the tool&para;<br>    "command": "npm test"          // for Bash, this is the shell command&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>Your script can parse that JSON and act on any of those fields. `UserPromptSubmit` hooks get the `prompt` text instead, `SessionStart` hooks get the `source` (startup, resume, compact), and so on. See [Common input fields](/en/hooks#common-input-fields) in the reference for shared fields, and each event's section for event-specific schemas.&para;<br>&para;<br>#### Hook output&para;<br>&para;<br>Your script tells Claude Code what to do next by writing to stdout or stderr and exiting with a specific code. For example, a `PreToolUse` hook that wants to block a command:&para;<br>&para;<br>```bash  theme={null}&para;<br>#!/bin/bash&para;<br>INPUT=$(cat)&para;<br>COMMAND=$(echo "$INPUT" | jq -r '.tool_input.command')&para;<br>&para;<br>if echo "$COMMAND" | grep -q "drop table"; then&para;<br>  echo "Blocked: dropping tables is not allowed" &gt;&amp;2  # stderr becomes Claude's feedback&para;<br>  exit 2                                               # exit 2 = block the action&para;<br>fi&para;<br>&para;<br>exit 0  # exit 0 = let it proceed&para;<br>```&para;<br>&para;<br>The exit code determines what happens next:&para;<br>&para;<br>* **Exit 0**: the action proceeds. For `UserPromptSubmit` and `SessionStart` hooks, anything you write to stdout is added to Claude's context.&para;<br>* **Exit 2**: the action is blocked. Write a reason to stderr, and Claude receives it as feedback so it can adjust.&para;<br>* **Any other exit code**: the action proceeds. Stderr is logged but not shown to Claude. Toggle verbose mode with `Ctrl+O` to see these messages in the transcript.&para;<br>&para;<br>#### Structured JSON output&para;<br>&para;<br>Exit codes give you two options: allow or block. For more control, exit 0 and print a JSON object to stdout instead.&para;<br>&para;<br>&lt;Note&gt;&para;<br>  Use exit 2 to block with a stderr message, or exit 0 with JSON for structured control. Don't mix them: Claude Code ignores JSON when you exit 2.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>For example, a `PreToolUse` hook can deny a tool call and tell Claude why, or escalate it to the user for approval:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "PreToolUse",&para;<br>    "permissionDecision": "deny",&para;<br>    "permissionDecisionReason": "Use rg instead of grep for better performance"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>Claude Code reads `permissionDecision` and cancels the tool call, then feeds `permissionDecisionReason` back to Claude as feedback. The three options are:&para;<br>&para;<br>* `"allow"`: proceed without showing a permission prompt&para;<br>* `"deny"`: cancel the tool call and send the reason to Claude&para;<br>* `"ask"`: show the permission prompt to the user as normal&para;<br>&para;<br>For `UserPromptSubmit` hooks, use `additionalContext` instead to inject text into Claude's context. See [Control behavior with JSON output](/en/hooks#json-output) in the reference for the full JSON schema. Prompt-based hooks (`type: "prompt"`) handle output differently: see [Prompt-based hooks](#prompt-based-hooks).&para;<br>&para;<br>### Filter hooks with matchers&para;<br>&para;<br>Without a matcher, a hook fires on every occurrence of its event. Matchers let you narrow that down. For example, if you want to run a formatter only after file edits (not after every tool call), add a matcher to your `PostToolUse` hook:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PostToolUse": [&para;<br>      {&para;<br>        "matcher": "Edit|Write",&para;<br>        "hooks": [&para;<br>          { "type": "command", "command": "prettier --write ..." }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>The `"Edit|Write"` matcher is a regex pattern that matches the tool name. The hook only fires when Claude uses the `Edit` or `Write` tool, not when it uses `Bash`, `Read`, or any other tool.&para;<br>&para;<br>Each event type matches on a specific field. Matchers support exact strings and regex patterns:&para;<br>&para;<br>| Event                                                                  | What the matcher filters  | Example matcher values                                                   |&para;<br>| :--------------------------------------------------------------------- | :------------------------ | :----------------------------------------------------------------------- |&para;<br>| `PreToolUse`, `PostToolUse`, `PostToolUseFailure`, `PermissionRequest` | tool name                 | `Bash`, `Edit\|Write`, `mcp__.*`                                         |&para;<br>| `SessionStart`                                                         | how the session started   | `startup`, `resume`, `clear`, `compact`                                  |&para;<br>| `SessionEnd`                                                           | why the session ended     | `clear`, `logout`, `prompt_input_exit`, `other`                          |&para;<br>| `Notification`                                                         | notification type         | `permission_prompt`, `idle_prompt`, `auth_success`, `elicitation_dialog` |&para;<br>| `SubagentStart`                                                        | agent type                | `Bash`, `Explore`, `Plan`, or custom agent names                         |&para;<br>| `PreCompact`                                                           | what triggered compaction | `manual`, `auto`                                                         |&para;<br>| `UserPromptSubmit`, `Stop`                                             | no matcher support        | always fires on every occurrence                                         |&para;<br>| `SubagentStop`                                                         | agent type                | same values as `SubagentStart`                                           |&para;<br>&para;<br>A few more examples showing matchers on different event types:&para;<br>&para;<br>&lt;Tabs&gt;&para;<br>  &lt;Tab title="Log every Bash command"&gt;&para;<br>    Match only `Bash` tool calls and log each command to a file. The `PostToolUse` event fires after the command completes, so `tool_input.command` contains what ran. The hook receives the event data as JSON on stdin, and `jq -r '.tool_input.command'` extracts just the command string, which `&gt;&gt;` appends to the log file:&para;<br>&para;<br>    ```json  theme={null}&para;<br>    {&para;<br>      "hooks": {&para;<br>        "PostToolUse": [&para;<br>          {&para;<br>            "matcher": "Bash",&para;<br>            "hooks": [&para;<br>              {&para;<br>                "type": "command",&para;<br>                "command": "jq -r '.tool_input.command' &gt;&gt; ~/.claude/command-log.txt"&para;<br>              }&para;<br>            ]&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    }&para;<br>    ```&para;<br>  &lt;/Tab&gt;&para;<br>&para;<br>  &lt;Tab title="Match MCP tools"&gt;&para;<br>    MCP tools use a different naming convention than built-in tools: `mcp__&lt;server&gt;__&lt;tool&gt;`, where `&lt;server&gt;` is the MCP server name and `&lt;tool&gt;` is the tool it provides. For example, `mcp__github__search_repositories` or `mcp__filesystem__read_file`. Use a regex matcher to target all tools from a specific server, or match across servers with a pattern like `mcp__.*__write.*`. See [Match MCP tools](/en/hooks#match-mcp-tools) in the reference for the full list of examples.&para;<br>&para;<br>    The command below extracts the tool name from the hook's JSON input with `jq` and writes it to stderr, where it shows up in verbose mode (`Ctrl+O`):&para;<br>&para;<br>    ```json  theme={null}&para;<br>    {&para;<br>      "hooks": {&para;<br>        "PreToolUse": [&para;<br>          {&para;<br>            "matcher": "mcp__github__.*",&para;<br>            "hooks": [&para;<br>              {&para;<br>                "type": "command",&para;<br>                "command": "echo \"GitHub tool called: $(jq -r '.tool_name')\" &gt;&amp;2"&para;<br>              }&para;<br>            ]&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    }&para;<br>    ```&para;<br>  &lt;/Tab&gt;&para;<br>&para;<br>  &lt;Tab title="Clean up on session end"&gt;&para;<br>    The `SessionEnd` event supports matchers on the reason the session ended. This hook only fires on `clear` (when you run `/clear`), not on normal exits:&para;<br>&para;<br>    ```json  theme={null}&para;<br>    {&para;<br>      "hooks": {&para;<br>        "SessionEnd": [&para;<br>          {&para;<br>            "matcher": "clear",&para;<br>            "hooks": [&para;<br>              {&para;<br>                "type": "command",&para;<br>                "command": "rm -f /tmp/claude-scratch-*.txt"&para;<br>              }&para;<br>            ]&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    }&para;<br>    ```&para;<br>  &lt;/Tab&gt;&para;<br>&lt;/Tabs&gt;&para;<br>&para;<br>For full matcher syntax, see the [Hooks reference](/en/hooks#configuration).&para;<br>&para;<br>### Configure hook location&para;<br>&para;<br>Where you add a hook determines its scope:&para;<br>&para;<br>| Location                                                   | Scope                              | Shareable                          |&para;<br>| :--------------------------------------------------------- | :--------------------------------- | :--------------------------------- |&para;<br>| `~/.claude/settings.json`                                  | All your projects                  | No, local to your machine          |&para;<br>| `.claude/settings.json`                                    | Single project                     | Yes, can be committed to the repo  |&para;<br>| `.claude/settings.local.json`                              | Single project                     | No, gitignored                     |&para;<br>| Managed policy settings                                    | Organization-wide                  | Yes, admin-controlled              |&para;<br>| [Plugin](/en/plugins) `hooks/hooks.json`                   | When plugin is enabled             | Yes, bundled with the plugin       |&para;<br>| [Skill](/en/skills) or [agent](/en/sub-agents) frontmatter | While the skill or agent is active | Yes, defined in the component file |&para;<br>&para;<br>You can also use the [`/hooks` menu](/en/hooks#the-hooks-menu) in Claude Code to add, delete, and view hooks interactively. To disable all hooks at once, use the toggle at the bottom of the `/hooks` menu or set `"disableAllHooks": true` in your settings file.&para;<br>&para;<br>Hooks added through the `/hooks` menu take effect immediately. If you edit settings files directly while Claude Code is running, the changes won't take effect until you review them in the `/hooks` menu or restart your session.&para;<br>&para;<br>## Prompt-based hooks&para;<br>&para;<br>For decisions that require judgment rather than deterministic rules, use `type: "prompt"` hooks. Instead of running a shell command, Claude Code sends your prompt and the hook's input data to a Claude model (Haiku by default) to make the decision. You can specify a different model with the `model` field if you need more capability.&para;<br>&para;<br>The model's only job is to return a yes/no decision as JSON:&para;<br>&para;<br>* `"ok": true`: the action proceeds&para;<br>* `"ok": false`: the action is blocked. The model's `"reason"` is fed back to Claude so it can adjust.&para;<br>&para;<br>This example uses a `Stop` hook to ask the model whether all requested tasks are complete. If the model returns `"ok": false`, Claude keeps working and uses the `reason` as its next instruction:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "Stop": [&para;<br>      {&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "prompt",&para;<br>            "prompt": "Check if all tasks are complete. If not, respond with {\"ok\": false, \"reason\": \"what remains to be done\"}."&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>For full configuration options, see [Prompt-based hooks](/en/hooks#prompt-based-hooks) in the reference.&para;<br>&para;<br>## Agent-based hooks&para;<br>&para;<br>When verification requires inspecting files or running commands, use `type: "agent"` hooks. Unlike prompt hooks which make a single LLM call, agent hooks spawn a subagent that can read files, search code, and use other tools to verify conditions before returning a decision.&para;<br>&para;<br>Agent hooks use the same `"ok"` / `"reason"` response format as prompt hooks, but with a longer default timeout of 60 seconds and up to 50 tool-use turns.&para;<br>&para;<br>This example verifies that tests pass before allowing Claude to stop:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "Stop": [&para;<br>      {&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "agent",&para;<br>            "prompt": "Verify that all unit tests pass. Run the test suite and check the results. $ARGUMENTS",&para;<br>            "timeout": 120&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>Use prompt hooks when the hook input data alone is enough to make a decision. Use agent hooks when you need to verify something against the actual state of the codebase.&para;<br>&para;<br>For full configuration options, see [Agent-based hooks](/en/hooks#agent-based-hooks) in the reference.&para;<br>&para;<br>## Limitations and troubleshooting&para;<br>&para;<br>### Limitations&para;<br>&para;<br>* Hooks communicate through stdout, stderr, and exit codes only. They cannot trigger slash commands or tool calls directly.&para;<br>* Hook timeout is 10 minutes by default, configurable per hook with the `timeout` field (in seconds).&para;<br>* `PostToolUse` hooks cannot undo actions since the tool has already executed.&para;<br>* `PermissionRequest` hooks do not fire in [non-interactive mode](/en/headless) (`-p`). Use `PreToolUse` hooks for automated permission decisions.&para;<br>* `Stop` hooks fire whenever Claude finishes responding, not only at task completion. They do not fire on user interrupts.&para;<br>&para;<br>### Hook not firing&para;<br>&para;<br>The hook is configured but never executes.&para;<br>&para;<br>* Run `/hooks` and confirm the hook appears under the correct event&para;<br>* Check that the matcher pattern matches the tool name exactly (matchers are case-sensitive)&para;<br>* Verify you're triggering the right event type (e.g., `PreToolUse` fires before tool execution, `PostToolUse` fires after)&para;<br>* If using `PermissionRequest` hooks in non-interactive mode (`-p`), switch to `PreToolUse` instead&para;<br>&para;<br>### Hook error in output&para;<br>&para;<br>You see a message like "PreToolUse hook error: ..." in the transcript.&para;<br>&para;<br>* Your script exited with a non-zero code unexpectedly. Test it manually by piping sample JSON:&para;<br>  ```bash  theme={null}&para;<br>  echo '{"tool_name":"Bash","tool_input":{"command":"ls"}}' | ./my-hook.sh&para;<br>  echo $?  # Check the exit code&para;<br>  ```&para;<br>* If you see "command not found", use absolute paths or `$CLAUDE_PROJECT_DIR` to reference scripts&para;<br>* If you see "jq: command not found", install `jq` or use Python/Node.js for JSON parsing&para;<br>* If the script isn't running at all, make it executable: `chmod +x ./my-hook.sh`&para;<br>&para;<br>### `/hooks` shows no hooks configured&para;<br>&para;<br>You edited a settings file but the hooks don't appear in the menu.&para;<br>&para;<br>* Restart your session or open `/hooks` to reload. Hooks added through the `/hooks` menu take effect immediately, but manual file edits require a reload.&para;<br>* Verify your JSON is valid (trailing commas and comments are not allowed)&para;<br>* Confirm the settings file is in the correct location: `.claude/settings.json` for project hooks, `~/.claude/settings.json` for global hooks&para;<br>&para;<br>### Stop hook runs forever&para;<br>&para;<br>Claude keeps working in an infinite loop instead of stopping.&para;<br>&para;<br>Your Stop hook script needs to check whether it already triggered a continuation. Parse the `stop_hook_active` field from the JSON input and exit early if it's `true`:&para;<br>&para;<br>```bash  theme={null}&para;<br>#!/bin/bash&para;<br>INPUT=$(cat)&para;<br>if [ "$(echo "$INPUT" | jq -r '.stop_hook_active')" = "true" ]; then&para;<br>  exit 0  # Allow Claude to stop&para;<br>fi&para;<br># ... rest of your hook logic&para;<br>```&para;<br>&para;<br>### JSON validation failed&para;<br>&para;<br>Claude Code shows a JSON parsing error even though your hook script outputs valid JSON.&para;<br>&para;<br>When Claude Code runs a hook, it spawns a shell that sources your profile (`~/.zshrc` or `~/.bashrc`). If your profile contains unconditional `echo` statements, that output gets prepended to your hook's JSON:&para;<br>&para;<br>```&para;<br>Shell ready on arm64&para;<br>{"decision": "allow"}&para;<br>```&para;<br>&para;<br>Claude Code tries to parse this as JSON and fails. To fix this, wrap echo statements in your shell profile so they only run in interactive shells:&para;<br>&para;<br>```bash  theme={null}&para;<br># In ~/.zshrc or ~/.bashrc&para;<br>if [[ $- == *i* ]]; then&para;<br>  echo "Shell ready"&para;<br>fi&para;<br>```&para;<br>&para;<br>The `$-` variable contains shell flags, and `i` means interactive. Hooks run in non-interactive shells, so the echo is skipped.&para;<br>&para;<br>### Debug techniques&para;<br>&para;<br>Toggle verbose mode with `Ctrl+O` to see hook output in the transcript, or run `claude --debug` for full execution details including which hooks matched and their exit codes.&para;<br>&para;<br>## Learn more&para;<br>&para;<br>* [Hooks reference](/en/hooks): full event schemas, JSON output format, async hooks, and MCP tool hooks&para;<br>* [Security considerations](/en/hooks#security-considerations): review before deploying hooks in shared or production environments&para;<br>* [Bash command validator example](https://github.com/anthropics/claude-code/blob/main/examples/hooks/bash_command_validator_example.py): complete reference implementation</ins><span>&para;<br></span></div>
        </div>

        <h2 style="margin-top: 2rem; margin-bottom: 1rem;">Unified Diff</h2>
        <pre><code>--- a/hooks-guide.md
+++ b/hooks-guide.md
@@ -2,148 +2,156 @@
 &gt; Fetch the complete documentation index at: https://code.claude.com/docs/llms.txt
 &gt; Use this file to discover all available pages before exploring further.
 
-# Get started with Claude Code hooks
-
-&gt; Learn how to customize and extend Claude Code&#39;s behavior by registering shell commands
-
-Claude Code hooks are user-defined shell commands that execute at various points
-in Claude Code&#39;s lifecycle. Hooks provide deterministic control over Claude
-Code&#39;s behavior, ensuring certain actions always happen rather than relying on
-the LLM to choose to run them.
+# Automate workflows with hooks
+
+&gt; Run shell commands automatically when Claude Code edits files, finishes tasks, or needs input. Format code, send notifications, validate commands, and enforce project rules.
+
+Hooks are user-defined shell commands that execute at specific points in Claude Code&#39;s lifecycle. They provide deterministic control over Claude Code&#39;s behavior, ensuring certain actions always happen rather than relying on the LLM to choose to run them. Use hooks to enforce project rules, automate repetitive tasks, and integrate Claude Code with your existing tools.
+
+For decisions that require judgment rather than deterministic rules, you can also use [prompt-based hooks](#prompt-based-hooks) or [agent-based hooks](#agent-based-hooks) that use a Claude model to evaluate conditions.
+
+For other ways to extend Claude Code, see [skills](/en/skills) for giving Claude additional instructions and executable commands, [subagents](/en/sub-agents) for running tasks in isolated contexts, and [plugins](/en/plugins) for packaging extensions to share across projects.
 
 &lt;Tip&gt;
-  For reference documentation on hooks, see [Hooks reference](/en/hooks).
+  This guide covers common use cases and how to get started. For full event schemas, JSON input/output formats, and advanced features like async hooks and MCP tool hooks, see the [Hooks reference](/en/hooks).
 &lt;/Tip&gt;
 
-Example use cases for hooks include:
-
-* **Notifications**: Customize how you get notified when Claude Code is awaiting
-  your input or permission to run something.
-* **Automatic formatting**: Run `prettier` on .ts files, `gofmt` on .go files,
-  etc. after every file edit.
-* **Logging**: Track and count all executed commands for compliance or
-  debugging.
-* **Feedback**: Provide automated feedback when Claude Code produces code that
-  does not follow your codebase conventions.
-* **Custom permissions**: Block modifications to production files or sensitive
-  directories.
-
-By encoding these rules as hooks rather than prompting instructions, you turn
-suggestions into app-level code that executes every time it is expected to run.
-
-&lt;Warning&gt;
-  You must consider the security implication of hooks as you add them, because hooks run automatically during the agent loop with your current environment&#39;s credentials.
-  For example, malicious hooks code can exfiltrate your data. Always review your hooks implementation before registering them.
-
-  For full security best practices, see [Security Considerations](/en/hooks#security-considerations) in the hooks reference documentation.
-&lt;/Warning&gt;
-
-## Hook Events Overview
-
-Claude Code provides several hook events that run at different points in the
-workflow:
-
-* **PreToolUse**: Runs before tool calls (can block them)
-* **PermissionRequest**: Runs when a permission dialog is shown (can allow or deny)
-* **PostToolUse**: Runs after tool calls complete
-* **UserPromptSubmit**: Runs when the user submits a prompt, before Claude processes it
-* **Notification**: Runs when Claude Code sends notifications
-* **Stop**: Runs when Claude Code finishes responding
-* **SubagentStop**: Runs when subagent tasks complete
-* **PreCompact**: Runs before Claude Code is about to run a compact operation
-* **Setup**: Runs when Claude Code is invoked with `--init`, `--init-only`, or `--maintenance` flags
-* **SessionStart**: Runs when Claude Code starts a new session or resumes an existing session
-* **SessionEnd**: Runs when Claude Code session ends
-
-Each event receives different data and can control Claude&#39;s behavior in
-different ways.
-
-## Quickstart
-
-In this quickstart, you&#39;ll add a hook that logs the shell commands that Claude
-Code runs.
-
-### Prerequisites
-
-Install `jq` for JSON processing in the command line.
-
-### Step 1: Open hooks configuration
-
-Run the `/hooks` command and select
-the `PreToolUse` hook event.
-
-`PreToolUse` hooks run before tool calls and can block them while providing
-Claude feedback on what to do differently.
-
-### Step 2: Add a matcher
-
-Select `+ Add new matcher…` to run your hook only on Bash tool calls.
-
-Type `Bash` for the matcher.
-
-&lt;Note&gt;You can use `*` to match all tools.&lt;/Note&gt;
-
-### Step 3: Add the hook
-
-Select `+ Add new hook…` and enter this command:
-
-```bash  theme={null}
-jq -r &#39;&#34;\(.tool_input.command) - \(.tool_input.description // &#34;No description&#34;)&#34;&#39; &gt;&gt; ~/.claude/bash-command-log.txt
-```
-
-### Step 4: Save your configuration
-
-For storage location, select `User settings` since you&#39;re logging to your home
-directory. This hook will then apply to all projects, not just your current
-project.
-
-Then press `Esc` until you return to the REPL. Your hook is now registered.
-
-### Step 5: Verify your hook
-
-Run `/hooks` again or check `~/.claude/settings.json` to see your configuration:
-
-```json  theme={null}
-{
-  &#34;hooks&#34;: {
-    &#34;PreToolUse&#34;: [
-      {
-        &#34;matcher&#34;: &#34;Bash&#34;,
-        &#34;hooks&#34;: [
-          {
-            &#34;type&#34;: &#34;command&#34;,
-            &#34;command&#34;: &#34;jq -r &#39;\&#34;\\(.tool_input.command) - \\(.tool_input.description // \&#34;No description\&#34;)\&#34;&#39; &gt;&gt; ~/.claude/bash-command-log.txt&#34;
-          }
-        ]
-      }
-    ]
-  }
-}
-```
-
-### Step 6: Test your hook
-
-Ask Claude to run a simple command like `ls` and check your log file:
-
-```bash  theme={null}
-cat ~/.claude/bash-command-log.txt
-```
-
-You should see entries like:
-
-```
-ls - Lists files and directories
-```
-
-## More Examples
-
-&lt;Note&gt;
-  For a complete example implementation, see the [bash command validator example](https://github.com/anthropics/claude-code/blob/main/examples/hooks/bash_command_validator_example.py) in our public codebase.
-&lt;/Note&gt;
-
-### Code Formatting Hook
-
-Automatically format TypeScript files after editing:
+## Set up your first hook
+
+The fastest way to create a hook is through the `/hooks` interactive menu in Claude Code. This walkthrough creates a desktop notification hook, so you get alerted whenever Claude is waiting for your input instead of watching the terminal.
+
+&lt;Steps&gt;
+  &lt;Step title=&#34;Open the hooks menu&#34;&gt;
+    Type `/hooks` in the Claude Code CLI. You&#39;ll see a list of all available hook events, plus an option to disable all hooks. Each event corresponds to a point in Claude&#39;s lifecycle where you can run custom code. Select `Notification` to create a hook that fires when Claude needs your attention.
+  &lt;/Step&gt;
+
+  &lt;Step title=&#34;Configure the matcher&#34;&gt;
+    The menu shows a list of matchers, which filter when the hook fires. Set the matcher to `*` to fire on all notification types. You can narrow it later by changing the matcher to a specific value like `permission_prompt` or `idle_prompt`.
+  &lt;/Step&gt;
+
+  &lt;Step title=&#34;Add your command&#34;&gt;
+    Select `+ Add new hook…`. The menu prompts you for a shell command to run when the event fires. Hooks run any shell command you provide, so you can use your platform&#39;s built-in notification tool. Copy the command for your OS:
+
+    &lt;Tabs&gt;
+      &lt;Tab title=&#34;macOS&#34;&gt;
+        Uses [`osascript`](https://ss64.com/mac/osascript.html) to trigger a native macOS notification through AppleScript:
+
+        ```
+        osascript -e &#39;display notification &#34;Claude Code needs your attention&#34; with title &#34;Claude Code&#34;&#39;
+        ```
+      &lt;/Tab&gt;
+
+      &lt;Tab title=&#34;Linux&#34;&gt;
+        Uses `notify-send`, which is pre-installed on most Linux desktops with a notification daemon:
+
+        ```
+        notify-send &#39;Claude Code&#39; &#39;Claude Code needs your attention&#39;
+        ```
+      &lt;/Tab&gt;
+
+      &lt;Tab title=&#34;Windows (PowerShell)&#34;&gt;
+        Uses PowerShell to show a native message box through .NET&#39;s Windows Forms:
+
+        ```
+        powershell.exe -Command &#34;[System.Reflection.Assembly]::LoadWithPartialName(&#39;System.Windows.Forms&#39;); [System.Windows.Forms.MessageBox]::Show(&#39;Claude Code needs your attention&#39;, &#39;Claude Code&#39;)&#34;
+        ```
+      &lt;/Tab&gt;
+    &lt;/Tabs&gt;
+  &lt;/Step&gt;
+
+  &lt;Step title=&#34;Choose a storage location&#34;&gt;
+    The menu asks where to save the hook configuration. Select `User settings` to store it in `~/.claude/settings.json`, which applies the hook to all your projects. You could also choose `Project settings` to scope it to the current project. See [Configure hook location](#configure-hook-location) for all available scopes.
+  &lt;/Step&gt;
+
+  &lt;Step title=&#34;Test the hook&#34;&gt;
+    Press `Esc` to return to the CLI. Ask Claude to do something that requires permission, then switch away from the terminal. You should receive a desktop notification.
+  &lt;/Step&gt;
+&lt;/Steps&gt;
+
+## What you can automate
+
+Hooks let you run code at key points in Claude Code&#39;s lifecycle: format files after edits, block commands before they execute, send notifications when Claude needs input, inject context at session start, and more. For the full list of hook events, see the [Hooks reference](/en/hooks#hook-lifecycle).
+
+Each example includes a ready-to-use configuration block that you add to a [settings file](#configure-hook-location). The most common patterns:
+
+* [Get notified when Claude needs input](#get-notified-when-claude-needs-input)
+* [Auto-format code after edits](#auto-format-code-after-edits)
+* [Block edits to protected files](#block-edits-to-protected-files)
+* [Re-inject context after compaction](#re-inject-context-after-compaction)
+
+### Get notified when Claude needs input
+
+Get a desktop notification whenever Claude finishes working and needs your input, so you can switch to other tasks without checking the terminal.
+
+This hook uses the `Notification` event, which fires when Claude is waiting for input or permission. Each tab below uses the platform&#39;s native notification command. Add this to `~/.claude/settings.json`, or use the [interactive walkthrough](#set-up-your-first-hook) above to configure it with `/hooks`:
+
+&lt;Tabs&gt;
+  &lt;Tab title=&#34;macOS&#34;&gt;
+    ```json  theme={null}
+    {
+      &#34;hooks&#34;: {
+        &#34;Notification&#34;: [
+          {
+            &#34;matcher&#34;: &#34;&#34;,
+            &#34;hooks&#34;: [
+              {
+                &#34;type&#34;: &#34;command&#34;,
+                &#34;command&#34;: &#34;osascript -e &#39;display notification \&#34;Claude Code needs your attention\&#34; with title \&#34;Claude Code\&#34;&#39;&#34;
+              }
+            ]
+          }
+        ]
+      }
+    }
+    ```
+  &lt;/Tab&gt;
+
+  &lt;Tab title=&#34;Linux&#34;&gt;
+    ```json  theme={null}
+    {
+      &#34;hooks&#34;: {
+        &#34;Notification&#34;: [
+          {
+            &#34;matcher&#34;: &#34;&#34;,
+            &#34;hooks&#34;: [
+              {
+                &#34;type&#34;: &#34;command&#34;,
+                &#34;command&#34;: &#34;notify-send &#39;Claude Code&#39; &#39;Claude Code needs your attention&#39;&#34;
+              }
+            ]
+          }
+        ]
+      }
+    }
+    ```
+  &lt;/Tab&gt;
+
+  &lt;Tab title=&#34;Windows (PowerShell)&#34;&gt;
+    ```json  theme={null}
+    {
+      &#34;hooks&#34;: {
+        &#34;Notification&#34;: [
+          {
+            &#34;matcher&#34;: &#34;&#34;,
+            &#34;hooks&#34;: [
+              {
+                &#34;type&#34;: &#34;command&#34;,
+                &#34;command&#34;: &#34;powershell.exe -Command \&#34;[System.Reflection.Assembly]::LoadWithPartialName(&#39;System.Windows.Forms&#39;); [System.Windows.Forms.MessageBox]::Show(&#39;Claude Code needs your attention&#39;, &#39;Claude Code&#39;)\&#34;&#34;
+              }
+            ]
+          }
+        ]
+      }
+    }
+    ```
+  &lt;/Tab&gt;
+&lt;/Tabs&gt;
+
+### Auto-format code after edits
+
+Automatically run [Prettier](https://prettier.io/) on every file Claude edits, so formatting stays consistent without manual intervention.
+
+This hook uses the `PostToolUse` event with an `Edit|Write` matcher, so it runs only after file-editing tools. The command extracts the edited file path with [`jq`](https://jqlang.github.io/jq/) and passes it to Prettier. Add this to `.claude/settings.json` in your project root:
 
 ```json  theme={null}
 {
@@ -154,7 +162,7 @@
         &#34;hooks&#34;: [
           {
             &#34;type&#34;: &#34;command&#34;,
-            &#34;command&#34;: &#34;jq -r &#39;.tool_input.file_path&#39; | { read file_path; if echo \&#34;$file_path\&#34; | grep -q &#39;\\.ts$&#39;; then npx prettier --write \&#34;$file_path\&#34;; fi; }&#34;
+            &#34;command&#34;: &#34;jq -r &#39;.tool_input.file_path&#39; | xargs npx prettier --write&#34;
           }
         ]
       }
@@ -163,9 +171,194 @@
 }
 ```
 
-### Markdown Formatting Hook
-
-Automatically fix missing language tags and formatting issues in markdown files:
+&lt;Note&gt;
+  The Bash examples on this page use `jq` for JSON parsing. Install it with `brew install jq` (macOS), `apt-get install jq` (Debian/Ubuntu), or see [`jq` downloads](https://jqlang.github.io/jq/download/).
+&lt;/Note&gt;
+
+### Block edits to protected files
+
+Prevent Claude from modifying sensitive files like `.env`, `package-lock.json`, or anything in `.git/`. Claude receives feedback explaining why the edit was blocked, so it can adjust its approach.
+
+This example uses a separate script file that the hook calls. The script checks the target file path against a list of protected patterns and exits with code 2 to block the edit.
+
+&lt;Steps&gt;
+  &lt;Step title=&#34;Create the hook script&#34;&gt;
+    Save this to `.claude/hooks/protect-files.sh`:
+
+    ```bash  theme={null}
+    #!/bin/bash
+    # protect-files.sh
+
+    INPUT=$(cat)
+    FILE_PATH=$(echo &#34;$INPUT&#34; | jq -r &#39;.tool_input.file_path // empty&#39;)
+
+    PROTECTED_PATTERNS=(&#34;.env&#34; &#34;package-lock.json&#34; &#34;.git/&#34;)
+
+    for pattern in &#34;${PROTECTED_PATTERNS[@]}&#34;; do
+      if [[ &#34;$FILE_PATH&#34; == *&#34;$pattern&#34;* ]]; then
+        echo &#34;Blocked: $FILE_PATH matches protected pattern &#39;$pattern&#39;&#34; &gt;&amp;2
+        exit 2
+      fi
+    done
+
+    exit 0
+    ```
+  &lt;/Step&gt;
+
+  &lt;Step title=&#34;Make the script executable (macOS/Linux)&#34;&gt;
+    Hook scripts must be executable for Claude Code to run them:
+
+    ```bash  theme={null}
+    chmod +x .claude/hooks/protect-files.sh
+    ```
+  &lt;/Step&gt;
+
+  &lt;Step title=&#34;Register the hook&#34;&gt;
+    Add a `PreToolUse` hook to `.claude/settings.json` that runs the script before any `Edit` or `Write` tool call:
+
+    ```json  theme={null}
+    {
+      &#34;hooks&#34;: {
+        &#34;PreToolUse&#34;: [
+          {
+            &#34;matcher&#34;: &#34;Edit|Write&#34;,
+            &#34;hooks&#34;: [
+              {
+                &#34;type&#34;: &#34;command&#34;,
+                &#34;command&#34;: &#34;\&#34;$CLAUDE_PROJECT_DIR\&#34;/.claude/hooks/protect-files.sh&#34;
+              }
+            ]
+          }
+        ]
+      }
+    }
+    ```
+  &lt;/Step&gt;
+&lt;/Steps&gt;
+
+### Re-inject context after compaction
+
+When Claude&#39;s context window fills up, compaction summarizes the conversation to free space. This can lose important details. Use a `SessionStart` hook with a `compact` matcher to re-inject critical context after every compaction.
+
+Any text your command writes to stdout is added to Claude&#39;s context. This example reminds Claude of project conventions and recent work. Add this to `.claude/settings.json` in your project root:
+
+```json  theme={null}
+{
+  &#34;hooks&#34;: {
+    &#34;SessionStart&#34;: [
+      {
+        &#34;matcher&#34;: &#34;compact&#34;,
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;command&#34;,
+            &#34;command&#34;: &#34;echo &#39;Reminder: use Bun, not npm. Run bun test before committing. Current sprint: auth refactor.&#39;&#34;
+          }
+        ]
+      }
+    ]
+  }
+}
+```
+
+You can replace the `echo` with any command that produces dynamic output, like `git log --oneline -5` to show recent commits. For injecting context on every session start, consider using [CLAUDE.md](/en/memory) instead. For environment variables, see [`CLAUDE_ENV_FILE`](/en/hooks#persist-environment-variables) in the reference.
+
+## How hooks work
+
+Hook events fire at specific lifecycle points in Claude Code. When an event fires, all matching hooks run in parallel, and identical hook commands are automatically deduplicated. The table below shows each event and when it triggers:
+
+| Event                | When it fires                                        |
+| :------------------- | :--------------------------------------------------- |
+| `SessionStart`       | When a session begins or resumes                     |
+| `UserPromptSubmit`   | When you submit a prompt, before Claude processes it |
+| `PreToolUse`         | Before a tool call executes. Can block it            |
+| `PermissionRequest`  | When a permission dialog appears                     |
+| `PostToolUse`        | After a tool call succeeds                           |
+| `PostToolUseFailure` | After a tool call fails                              |
+| `Notification`       | When Claude Code sends a notification                |
+| `SubagentStart`      | When a subagent is spawned                           |
+| `SubagentStop`       | When a subagent finishes                             |
+| `Stop`               | When Claude finishes responding                      |
+| `PreCompact`         | Before context compaction                            |
+| `SessionEnd`         | When a session terminates                            |
+
+Each hook has a `type` that determines how it runs. Most hooks use `&#34;type&#34;: &#34;command&#34;`, which runs a shell command. Two other options use a Claude model to make decisions: `&#34;type&#34;: &#34;prompt&#34;` for single-turn evaluation and `&#34;type&#34;: &#34;agent&#34;` for multi-turn verification with tool access. See [Prompt-based hooks](#prompt-based-hooks) and [Agent-based hooks](#agent-based-hooks) for details.
+
+### Read input and return output
+
+Hooks communicate with Claude Code through stdin, stdout, stderr, and exit codes. When an event fires, Claude Code passes event-specific data as JSON to your script&#39;s stdin. Your script reads that data, does its work, and tells Claude Code what to do next via the exit code.
+
+#### Hook input
+
+Every event includes common fields like `session_id` and `cwd`, but each event type adds different data. For example, when Claude runs a Bash command, a `PreToolUse` hook receives something like this on stdin:
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,          // unique ID for this session
+  &#34;cwd&#34;: &#34;/Users/sarah/myproject&#34;, // working directory when the event fired
+  &#34;hook_event_name&#34;: &#34;PreToolUse&#34;, // which event triggered this hook
+  &#34;tool_name&#34;: &#34;Bash&#34;,             // the tool Claude is about to use
+  &#34;tool_input&#34;: {                  // the arguments Claude passed to the tool
+    &#34;command&#34;: &#34;npm test&#34;          // for Bash, this is the shell command
+  }
+}
+```
+
+Your script can parse that JSON and act on any of those fields. `UserPromptSubmit` hooks get the `prompt` text instead, `SessionStart` hooks get the `source` (startup, resume, compact), and so on. See [Common input fields](/en/hooks#common-input-fields) in the reference for shared fields, and each event&#39;s section for event-specific schemas.
+
+#### Hook output
+
+Your script tells Claude Code what to do next by writing to stdout or stderr and exiting with a specific code. For example, a `PreToolUse` hook that wants to block a command:
+
+```bash  theme={null}
+#!/bin/bash
+INPUT=$(cat)
+COMMAND=$(echo &#34;$INPUT&#34; | jq -r &#39;.tool_input.command&#39;)
+
+if echo &#34;$COMMAND&#34; | grep -q &#34;drop table&#34;; then
+  echo &#34;Blocked: dropping tables is not allowed&#34; &gt;&amp;2  # stderr becomes Claude&#39;s feedback
+  exit 2                                               # exit 2 = block the action
+fi
+
+exit 0  # exit 0 = let it proceed
+```
+
+The exit code determines what happens next:
+
+* **Exit 0**: the action proceeds. For `UserPromptSubmit` and `SessionStart` hooks, anything you write to stdout is added to Claude&#39;s context.
+* **Exit 2**: the action is blocked. Write a reason to stderr, and Claude receives it as feedback so it can adjust.
+* **Any other exit code**: the action proceeds. Stderr is logged but not shown to Claude. Toggle verbose mode with `Ctrl+O` to see these messages in the transcript.
+
+#### Structured JSON output
+
+Exit codes give you two options: allow or block. For more control, exit 0 and print a JSON object to stdout instead.
+
+&lt;Note&gt;
+  Use exit 2 to block with a stderr message, or exit 0 with JSON for structured control. Don&#39;t mix them: Claude Code ignores JSON when you exit 2.
+&lt;/Note&gt;
+
+For example, a `PreToolUse` hook can deny a tool call and tell Claude why, or escalate it to the user for approval:
+
+```json  theme={null}
+{
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;PreToolUse&#34;,
+    &#34;permissionDecision&#34;: &#34;deny&#34;,
+    &#34;permissionDecisionReason&#34;: &#34;Use rg instead of grep for better performance&#34;
+  }
+}
+```
+
+Claude Code reads `permissionDecision` and cancels the tool call, then feeds `permissionDecisionReason` back to Claude as feedback. The three options are:
+
+* `&#34;allow&#34;`: proceed without showing a permission prompt
+* `&#34;deny&#34;`: cancel the tool call and send the reason to Claude
+* `&#34;ask&#34;`: show the permission prompt to the user as normal
+
+For `UserPromptSubmit` hooks, use `additionalContext` instead to inject text into Claude&#39;s context. See [Control behavior with JSON output](/en/hooks#json-output) in the reference for the full JSON schema. Prompt-based hooks (`type: &#34;prompt&#34;`) handle output differently: see [Prompt-based hooks](#prompt-based-hooks).
+
+### Filter hooks with matchers
+
+Without a matcher, a hook fires on every occurrence of its event. Matchers let you narrow that down. For example, if you want to run a formatter only after file edits (not after every tool call), add a matcher to your `PostToolUse` hook:
 
 ```json  theme={null}
 {
@@ -174,10 +367,7 @@
       {
         &#34;matcher&#34;: &#34;Edit|Write&#34;,
         &#34;hooks&#34;: [
-          {
-            &#34;type&#34;: &#34;command&#34;,
-            &#34;command&#34;: &#34;\&#34;$CLAUDE_PROJECT_DIR\&#34;/.claude/hooks/markdown_formatter.py&#34;
-          }
+          { &#34;type&#34;: &#34;command&#34;, &#34;command&#34;: &#34;prettier --write ...&#34; }
         ]
       }
     ]
@@ -185,121 +375,132 @@
 }
 ```
 
-Create `.claude/hooks/markdown_formatter.py` with this content:
-
-````python  theme={null}
-#!/usr/bin/env python3
-&#34;&#34;&#34;
-Markdown formatter for Claude Code output.
-Fixes missing language tags and spacing issues while preserving code content.
-&#34;&#34;&#34;
-import json
-import sys
-import re
-import os
-
-def detect_language(code):
-    &#34;&#34;&#34;Best-effort language detection from code content.&#34;&#34;&#34;
-    s = code.strip()
-    
-    # JSON detection
-    if re.search(r&#39;^\s*[{\[]&#39;, s):
-        try:
-            json.loads(s)
-            return &#39;json&#39;
-        except:
-            pass
-    
-    # Python detection
-    if re.search(r&#39;^\s*def\s+\w+\s*\(&#39;, s, re.M) or \
-       re.search(r&#39;^\s*(import|from)\s+\w+&#39;, s, re.M):
-        return &#39;python&#39;
-    
-    # JavaScript detection  
-    if re.search(r&#39;\b(function\s+\w+\s*\(|const\s+\w+\s*=)&#39;, s) or \
-       re.search(r&#39;=&gt;|console\.(log|error)&#39;, s):
-        return &#39;javascript&#39;
-    
-    # Bash detection
-    if re.search(r&#39;^#!.*\b(bash|sh)\b&#39;, s, re.M) or \
-       re.search(r&#39;\b(if|then|fi|for|in|do|done)\b&#39;, s):
-        return &#39;bash&#39;
-    
-    # SQL detection
-    if re.search(r&#39;\b(SELECT|INSERT|UPDATE|DELETE|CREATE)\s+&#39;, s, re.I):
-        return &#39;sql&#39;
-        
-    return &#39;text&#39;
-
-def format_markdown(content):
-    &#34;&#34;&#34;Format markdown content with language detection.&#34;&#34;&#34;
-    # Fix unlabeled code fences
-    def add_lang_to_fence(match):
-        indent, info, body, closing = match.groups()
-        if not info.strip():
-            lang = detect_language(body)
-            return f&#34;{indent}```{lang}\n{body}{closing}\n&#34;
-        return match.group(0)
-    
-    fence_pattern = r&#39;(?ms)^([ \t]{0,3})```([^\n]*)\n(.*?)(\n\1```)\s*$&#39;
-    content = re.sub(fence_pattern, add_lang_to_fence, content)
-    
-    # Fix excessive blank lines (only outside code fences)
-    content = re.sub(r&#39;\n{3,}&#39;, &#39;\n\n&#39;, content)
-    
-    return content.rstrip() + &#39;\n&#39;
-
-# Main execution
-try:
-    input_data = json.load(sys.stdin)
-    file_path = input_data.get(&#39;tool_input&#39;, {}).get(&#39;file_path&#39;, &#39;&#39;)
-    
-    if not file_path.endswith((&#39;.md&#39;, &#39;.mdx&#39;)):
-        sys.exit(0)  # Not a markdown file
-    
-    if os.path.exists(file_path):
-        with open(file_path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
-            content = f.read()
-        
-        formatted = format_markdown(content)
-        
-        if formatted != content:
-            with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
-                f.write(formatted)
-            print(f&#34;✓ Fixed markdown formatting in {file_path}&#34;)
-    
-except Exception as e:
-    print(f&#34;Error formatting markdown: {e}&#34;, file=sys.stderr)
-    sys.exit(1)
-````
-
-Make the script executable:
-
-```bash  theme={null}
-chmod +x .claude/hooks/markdown_formatter.py
-```
-
-This hook automatically:
-
-* Detects programming languages in unlabeled code blocks
-* Adds appropriate language tags for syntax highlighting
-* Fixes excessive blank lines while preserving code content
-* Only processes markdown files (`.md`, `.mdx`)
-
-### Custom Notification Hook
-
-Get desktop notifications when Claude needs input:
+The `&#34;Edit|Write&#34;` matcher is a regex pattern that matches the tool name. The hook only fires when Claude uses the `Edit` or `Write` tool, not when it uses `Bash`, `Read`, or any other tool.
+
+Each event type matches on a specific field. Matchers support exact strings and regex patterns:
+
+| Event                                                                  | What the matcher filters  | Example matcher values                                                   |
+| :--------------------------------------------------------------------- | :------------------------ | :----------------------------------------------------------------------- |
+| `PreToolUse`, `PostToolUse`, `PostToolUseFailure`, `PermissionRequest` | tool name                 | `Bash`, `Edit\|Write`, `mcp__.*`                                         |
+| `SessionStart`                                                         | how the session started   | `startup`, `resume`, `clear`, `compact`                                  |
+| `SessionEnd`                                                           | why the session ended     | `clear`, `logout`, `prompt_input_exit`, `other`                          |
+| `Notification`                                                         | notification type         | `permission_prompt`, `idle_prompt`, `auth_success`, `elicitation_dialog` |
+| `SubagentStart`                                                        | agent type                | `Bash`, `Explore`, `Plan`, or custom agent names                         |
+| `PreCompact`                                                           | what triggered compaction | `manual`, `auto`                                                         |
+| `UserPromptSubmit`, `Stop`                                             | no matcher support        | always fires on every occurrence                                         |
+| `SubagentStop`                                                         | agent type                | same values as `SubagentStart`                                           |
+
+A few more examples showing matchers on different event types:
+
+&lt;Tabs&gt;
+  &lt;Tab title=&#34;Log every Bash command&#34;&gt;
+    Match only `Bash` tool calls and log each command to a file. The `PostToolUse` event fires after the command completes, so `tool_input.command` contains what ran. The hook receives the event data as JSON on stdin, and `jq -r &#39;.tool_input.command&#39;` extracts just the command string, which `&gt;&gt;` appends to the log file:
+
+    ```json  theme={null}
+    {
+      &#34;hooks&#34;: {
+        &#34;PostToolUse&#34;: [
+          {
+            &#34;matcher&#34;: &#34;Bash&#34;,
+            &#34;hooks&#34;: [
+              {
+                &#34;type&#34;: &#34;command&#34;,
+                &#34;command&#34;: &#34;jq -r &#39;.tool_input.command&#39; &gt;&gt; ~/.claude/command-log.txt&#34;
+              }
+            ]
+          }
+        ]
+      }
+    }
+    ```
+  &lt;/Tab&gt;
+
+  &lt;Tab title=&#34;Match MCP tools&#34;&gt;
+    MCP tools use a different naming convention than built-in tools: `mcp__&lt;server&gt;__&lt;tool&gt;`, where `&lt;server&gt;` is the MCP server name and `&lt;tool&gt;` is the tool it provides. For example, `mcp__github__search_repositories` or `mcp__filesystem__read_file`. Use a regex matcher to target all tools from a specific server, or match across servers with a pattern like `mcp__.*__write.*`. See [Match MCP tools](/en/hooks#match-mcp-tools) in the reference for the full list of examples.
+
+    The command below extracts the tool name from the hook&#39;s JSON input with `jq` and writes it to stderr, where it shows up in verbose mode (`Ctrl+O`):
+
+    ```json  theme={null}
+    {
+      &#34;hooks&#34;: {
+        &#34;PreToolUse&#34;: [
+          {
+            &#34;matcher&#34;: &#34;mcp__github__.*&#34;,
+            &#34;hooks&#34;: [
+              {
+                &#34;type&#34;: &#34;command&#34;,
+                &#34;command&#34;: &#34;echo \&#34;GitHub tool called: $(jq -r &#39;.tool_name&#39;)\&#34; &gt;&amp;2&#34;
+              }
+            ]
+          }
+        ]
+      }
+    }
+    ```
+  &lt;/Tab&gt;
+
+  &lt;Tab title=&#34;Clean up on session end&#34;&gt;
+    The `SessionEnd` event supports matchers on the reason the session ended. This hook only fires on `clear` (when you run `/clear`), not on normal exits:
+
+    ```json  theme={null}
+    {
+      &#34;hooks&#34;: {
+        &#34;SessionEnd&#34;: [
+          {
+            &#34;matcher&#34;: &#34;clear&#34;,
+            &#34;hooks&#34;: [
+              {
+                &#34;type&#34;: &#34;command&#34;,
+                &#34;command&#34;: &#34;rm -f /tmp/claude-scratch-*.txt&#34;
+              }
+            ]
+          }
+        ]
+      }
+    }
+    ```
+  &lt;/Tab&gt;
+&lt;/Tabs&gt;
+
+For full matcher syntax, see the [Hooks reference](/en/hooks#configuration).
+
+### Configure hook location
+
+Where you add a hook determines its scope:
+
+| Location                                                   | Scope                              | Shareable                          |
+| :--------------------------------------------------------- | :--------------------------------- | :--------------------------------- |
+| `~/.claude/settings.json`                                  | All your projects                  | No, local to your machine          |
+| `.claude/settings.json`                                    | Single project                     | Yes, can be committed to the repo  |
+| `.claude/settings.local.json`                              | Single project                     | No, gitignored                     |
+| Managed policy settings                                    | Organization-wide                  | Yes, admin-controlled              |
+| [Plugin](/en/plugins) `hooks/hooks.json`                   | When plugin is enabled             | Yes, bundled with the plugin       |
+| [Skill](/en/skills) or [agent](/en/sub-agents) frontmatter | While the skill or agent is active | Yes, defined in the component file |
+
+You can also use the [`/hooks` menu](/en/hooks#the-hooks-menu) in Claude Code to add, delete, and view hooks interactively. To disable all hooks at once, use the toggle at the bottom of the `/hooks` menu or set `&#34;disableAllHooks&#34;: true` in your settings file.
+
+Hooks added through the `/hooks` menu take effect immediately. If you edit settings files directly while Claude Code is running, the changes won&#39;t take effect until you review them in the `/hooks` menu or restart your session.
+
+## Prompt-based hooks
+
+For decisions that require judgment rather than deterministic rules, use `type: &#34;prompt&#34;` hooks. Instead of running a shell command, Claude Code sends your prompt and the hook&#39;s input data to a Claude model (Haiku by default) to make the decision. You can specify a different model with the `model` field if you need more capability.
+
+The model&#39;s only job is to return a yes/no decision as JSON:
+
+* `&#34;ok&#34;: true`: the action proceeds
+* `&#34;ok&#34;: false`: the action is blocked. The model&#39;s `&#34;reason&#34;` is fed back to Claude so it can adjust.
+
+This example uses a `Stop` hook to ask the model whether all requested tasks are complete. If the model returns `&#34;ok&#34;: false`, Claude keeps working and uses the `reason` as its next instruction:
 
 ```json  theme={null}
 {
   &#34;hooks&#34;: {
-    &#34;Notification&#34;: [
+    &#34;Stop&#34;: [
       {
-        &#34;matcher&#34;: &#34;&#34;,
         &#34;hooks&#34;: [
           {
-            &#34;type&#34;: &#34;command&#34;,
-            &#34;command&#34;: &#34;notify-send &#39;Claude Code&#39; &#39;Awaiting your input&#39;&#34;
+            &#34;type&#34;: &#34;prompt&#34;,
+            &#34;prompt&#34;: &#34;Check if all tasks are complete. If not, respond with {\&#34;ok\&#34;: false, \&#34;reason\&#34;: \&#34;what remains to be done\&#34;}.&#34;
           }
         ]
       }
@@ -308,20 +509,26 @@
 }
 ```
 
-### File Protection Hook
-
-Block edits to sensitive files:
+For full configuration options, see [Prompt-based hooks](/en/hooks#prompt-based-hooks) in the reference.
+
+## Agent-based hooks
+
+When verification requires inspecting files or running commands, use `type: &#34;agent&#34;` hooks. Unlike prompt hooks which make a single LLM call, agent hooks spawn a subagent that can read files, search code, and use other tools to verify conditions before returning a decision.
+
+Agent hooks use the same `&#34;ok&#34;` / `&#34;reason&#34;` response format as prompt hooks, but with a longer default timeout of 60 seconds and up to 50 tool-use turns.
+
+This example verifies that tests pass before allowing Claude to stop:
 
 ```json  theme={null}
 {
   &#34;hooks&#34;: {
-    &#34;PreToolUse&#34;: [
+    &#34;Stop&#34;: [
       {
-        &#34;matcher&#34;: &#34;Edit|Write&#34;,
         &#34;hooks&#34;: [
           {
-            &#34;type&#34;: &#34;command&#34;,
-            &#34;command&#34;: &#34;python3 -c \&#34;import json, sys; data=json.load(sys.stdin); path=data.get(&#39;tool_input&#39;,{}).get(&#39;file_path&#39;,&#39;&#39;); sys.exit(2 if any(p in path for p in [&#39;.env&#39;, &#39;package-lock.json&#39;, &#39;.git/&#39;]) else 0)\&#34;&#34;
+            &#34;type&#34;: &#34;agent&#34;,
+            &#34;prompt&#34;: &#34;Verify that all unit tests pass. Run the test suite and check the results. $ARGUMENTS&#34;,
+            &#34;timeout&#34;: 120
           }
         ]
       }
@@ -330,9 +537,93 @@
 }
 ```
 
+Use prompt hooks when the hook input data alone is enough to make a decision. Use agent hooks when you need to verify something against the actual state of the codebase.
+
+For full configuration options, see [Agent-based hooks](/en/hooks#agent-based-hooks) in the reference.
+
+## Limitations and troubleshooting
+
+### Limitations
+
+* Hooks communicate through stdout, stderr, and exit codes only. They cannot trigger slash commands or tool calls directly.
+* Hook timeout is 10 minutes by default, configurable per hook with the `timeout` field (in seconds).
+* `PostToolUse` hooks cannot undo actions since the tool has already executed.
+* `PermissionRequest` hooks do not fire in [non-interactive mode](/en/headless) (`-p`). Use `PreToolUse` hooks for automated permission decisions.
+* `Stop` hooks fire whenever Claude finishes responding, not only at task completion. They do not fire on user interrupts.
+
+### Hook not firing
+
+The hook is configured but never executes.
+
+* Run `/hooks` and confirm the hook appears under the correct event
+* Check that the matcher pattern matches the tool name exactly (matchers are case-sensitive)
+* Verify you&#39;re triggering the right event type (e.g., `PreToolUse` fires before tool execution, `PostToolUse` fires after)
+* If using `PermissionRequest` hooks in non-interactive mode (`-p`), switch to `PreToolUse` instead
+
+### Hook error in output
+
+You see a message like &#34;PreToolUse hook error: ...&#34; in the transcript.
+
+* Your script exited with a non-zero code unexpectedly. Test it manually by piping sample JSON:
+  ```bash  theme={null}
+  echo &#39;{&#34;tool_name&#34;:&#34;Bash&#34;,&#34;tool_input&#34;:{&#34;command&#34;:&#34;ls&#34;}}&#39; | ./my-hook.sh
+  echo $?  # Check the exit code
+  ```
+* If you see &#34;command not found&#34;, use absolute paths or `$CLAUDE_PROJECT_DIR` to reference scripts
+* If you see &#34;jq: command not found&#34;, install `jq` or use Python/Node.js for JSON parsing
+* If the script isn&#39;t running at all, make it executable: `chmod +x ./my-hook.sh`
+
+### `/hooks` shows no hooks configured
+
+You edited a settings file but the hooks don&#39;t appear in the menu.
+
+* Restart your session or open `/hooks` to reload. Hooks added through the `/hooks` menu take effect immediately, but manual file edits require a reload.
+* Verify your JSON is valid (trailing commas and comments are not allowed)
+* Confirm the settings file is in the correct location: `.claude/settings.json` for project hooks, `~/.claude/settings.json` for global hooks
+
+### Stop hook runs forever
+
+Claude keeps working in an infinite loop instead of stopping.
+
+Your Stop hook script needs to check whether it already triggered a continuation. Parse the `stop_hook_active` field from the JSON input and exit early if it&#39;s `true`:
+
+```bash  theme={null}
+#!/bin/bash
+INPUT=$(cat)
+if [ &#34;$(echo &#34;$INPUT&#34; | jq -r &#39;.stop_hook_active&#39;)&#34; = &#34;true&#34; ]; then
+  exit 0  # Allow Claude to stop
+fi
+# ... rest of your hook logic
+```
+
+### JSON validation failed
+
+Claude Code shows a JSON parsing error even though your hook script outputs valid JSON.
+
+When Claude Code runs a hook, it spawns a shell that sources your profile (`~/.zshrc` or `~/.bashrc`). If your profile contains unconditional `echo` statements, that output gets prepended to your hook&#39;s JSON:
+
+```
+Shell ready on arm64
+{&#34;decision&#34;: &#34;allow&#34;}
+```
+
+Claude Code tries to parse this as JSON and fails. To fix this, wrap echo statements in your shell profile so they only run in interactive shells:
+
+```bash  theme={null}
+# In ~/.zshrc or ~/.bashrc
+if [[ $- == *i* ]]; then
+  echo &#34;Shell ready&#34;
+fi
+```
+
+The `$-` variable contains shell flags, and `i` means interactive. Hooks run in non-interactive shells, so the echo is skipped.
+
+### Debug techniques
+
+Toggle verbose mode with `Ctrl+O` to see hook output in the transcript, or run `claude --debug` for full execution details including which hooks matched and their exit codes.
+
 ## Learn more
 
-* For reference documentation on hooks, see [Hooks reference](/en/hooks).
-* For comprehensive security best practices and safety guidelines, see [Security Considerations](/en/hooks#security-considerations) in the hooks reference documentation.
-* For troubleshooting steps and debugging techniques, see [Debugging](/en/hooks#debugging) in the hooks reference
-  documentation.
+* [Hooks reference](/en/hooks): full event schemas, JSON output format, async hooks, and MCP tool hooks
+* [Security considerations](/en/hooks#security-considerations): review before deploying hooks in shared or production environments
+* [Bash command validator example](https://github.com/anthropics/claude-code/blob/main/examples/hooks/bash_command_validator_example.py): complete reference implementation
</code></pre>
    </div>
</body>
</html>