<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hooks - Diff Report</title>
    <link rel="stylesheet" href="../../css/diff.css">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --card-bg: #16213e;
            --text-color: #eee;
            --accent: #0f3460;
            --add-bg: #1a4d1a;
            --del-bg: #4d1a1a;
            --add-text: #4ade80;
            --del-text: #f87171;
        }
        @media (prefers-color-scheme: light) {
            :root {
                --bg-color: #f5f5f5;
                --card-bg: #fff;
                --text-color: #333;
                --accent: #e0e0e0;
                --add-bg: #d4edda;
                --del-bg: #f8d7da;
                --add-text: #155724;
                --del-text: #721c24;
            }
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 2rem;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        header { margin-bottom: 2rem; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .meta { color: #888; font-size: 0.9rem; }
        .summary {
            background: var(--card-bg);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            display: flex;
            gap: 2rem;
        }
        .stat { display: flex; align-items: center; gap: 0.5rem; }
        .stat.added { color: var(--add-text); }
        .stat.removed { color: var(--del-text); }
        .analysis {
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            border-left: 4px solid #8b5cf6;
        }
        .analysis-header {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #8b5cf6;
        }
        .analysis-content {
            white-space: pre-wrap;
            font-size: 0.95rem;
            line-height: 1.7;
        }
        .diff-container {
            background: var(--card-bg);
            border-radius: 8px;
            overflow: hidden;
        }
        .diff-header {
            background: var(--accent);
            padding: 0.75rem 1rem;
            font-weight: 600;
        }
        .diff-content {
            padding: 1rem;
            overflow-x: auto;
        }
        .diff-content ins {
            background: var(--add-bg);
            color: var(--add-text);
            text-decoration: none;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        .diff-content del {
            background: var(--del-bg);
            color: var(--del-text);
            text-decoration: line-through;
            padding: 0.1em 0.2em;
            border-radius: 2px;
        }
        pre {
            background: var(--accent);
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.85rem;
            margin-top: 2rem;
        }
        a { color: #60a5fa; }
        .back-link { margin-bottom: 1rem; display: inline-block; }
    </style>
</head>
<body>
    <div class="container">
        <a href="../index.html" class="back-link">&larr; Back to daily report</a>

        <header>
            <h1>hooks.md</h1>
            <p class="meta">Changed on 2026-01-30 23:01:27 EST</p>
        </header>

        <div class="summary">
            <div class="stat added">
                <span>+535</span> lines added
            </div>
            <div class="stat removed">
                <span>-511</span> lines removed
            </div>
        </div>

        

        <div class="diff-container">
            <div class="diff-header">Visual Diff</div>
            <div class="diff-content"><span>&gt; ## Documentation Index&para;<br>&gt; Fetch the complete documentation index at: https://code.claude.com/docs/llms.txt&para;<br>&gt; Use this file to discover all available pages before exploring further.&para;<br>&para;<br># Hooks reference&para;<br>&para;<br>&gt; </span><del style="background:#ffe6e6;">This page provides reference documentation for implementing hooks in Claude Code.&para;<br>&para;<br>&lt;Tip&gt;&para;<br>  For a quickstart guide with examples, see [Get started with Claude Code hooks</del><ins style="background:#e6ffe6;">Reference for Claude Code hook events, configuration schema, JSON input/output formats, exit codes, async hooks, prompt hooks, and MCP tool hooks.&para;<br>&para;<br>&lt;Tip&gt;&para;<br>  For a quickstart guide with examples, see [Automate workflows with hooks](/en/hooks-guide).&para;<br>&lt;/Tip&gt;&para;<br>&para;<br>Hooks are user-defined shell commands or LLM prompts that execute automatically at specific points in Claude Code's lifecycle. Use this reference to look up event schemas, configuration options, JSON input/output formats, and advanced features like async hooks and MCP tool hooks. If you're setting up hooks for the first time, start with the [guide</ins><span>](/en/hooks-guide)</span><del style="background:#ffe6e6;">.&para;<br>&lt;/Tip&gt;</del><ins style="background:#e6ffe6;"> instead.</ins><span>&para;<br>&para;<br>## Hook lifecycle&para;<br>&para;<br>Hooks fire at specific points during a Claude Code session.</span><ins style="background:#e6ffe6;"> When an event fires and a matcher matches, Claude Code passes JSON context about the event to your hook handler. For command hooks, this arrives on stdin. Your handler can then inspect the input, take action, and optionally return a decision. Some events fire once per session, while others fire repeatedly inside the agentic loop:</ins><span>&para;<br>&para;<br>&lt;div style={{maxWidth: "500px", margin: "0 auto"}}&gt;&para;<br>  &lt;Frame&gt;&para;<br>    &lt;img src="https://mintcdn.com/claude-code/z2YM37Ycg6eMbID3/images/hooks-lifecycle.png?fit=max&amp;auto=format&amp;n=z2YM37Ycg6eMbID3&amp;q=85&amp;s=5c25fedbc3db6f8882af50c3cc478c32" alt="Hook lifecycle diagram showing the sequence of hooks from SessionStart through the agentic loop to SessionEnd" data-og-width="8876" width="8876" data-og-height="12492" height="12492" data-path="images/hooks-lifecycle.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/claude-code/z2YM37Ycg6eMbID3/images/hooks-lifecycle.png?w=280&amp;fit=max&amp;auto=format&amp;n=z2YM37Ycg6eMbID3&amp;q=85&amp;s=62406fcd5d4a189cc8842ee1bd946b84 280w, https://mintcdn.com/claude-code/z2YM37Ycg6eMbID3/images/hooks-lifecycle.png?w=560&amp;fit=max&amp;auto=format&amp;n=z2YM37Ycg6eMbID3&amp;q=85&amp;s=fa3049022a6973c5f974e0f95b28169d 560w, https://mintcdn.com/claude-code/z2YM37Ycg6eMbID3/images/hooks-lifecycle.png?w=840&amp;fit=max&amp;auto=format&amp;n=z2YM37Ycg6eMbID3&amp;q=85&amp;s=bd2890897db61a03160b93d4f972ff8e 840w, https://mintcdn.com/claude-code/z2YM37Ycg6eMbID3/images/hooks-lifecycle.png?w=1100&amp;fit=max&amp;auto=format&amp;n=z2YM37Ycg6eMbID3&amp;q=85&amp;s=7ae8e098340479347135e39df4a13454 1100w, https://mintcdn.com/claude-code/z2YM37Ycg6eMbID3/images/hooks-lifecycle.png?w=1650&amp;fit=max&amp;auto=format&amp;n=z2YM37Ycg6eMbID3&amp;q=85&amp;s=848a8606aab22c2ccaa16b6a18431e32 1650w, https://mintcdn.com/claude-code/z2YM37Ycg6eMbID3/images/hooks-lifecycle.png?w=2500&amp;fit=max&amp;auto=format&amp;n=z2YM37Ycg6eMbID3&amp;q=85&amp;s=f3a9ef7feb61fa8fe362005aa185efbc 2500w" /&gt;&para;<br>  &lt;/Frame&gt;&para;<br>&lt;/div&gt;&para;<br>&para;<br></span><del style="background:#ffe6e6;">| Hook                 | When it fires                   |&para;<br>| :------------------- | :------------------------------ |&para;<br>| `SessionStart`       | Session begins or resumes       |&para;<br>| `UserPromptSubmit`   | User submits a prompt           |&para;<br>| `PreToolUse`         | Before tool execution           |&para;<br>| `PermissionRequest`  | When permission dialog appears  |&para;<br>| `PostToolUse`        | After tool succeeds             |&para;<br>| `PostToolUseFailure` | After tool fails                |&para;<br>| `SubagentStart`      | When spawning a subagent        |&para;<br>| `SubagentStop`       | When subagent finishes          |&para;<br>| `Stop`               | Claude finishes responding      |&para;<br>| `PreCompact`         | Before context compaction       |&para;<br>| `SessionEnd`         | Session terminates              |&para;<br>| `Notification`       | Claude Code sends notifications |&para;<br>&para;<br>## Configuration&para;<br>&para;<br>Claude Code hooks are configured in your [settings files](/en/settings):&para;<br>&para;<br>* `~/.claude/settings.json` - User settings&para;<br>* `.claude/settings.json` - Project settings&para;<br>* `.claude/settings.local.json` - Local project settings (not committed)&para;<br>* Managed policy settings&para;<br>&para;<br>&lt;Note&gt;&para;<br>  Enterprise administrators can use `allowManagedHooksOnly` to block user, project, and plugin hooks. See [Hook configuration](/en/settings#hook-configuration).&para;<br>&lt;/Note&gt;&para;<br>&para;<br>### Structure&para;<br>&para;<br>Hooks are organized by matchers, where each matcher can have multiple hooks:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "EventName": [&para;<br>      {&para;<br>        "matcher": "ToolPattern",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "your-command-here"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>* **matcher**: Pattern to match tool names, case-sensitive (only applicable for&para;<br>  `PreToolUse`, `PermissionRequest`, and `PostToolUse`)&para;<br>  * Simple strings match exactly: `Write` matches only the Write tool&para;<br>  * Supports regex: `Edit|Write` or `Notebook.*`&para;<br>  * Use `*` to match all tools. You can also use empty string (`""`) or leave&para;<br>    `matcher` blank.&para;<br>* **hooks**: Array of hooks to execute when the pattern matches&para;<br>  * `type`: Hook execution type - `"command"` for bash commands or `"prompt"` for LLM-based evaluation&para;<br>  * `command`: (For `type: "command"`) The bash command to execute (can use `$CLAUDE_PROJECT_DIR` environment variable)&para;<br>  * `prompt`: (For `type: "prompt"`) The prompt to send to the LLM for evaluation&para;<br>  * `timeout`: (Optional) How long a hook should run, in seconds, before canceling that specific hook&para;<br>&para;<br>For events like `UserPromptSubmit`, `Stop`, `SubagentStop`, and `Setup`&para;<br>that don't use matchers, you can omit the matcher field:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "UserPromptSubmit": [&para;<br>      {&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "/path/to/prompt-validator.py"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### Project-Specific Hook Scripts&para;<br>&para;<br>You can use the environment variable `CLAUDE_PROJECT_DIR` (only available when&para;<br>Claude Code spawns the hook command) to reference scripts stored in your project,&para;<br>ensuring they work regardless of Claude's current directory:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PostToolUse": [&para;<br>      {&para;<br>        "matcher": "Write|Edit",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/check-style.sh"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### Plugin hooks&para;<br>&para;<br>[Plugins](/en/plugins) can provide hooks that integrate seamlessly with your user and project hooks. Plugin hooks are automatically merged with your configuration when plugins are enabled.&para;<br>&para;<br>**How plugin hooks work**:&para;<br>&para;<br>* Plugin hooks are defined in the plugin's `hooks/hooks.json` file or in a file given by a custom path to the `hooks` field.&para;<br>* When a plugin is enabled, its hooks are merged with user and project hooks&para;<br>* Multiple hooks from different sources can respond to the same event&para;<br>* Plugin hooks use the `${CLAUDE_PLUGIN_ROOT}` environment variable to reference plugin files&para;<br>&para;<br>**Example plugin hook configuration**:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "description": "Automatic code formatting",&para;<br>  "hooks": {&para;<br>    "PostToolUse": [&para;<br>      {&para;<br>        "matcher": "Write|Edit",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "${CLAUDE_PLUGIN_ROOT}/scripts/format.sh",&para;<br>            "timeout": 30&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;Note&gt;&para;<br>  Plugin hooks use the same format as regular hooks with an optional `description` field to explain the hook's purpose.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>&lt;Note&gt;&para;<br>  Plugin hooks run alongside your custom hooks. If multiple hooks match an event, they all execute in parallel.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>**Environment variables for plugins**:&para;<br>&para;<br>* `${CLAUDE_PLUGIN_ROOT}`: Absolute path to the plugin directory&para;<br>* `${CLAUDE_PROJECT_DIR}`: Project root directory (same as for project hooks)&para;<br>* All standard environment variables are available&para;<br>&para;<br>See the [plugin components reference](/en/plugins-reference#hooks) for details on creating plugin hooks.&para;<br>&para;<br>### Hooks in skills and agents&para;<br>&para;<br>In addition to settings files and plugins, hooks can be defined directly in [skills](/en/skills) and [subagents](/en/sub-agents) using frontmatter. These hooks are scoped to the component's lifecycle and only run when that component is active.&para;<br>&para;<br>**Supported events**: `PreToolUse`, `PostToolUse`, and `Stop`&para;<br>&para;<br>**Example in a Skill**:&para;<br>&para;<br>```yaml  theme={null}&para;<br>---&para;<br>name: secure-operations&para;<br>description: Perform operations with security checks&para;<br>hooks:&para;<br>  PreToolUse:&para;<br>    - matcher: "Bash"&para;<br>      hooks:&para;<br>        - type: command&para;<br>          command: "./scripts/security-check.sh"&para;<br>---&para;<br>```&para;<br>&para;<br>**Example in an agent**:&para;<br>&para;<br>```yaml  theme={null}&para;<br>---&para;<br>name: code-reviewer&para;<br>description: Review code changes&para;<br>hooks:&para;<br>  PostToolUse:&para;<br>    - matcher: "Edit|Write"&para;<br>      hooks:&para;<br>        - type: command&para;<br>          command: "./scripts/run-linter.sh"&para;<br>---&para;<br>```&para;<br>&para;<br>Component-scoped hooks follow the same configuration format as settings-based hooks but are automatically cleaned up when the component finishes executing.&para;<br>&para;<br>**Additional option for skills:**&para;<br>&para;<br>* `once`: Set to `true` to run the hook only once per session. After the first successful execution, the hook is removed. Note: This option is currently only supported for skills, not for agents.&para;<br>&para;<br>## Prompt-Based Hooks&para;<br>&para;<br>In addition to bash command hooks (`type: "command"`), Claude Code supports prompt-based hooks (`type: "prompt"`) that use an LLM to evaluate whether to allow or block an action. Prompt-based hooks are currently only supported for `Stop` and `SubagentStop` hooks, where they enable intelligent, context-aware decisions.&para;<br>&para;<br>### How prompt-based hooks work&para;<br>&para;<br>Instead of executing a bash command, prompt-based hooks:&para;<br>&para;<br>1. Send the hook input and your prompt to a fast LLM (Haiku)&para;<br>2. The LLM responds with structured JSON containing a decision&para;<br>3. Claude Code processes the decision automatically&para;<br>&para;<br>### Configuration&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "Stop": [&para;<br>      {&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "prompt",&para;<br>            "prompt": "Evaluate if Claude should stop: $ARGUMENTS. Check if all tasks are complete."&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>**Fields:**&para;<br>&para;<br>* `type`: Must be `"prompt"`&para;<br>* `prompt`: The prompt text to send to the LLM&para;<br>  * Use `$ARGUMENTS` as a placeholder for the hook input JSON&para;<br>  * If `$ARGUMENTS` is not present, input JSON is appended to the prompt&para;<br>* `timeout`: (Optional) Timeout in seconds (default: 30 seconds)&para;<br>&para;<br>### Response schema&para;<br>&para;<br>The LLM must respond with JSON containing:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "ok": true | false,&para;<br>  "reason": "Explanation for the decision"&para;<br>}&para;<br>```&para;<br>&para;<br>**Response fields:**&para;<br>&para;<br>* `ok`: `true` allows the action, `false` prevents it&para;<br>* `reason`: Required when `ok` is `false`. Explanation shown to Claude&para;<br>&para;<br>### Supported hook events&para;<br>&para;<br>Prompt-based hooks work with any hook event, but are most useful for:&para;<br>&para;<br>* **Stop**: Intelligently decide if Claude should continue working&para;<br>* **SubagentStop**: Evaluate if a subagent has completed its task&para;<br>* **UserPromptSubmit**: Validate user prompts with LLM assistance&para;<br>* **PreToolUse**: Make context-aware permission decisions&para;<br>* **PermissionRequest**: Intelligently allow or deny permission dialogs&para;<br>&para;<br>### Example: Intelligent Stop hook&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "Stop": [&para;<br>      {&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "prompt",&para;<br>            "prompt": "You are evaluating whether Claude should stop working. Context: $ARGUMENTS\n\nAnalyze the conversation and determine if:\n1. All user-requested tasks are complete\n2. Any errors need to be addressed\n3. Follow-up work is needed\n\nRespond with JSON: {\"ok\": true} to allow stopping, or {\"ok\": false, \"reason\": \"your explanation\"} to continue working.",&para;<br>            "timeout": 30&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### Example: SubagentStop with custom logic&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "SubagentStop": [&para;<br>      {&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "prompt",&para;<br>            "prompt": "Evaluate if this subagent should stop. Input: $ARGUMENTS\n\nCheck if:\n- The subagent completed its assigned task\n- Any errors occurred that need fixing\n- Additional context gathering is needed\n\nReturn: {\"ok\": true} to allow stopping, or {\"ok\": false, \"reason\": \"explanation\"} to continue."&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### Comparison with bash command hooks&para;<br>&para;<br>| Feature               | Bash Command Hooks      | Prompt-Based Hooks             |&para;<br>| --------------------- | ----------------------- | ------------------------------ |&para;<br>| **Execution**         | Runs bash script        | Queries LLM                    |&para;<br>| **Decision logic**    | You implement in code   | LLM evaluates context          |&para;<br>| **Setup complexity**  | Requires script file    | Configure prompt               |&para;<br>| **Context awareness** | Limited to script logic | Natural language understanding |&para;<br>| **Performance**       | Fast (local execution)  | Slower (API call)              |&para;<br>| **Use case**          | Deterministic rules     | Context-aware decisions        |&para;<br>&para;<br>### Best practices&para;<br>&para;<br>* **Be specific in prompts**: Clearly state what you want the LLM to evaluate&para;<br>* **Include decision criteria**: List the factors the LLM should consider&para;<br>* **Test your prompts**: Verify the LLM makes correct decisions for your use cases&para;<br>* **Set appropriate timeouts**: Default is 30 seconds, adjust if needed&para;<br>* **Use for complex decisions**: Bash hooks are better for simple, deterministic rules&para;<br>&para;<br>See the [plugin components reference](/en/plugins-reference#hooks) for details on creating plugin hooks.&para;<br>&para;<br>## Hook Events&para;<br>&para;<br>### PreToolUse&para;<br>&para;<br>Runs after Claude creates tool parameters and before processing the tool call.&para;<br>&para;<br>**Common matchers:**&para;<br>&para;<br>* `Task` - Subagent tasks (see [subagents documentation](/en/sub-agents))&para;<br>* `Bash` - Shell commands&para;<br>* `Glob` - File pattern matching&para;<br>* `Grep` - Content search&para;<br>* `Read` - File reading&para;<br>* `Edit` - File editing&para;<br>* `Write` - File writing&para;<br>* `WebFetch`, `WebSearch` - Web operations&para;<br>&para;<br>Use [PreToolUse decision control](#pretooluse-decision-control) to allow, deny, or ask for permission to use the tool.&para;<br>&para;<br>### PermissionRequest&para;<br>&para;<br>Runs when the user is shown a permission dialog.&para;<br>Use [PermissionRequest decision control](#permissionrequest-decision-control) to allow or deny on behalf of the user.&para;<br>&para;<br>Recognizes the same matcher values as PreToolUse.&para;<br>&para;<br>### PostToolUse&para;<br>&para;<br>Runs immediately after a tool completes successfully.&para;<br>&para;<br>Recognizes the same matcher values as PreToolUse.&para;<br>&para;<br>### Notification&para;<br>&para;<br>Runs when Claude Code sends notifications. Supports matchers to filter by notification type.&para;<br>&para;<br>**Common matchers:**&para;<br>&para;<br>* `permission_prompt` - Permission requests from Claude Code&para;<br>* `idle_prompt` - When Claude is waiting for user input (after 60+ seconds of idle time)&para;<br>* `auth_success` - Authentication success notifications&para;<br>* `elicitation_dialog` - When Claude Code needs input for MCP tool elicitation&para;<br>&para;<br>You can use matchers to run different hooks for different notification types, or omit the matcher to run hooks for all notifications.&para;<br>&para;<br>**Example: Different notifications for different types**&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "Notification": [&para;<br>      {&para;<br>        "matcher": "permission_prompt",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "/path/to/permission-alert.sh"&para;<br>          }&para;<br>        ]&para;<br>      },&para;<br>      {&para;<br>        "matcher": "idle_prompt",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "/path/to/idle-notification.sh"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### UserPromptSubmit&para;<br>&para;<br>Runs when the user submits a prompt, before Claude processes it. This allows you&para;<br>to add additional context based on the prompt/conversation, validate prompts, or&para;<br>block certain types of prompts.&para;<br>&para;<br>### Stop&para;<br>&para;<br>Runs when the main Claude Code agent has finished responding. Does not run if&para;<br>the stoppage occurred due to a user interrupt.&para;<br>&para;<br>### SubagentStop&para;<br>&para;<br>Runs when a Claude Code subagent (Task tool call) has finished responding.&para;<br>&para;<br>### PreCompact&para;<br>&para;<br>Runs before Claude Code is about to run a compact operation.&para;<br>&para;<br>**Matchers:**&para;<br>&para;<br>* `manual` - Invoked from `/compact`&para;<br>* `auto` - Invoked from auto-compact (due to full context window)&para;<br>&para;<br>### Setup&para;<br>&para;<br>Runs when Claude Code is invoked with repository setup and maintenance flags (`--init`, `--init-only`, or `--maintenance`). Use this hook for operations you don't want on every session—such as installing dependencies, running migrations, or periodic maintenance tasks.&para;<br>&para;<br>&lt;Note&gt;&para;<br>  Use **Setup** hooks for one-time or occasional operations (dependency installation, migrations, cleanup). Use **SessionStart** hooks for things you want on every session (loading context, setting environment variables). Setup hooks require explicit flags because running them automatically would slow down every session start.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>**Matchers:**&para;<br>&para;<br>* `init` - Invoked from `--init` or `--init-only` flags&para;<br>* `maintenance` - Invoked from `--maintenance` flag&para;<br>&para;<br>Setup hooks have access to the `CLAUDE_ENV_FILE` environment variable for persisting environment variables, similar to SessionStart hooks.&para;<br>&para;<br>### SessionStart&para;<br>&para;<br>Runs when Claude Code starts a new session or resumes an existing session (which&para;<br>currently does start a new session under the hood). Useful for loading development context like existing issues or recent changes to your codebase, or setting up environment variables.&para;<br>&para;<br>&lt;Note&gt;&para;<br>  For one-time operations like installing dependencies or running migrations, use [Setup hooks](#setup) instead. SessionStart runs on every session, so keep these hooks fast.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>**Matchers:**&para;<br>&para;<br>* `startup` - Invoked from startup&para;<br>* `resume` - Invoked from `--resume`, `--continue`, or `/resume`&para;<br>* `clear` - Invoked from `/clear`&para;<br>* `compact` - Invoked from auto or manual compact.&para;<br>&para;<br>#### Persisting environment variables&para;<br>&para;<br>SessionStart hooks have access to the `CLAUDE_ENV_FILE` environment variable, which provides a file path where you can persist environment variables for subsequent bash commands.&para;<br>&para;<br>**Example: Setting individual environment variables**&para;<br>&para;<br>```bash  theme={null}&para;<br>#!/bin/bash&para;<br>&para;<br>if [ -n "$CLAUDE_ENV_FILE" ]; then&para;<br>  echo 'export NODE_ENV=production' &gt;&gt; "$CLAUDE_ENV_FILE"&para;<br>  echo 'export API_KEY=your-api-key' &gt;&gt; "$CLAUDE_ENV_FILE"&para;<br>  echo 'export PATH="$PATH:./node_modules/.bin"' &gt;&gt; "$CLAUDE_ENV_FILE"&para;<br>fi&para;<br>&para;<br>exit 0&para;<br>```&para;<br>&para;<br>**Example: Persisting all environment changes from the hook**&para;<br>&para;<br>When your setup modifies the environment (for example, `nvm use`), capture and persist all changes by diffing the environment:&para;<br>&para;<br>```bash  theme={null}&para;<br>#!/bin/bash&para;<br>&para;<br>ENV_BEFORE=$(export -p | sort)&para;<br>&para;<br># Run your setup commands that modify the environment&para;<br>source ~/.nvm/nvm.sh&para;<br>nvm use 20&para;<br>&para;<br>if [ -n "$CLAUDE_ENV_FILE" ]; then&para;<br>  ENV_AFTER=$(export -p | sort)&para;<br>  comm -13 &lt;(echo "$ENV_BEFORE") &lt;(echo "$ENV_AFTER") &gt;&gt; "$CLAUDE_ENV_FILE"&para;<br>fi&para;<br>&para;<br>exit 0&para;<br>```&para;<br>&para;<br>Any variables written to this file will be available in all subsequent bash commands that Claude Code executes during the session.&para;<br>&para;<br>&lt;Note&gt;&para;<br>  `CLAUDE_ENV_FILE` is only available for SessionStart hooks. Other hook types do not have access to this variable.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>### SessionEnd&para;<br>&para;<br>Runs when a Claude Code session ends. Useful for cleanup tasks, logging session&para;<br>statistics, or saving session state.&para;<br>&para;<br>The `reason` field in the hook input will be one of:&para;<br>&para;<br>* `clear` - Session cleared with /clear command&para;<br>* `logout` - User logged out&para;<br>* `prompt_input_exit` - User exited while prompt input was visible&para;<br>* `other` - Other exit reasons&para;<br>&para;<br>## Hook Input&para;<br>&para;<br>Hooks receive JSON data via stdin containing session information and&para;<br>event-specific data:&para;<br>&para;<br>```typescript  theme={null}&para;<br>{&para;<br>  // Common fields&para;<br>  session_id: string&para;<br>  transcript_path: string  // Path to conversation JSON&para;<br>  cwd: string              // The current working directory when the hook is invoked&para;<br>  permission_mode: string  // Current permission mode: "default", "plan", "acceptEdits", "dontAsk", or "bypassPermissions"&para;<br>&para;<br>  // Event-specific fields&para;<br>  hook_event_name: string&para;<br>  ...&para;<br>}&para;<br>```&para;<br>&para;<br>### PreToolUse Input&para;<br>&para;<br>The exact schema for `tool_input` depends on the tool. Here are examples for commonly hooked tools.&para;<br>&para;<br>#### Bash tool&para;<br>&para;<br>The Bash tool is the most commonly hooked tool for command validation:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "PreToolUse",&para;<br>  "tool_name": "Bash",&para;<br>  "tool_input": {&para;<br>    "command": "psql -c 'SELECT * FROM users'",&para;<br>    "description": "Query the users table",&para;<br>    "timeout": 120000&para;<br>  },&para;<br>  "tool_use_id": "toolu_01ABC123..."&para;<br>}&para;<br>```&para;<br>&para;<br>| Field               | Type    | Description                                   |&para;<br>| :------------------ | :------ | :-------------------------------------------- |&para;<br>| `command`           | string  | The shell command to execute                  |&para;<br>| `description`       | string  | Optional description of what the command does |&para;<br>| `timeout`           | number  | Optional timeout in milliseconds              |&para;<br>| `run_in_background` | boolean | Whether to run the command in background      |&para;<br>&para;<br>#### Write tool&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "PreToolUse",&para;<br>  "tool_name": "Write",&para;<br>  "tool_input": {&para;<br>    "file_path": "/path/to/file.txt",&para;<br>    "content": "file content"&para;<br>  },&para;<br>  "tool_use_id": "toolu_01ABC123..."&para;<br>}&para;<br>```&para;<br>&para;<br>| Field       | Type   | Description                        |&para;<br>| :---------- | :----- | :--------------------------------- |&para;<br>| `file_path` | string | Absolute path to the file to write |&para;<br>| `content`   | string | Content to write to the file       |&para;<br>&para;<br>#### Edit tool&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "PreToolUse",&para;<br>  "tool_name": "Edit",&para;<br>  "tool_input": {&para;<br>    "file_path": "/path/to/file.txt",&para;<br>    "old_string": "original text",&para;<br>    "new_string": "replacement text"&para;<br>  },&para;<br>  "tool_use_id": "toolu_01ABC123..."&para;<br>}&para;<br>```&para;<br>&para;<br>| Field         | Type    | Description                                         |&para;<br>| :------------ | :------ | :-------------------------------------------------- |&para;<br>| `file_path`   | string  | Absolute path to the file to edit                   |&para;<br>| `old_string`  | string  | Text to find and replace                            |&para;<br>| `new_string`  | string  | Replacement text                                    |&para;<br>| `replace_all` | boolean | Whether to replace all occurrences (default: false) |&para;<br>&para;<br>#### Read tool&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "PreToolUse",&para;<br>  "tool_name": "Read",&para;<br>  "tool_input": {&para;<br>    "file_path": "/path/to/file.txt"&para;<br>  },&para;<br>  "tool_use_id": "toolu_01ABC123..."&para;<br>}&para;<br>```&para;<br>&para;<br>| Field       | Type   | Description                                |&para;<br>| :---------- | :----- | :----------------------------------------- |&para;<br>| `file_path` | string | Absolute path to the file to read          |&para;<br>| `offset`    | number | Optional line number to start reading from |&para;<br>| `limit`     | number | Optional number of lines to read           |&para;<br>&para;<br>### PostToolUse Input&para;<br>&para;<br>The exact schema for `tool_input` and `tool_response` depends on the tool.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "PostToolUse",&para;<br>  "tool_name": "Write",&para;<br>  "tool_input": {&para;<br>    "file_path": "/path/to/file.txt",&para;<br>    "content": "file content"&para;<br>  },&para;<br>  "tool_response": {&para;<br>    "filePath": "/path/to/file.txt",&para;<br>    "success": true&para;<br>  },&para;<br>  "tool_use_id": "toolu_01ABC123..."&para;<br>}&para;<br>```&para;<br>&para;<br>### Notification Input&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "Notification",&para;<br>  "message": "Claude needs your permission to use Bash",&para;<br>  "notification_type": "permission_prompt"&para;<br>}&para;<br>```&para;<br>&para;<br>### UserPromptSubmit Input&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "UserPromptSubmit",&para;<br>  "prompt": "Write a function to calculate the factorial of a number"&para;<br>}&para;<br>```&para;<br>&para;<br>### Stop Input&para;<br>&para;<br>`stop_hook_active` is true when Claude Code is already continuing as a result of&para;<br>a stop hook. Check this value or process the transcript to prevent Claude Code&para;<br>from running indefinitely.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "Stop",&para;<br>  "stop_hook_active": true&para;<br>}&para;<br>```&para;<br>&para;<br>### SubagentStop Input&para;<br>&para;<br>Triggered when a subagent finishes. The `transcript_path` is the main session's transcript, while `agent_transcript_path` is the subagent's own transcript stored in a nested `subagents/` folder.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "~/.claude/projects/.../abc123.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "SubagentStop",&para;<br>  "stop_hook_active": false,&para;<br>  "agent_id": "def456",&para;<br>  "agent_transcript_path": "~/.claude/projects/.../abc123/subagents/agent-def456.jsonl"&para;<br>}&para;<br>```&para;<br>&para;<br>### PreCompact Input&para;<br>&para;<br>For `manual`, `custom_instructions` comes from what the user passes into&para;<br>`/compact`. For `auto`, `custom_instructions` is empty.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "PreCompact",&para;<br>  "trigger": "manual",&para;<br>  "custom_instructions": ""&para;<br>}&para;<br>```&para;<br>&para;<br>### Setup Input&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "Setup",&para;<br>  "trigger": "init"&para;<br>}&para;<br>```&para;<br>&para;<br>The `trigger` field will be either `"init"` (from `--init` or `--init-only`) or `"maintenance"` (from `--maintenance`).&para;<br>&para;<br>### SessionStart Input&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "SessionStart",&para;<br>  "source": "startup",&para;<br>  "model": "claude-sonnet-4-20250514"&para;<br>}&para;<br>```&para;<br>&para;<br>The `source` field indicates how the session started: `"startup"` for new sessions, `"resume"` for resumed sessions, `"clear"` after `/clear`, or `"compact"` after compaction. The `model` field contains the model identifier when available. If you start Claude Code with `claude --agent &lt;name&gt;`, an `agent_type` field contains the agent name.&para;<br>&para;<br>### SubagentStart Input&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "SubagentStart",&para;<br>  "agent_id": "agent-abc123",&para;<br>  "agent_type": "Explore"&para;<br>}&para;<br>```&para;<br>&para;<br>Triggered when a subagent is spawned. The `agent_id` field contains the unique identifier for the subagent, and `agent_type` contains the agent name (built-in agents like `"Bash"`, `"Explore"`, `"Plan"`, or custom agent names).&para;<br>&para;<br>### SessionEnd Input&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "SessionEnd",&para;<br>  "reason": "exit"&para;<br>}&para;<br>```&para;<br>&para;<br>## Hook Output&para;<br>&para;<br>There are two mutually exclusive ways for hooks to return output back to Claude Code. The output&para;<br>communicates whether to block and any feedback that should be shown to Claude&para;<br>and the user.&para;<br>&para;<br>### Simple: Exit Code&para;<br>&para;<br>Hooks communicate status through exit codes, stdout, and stderr:&para;<br>&para;<br>* **Exit code 0**: Success. `stdout` is shown to the user in verbose mode&para;<br>  (ctrl+o), except for `UserPromptSubmit` and `SessionStart`, where stdout is&para;<br>  added to the context. JSON output in `stdout` is parsed for structured control&para;<br>  (see [Advanced: JSON Output](#advanced-json-output)).&para;<br>* **Exit code 2**: Blocking error. Only `stderr` is used as the error message&para;<br>  and fed back to Claude. The format is `[command]: {stderr}`. JSON in `stdout`&para;<br>  is **not** processed for exit code 2. See per-hook-event behavior below.&para;<br>* **Other exit codes**: Non-blocking error. `stderr` is shown to the user in verbose mode (ctrl+o) with&para;<br>  format `Failed with non-blocking status code: {stderr}`. If `stderr` is empty,&para;<br>  it shows `No stderr output`. Execution continues.&para;<br>&para;<br>&lt;Warning&gt;&para;<br>  Reminder: Claude Code does not see stdout if the exit code is 0, except for&para;<br>  the `UserPromptSubmit` hook where stdout is injected as context.&para;<br>&lt;/Warning&gt;&para;<br>&para;<br>#### Exit Code 2 Behavior&para;<br>&para;<br>| Hook Event          | Behavior                                                           |&para;<br>| ------------------- | ------------------------------------------------------------------ |&para;<br>| `PreToolUse`        | Blocks the tool call, shows stderr to Claude                       |&para;<br>| `PermissionRequest` | Denies the permission, shows stderr to Claude                      |&para;<br>| `PostToolUse`       | Shows stderr to Claude (tool already ran)                          |&para;<br>| `Notification`      | N/A, shows stderr to user only                                     |&para;<br>| `UserPromptSubmit`  | Blocks prompt processing, erases prompt, shows stderr to user only |&para;<br>| `Stop`              | Blocks stoppage, shows stderr to Claude                            |&para;<br>| `SubagentStop`      | Blocks stoppage, shows stderr to Claude subagent                   |&para;<br>| `PreCompact`        | N/A, shows stderr to user only                                     |&para;<br>| `Setup`             | N/A, shows stderr to user only                                     |&para;<br>| `SessionStart`      | N/A, shows stderr to user only                                     |&para;<br>| `SessionEnd`        | N/A, shows stderr to user only                                     |&para;<br>&para;<br>### Advanced: JSON Output&para;<br>&para;<br>Hooks can return structured JSON in `stdout` for more sophisticated control.&para;<br>&para;<br>&lt;Warning&gt;&para;<br>  JSON output is only processed when the hook exits with code 0. If your hook&para;<br>  exits with code 2 (blocking error), `stderr` text is used directly—any JSON in `stdout`&para;<br>  is ignored. For other non-zero exit codes, only `stderr` is shown to the user in verbose mode (ctrl+o).&para;<br>&lt;/Warning&gt;&para;<br>&para;<br>#### Common JSON Fields&para;<br>&para;<br>All hook types can include these optional fields:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "continue": true, // Whether Claude should continue after hook execution (default: true)&para;<br>  "stopReason": "string", // Message shown when continue is false&para;<br>&para;<br>  "suppressOutput": true, // Hide stdout from transcript mode (default: false)&para;<br>  "systemMessage": "string" // Optional warning message shown to the user&para;<br>}&para;<br>```&para;<br>&para;<br>If `continue` is false, Claude stops processing after the hooks run.&para;<br>&para;<br>* For `PreToolUse`, this is different from `"permissionDecision": "deny"`, which&para;<br>  only blocks a specific tool call and provides automatic feedback to Claude.&para;<br>* For `PostToolUse`, this is different from `"decision": "block"`, which&para;<br>  provides automated feedback to Claude.&para;<br>* For `UserPromptSubmit`, this prevents the prompt from being processed.&para;<br>* For `Stop` and `SubagentStop`, this takes precedence over any&para;<br>  `"decision": "block"` output.&para;<br>* In all cases, `"continue" = false` takes precedence over any&para;<br>  `"decision": "block"` output.&para;<br>&para;<br>`stopReason` accompanies `continue` with a reason shown to the user, not shown&para;<br>to Claude.&para;<br>&para;<br>#### `PreToolUse` Decision Control&para;<br>&para;<br>`PreToolUse` hooks can control whether a tool call proceeds.&para;<br>&para;<br>* `"allow"` bypasses the permission system. `permissionDecisionReason` is shown&para;<br>  to the user but not to Claude.&para;<br>* `"deny"` prevents the tool call from executing. `permissionDecisionReason` is&para;<br>  shown to Claude.&para;<br>* `"ask"` asks the user to confirm the tool call in the UI.&para;<br>  `permissionDecisionReason` is shown to the user but not to Claude.&para;<br>&para;<br>Additionally, hooks can modify tool inputs before execution using `updatedInput`:&para;<br>&para;<br>* `updatedInput` modifies the tool's input parameters before the tool executes&para;<br>* Combine with `"permissionDecision": "allow"` to modify the input and auto-approve the tool call&para;<br>* Combine with `"permissionDecision": "ask"` to modify the input and show it to the user for confirmation&para;<br>&para;<br>Hooks can also provide context to Claude using `additionalContext`:&para;<br>&para;<br>* `"hookSpecificOutput.additionalContext"` adds a string to Claude's context before the tool executes.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "PreToolUse",&para;<br>    "permissionDecision": "allow",&para;<br>    "permissionDecisionReason": "My reason here",&para;<br>    "updatedInput": {&para;<br>      "field_to_modify": "new value"&para;<br>    },&para;<br>    "additionalContext": "Current environment: production. Proceed with caution."&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;Note&gt;&para;<br>  The `decision` and `reason` fields are deprecated for PreToolUse hooks.&para;<br>  Use `hookSpecificOutput.permissionDecision` and&para;<br>  `hookSpecificOutput.permissionDecisionReason` instead. The deprecated fields&para;<br>  `"approve"` and `"block"` map to `"allow"` and `"deny"` respectively.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>#### `PermissionRequest` Decision Control&para;<br>&para;<br>`PermissionRequest` hooks can allow or deny permission requests shown to the user.&para;<br>&para;<br>* For `"behavior": "allow"` you can also optionally pass in an `"updatedInput"` that modifies the tool's input parameters before the tool executes.&para;<br>* For `"behavior": "deny"` you can also optionally pass in a `"message"` string that tells the model why the permission was denied, and a boolean `"interrupt"` which will stop Claude.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "PermissionRequest",&para;<br>    "decision": {&para;<br>      "behavior": "allow",&para;<br>      "updatedInput": {&para;<br>        "command": "npm run lint"&para;<br>      }&para;<br>    }&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>#### `PostToolUse` Decision Control&para;<br>&para;<br>`PostToolUse` hooks can provide feedback to Claude after tool execution.&para;<br>&para;<br>* `"block"` automatically prompts Claude with `reason`.&para;<br>* `undefined` does nothing. `reason` is ignored.&para;<br>* `"hookSpecificOutput.additionalContext"` adds context for Claude to consider.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "decision": "block" | undefined,&para;<br>  "reason": "Explanation for decision",&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "PostToolUse",&para;<br>    "additionalContext": "Additional information for Claude"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>#### `UserPromptSubmit` Decision Control&para;<br>&para;<br>`UserPromptSubmit` hooks can control whether a user prompt is processed and add context.&para;<br>&para;<br>**Adding context (exit code 0):**&para;<br>There are two ways to add context to the conversation:&para;<br>&para;<br>1. **Plain text stdout** (simpler): Any non-JSON text written to stdout is added&para;<br>   as context. This is the easiest way to inject information.&para;<br>&para;<br>2. **JSON with `additionalContext`** (structured): Use the JSON format below for&para;<br>   more control. The `additionalContext` field is added as context.&para;<br>&para;<br>Both methods work with exit code 0. Plain stdout is shown as hook output in&para;<br>the transcript; `additionalContext` is added more discretely.&para;<br>&para;<br>**Blocking prompts:**&para;<br>&para;<br>* `"decision": "block"` prevents the prompt from being processed. The submitted&para;<br>  prompt is erased from context. `"reason"` is shown to the user but not added&para;<br>  to context.&para;<br>* `"decision": undefined` (or omitted) allows the prompt to proceed normally.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "decision": "block" | undefined,&para;<br>  "reason": "Explanation for decision",&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "UserPromptSubmit",&para;<br>    "additionalContext": "My additional context here"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;Note&gt;&para;<br>  The JSON format isn't required for simple use cases. To add context, you can print plain text to stdout with exit code 0. Use JSON when you need to&para;<br>  block prompts or want more structured control.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>#### `Stop`/`SubagentStop` Decision Control&para;<br>&para;<br>`Stop` and `SubagentStop` hooks can control whether Claude must continue.&para;<br>&para;<br>* `"block"` prevents Claude from stopping. You must populate `reason` for Claude&para;<br>  to know how to proceed.&para;<br>* `undefined` allows Claude to stop. `reason` is ignored.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "decision": "block" | undefined,&para;<br>  "reason": "Must be provided when Claude is blocked from stopping"&para;<br>}&para;<br>```&para;<br>&para;<br>#### `Setup` Decision Control&para;<br>&para;<br>`Setup` hooks allow you to load context and configure the environment during repository initialization or maintenance.&para;<br>&para;<br>* `"hookSpecificOutput.additionalContext"` adds the string to the context.&para;<br>* Multiple hooks' `additionalContext` values are concatenated.&para;<br>* Setup hooks have access to `CLAUDE_ENV_FILE` for persisting environment variables.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "Setup",&para;<br>    "additionalContext": "Repository initialized with custom configuration"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>#### `SessionStart` Decision Control&para;<br>&para;<br>`SessionStart` hooks allow you to load in context at the start of a session.&para;<br>&para;<br>* `"hookSpecificOutput.additionalContext"` adds the string to the context.&para;<br>* Multiple hooks' `additionalContext` values are concatenated.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "SessionStart",&para;<br>    "additionalContext": "My additional context here"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>#### `SessionEnd` Decision Control&para;<br>&para;<br>`SessionEnd` hooks run when a session ends. They cannot block session termination&para;<br>but can perform cleanup tasks.&para;<br>&para;<br>#### Exit Code Example: Bash Command Validation&para;<br>&para;<br>```python  theme={null}&para;<br>#!/usr/bin/env python3&para;<br>import json&para;<br>import re&para;<br>import sys&para;<br>&para;<br># Define validation rules as a list of (regex pattern, message) tuples&para;<br>VALIDATION_RULES = [&para;<br>    (&para;<br>        r"\bgrep\b(?!.*\|)",&para;<br>        "Use 'rg' (ripgrep) instead of 'grep' for better performance and features",&para;<br>    ),&para;<br>    (&para;<br>        r"\bfind\s+\S+\s+-name\b",&para;<br>        "Use 'rg --files | rg pattern' or 'rg --files -g pattern' instead of 'find -name' for better performance",&para;<br>    ),&para;<br>]&para;<br>&para;<br>&para;<br>def validate_command(command: str) -&gt; list[str]:&para;<br>    issues = []&para;<br>    for pattern, message in VALIDATION_RULES:&para;<br>        if re.search(pattern, command):&para;<br>            issues.append(message)&para;<br>    return issues&para;<br>&para;<br>&para;<br>try:&para;<br>    input_data = json.load(sys.stdin)&para;<br>except json.JSONDecodeError as e:&para;<br>    print(f"Error: Invalid JSON input: {e}", file=sys.stderr)&para;<br>    sys.exit(1)&para;<br>&para;<br>tool_name = input_data.get("tool_name", "")&para;<br>tool_input = input_data.get("tool_input", {})&para;<br>command = tool_input.get("command", "")&para;<br>&para;<br>if tool_name != "Bash" or not command:&para;<br>    sys.exit(1)&para;<br>&para;<br># Validate the command&para;<br>issues = validate_command(command)&para;<br>&para;<br>if issues:&para;<br>    for message in issues:&para;<br>        print(f"• {message}", file=sys.stderr)&para;<br>    # Exit code 2 blocks tool call and shows stderr to Claude&para;<br>    sys.exit(2)&para;<br>```&para;<br>&para;<br>#### JSON Output Example: UserPromptSubmit to Add Context and Validation&para;<br>&para;<br>&lt;Note&gt;&para;<br>  For `UserPromptSubmit` hooks, you can inject context using either method:&para;<br>&para;<br>  * **Plain text stdout** with exit code 0: Simplest approach, prints text&para;<br>  * **JSON output** with exit code 0: Use `"decision": "block"` to reject prompts,&para;<br>    or `additionalContext` for structured context injection&para;<br>&para;<br>  Remember: Exit code 2 only uses `stderr` for the error message. To block using&para;<br>  JSON (with a custom reason), use `"decision": "block"` with exit code 0.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>```python  theme={null}&para;<br>#!/usr/bin/env python3&para;<br>import json&para;<br>import sys&para;<br>import re&para;<br>import datetime&para;<br>&para;<br># Load input from stdin&para;<br>try:&para;<br>    input_data = json.load(sys.stdin)&para;<br>except json.JSONDecodeError as e:&para;<br>    print(f"Error: Invalid JSON input: {e}", file=sys.stderr)&para;<br>    sys.exit(1)&para;<br>&para;<br>prompt = input_data.get("prompt", "")&para;<br>&para;<br># Check for sensitive patterns&para;<br>sensitive_patterns = [&para;<br>    (r"(?i)\b(password|secret|key|token)\s*[:=]", "Prompt contains potential secrets"),&para;<br>]&para;<br>&para;<br>for pattern, message in sensitive_patterns:&para;<br>    if re.search(pattern, prompt):&para;<br>        # Use JSON output to block with a specific reason&para;<br>        output = {&para;<br>            "decision": "block",&para;<br>            "reason": f"Security policy violation: {message}. Please rephrase your request without sensitive information."&para;<br>        }&para;<br>        print(json.dumps(output))&para;<br>        sys.exit(0)&para;<br>&para;<br># Add current time to context&para;<br>context = f"Current time: {datetime.datetime.now()}"&para;<br>print(context)&para;<br>&para;<br>"""&para;<br>The following is also equivalent:&para;<br>print(json.dumps({&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "UserPromptSubmit",&para;<br>    "additionalContext": context,&para;<br>  },&para;<br>}))&para;<br>"""&para;<br>&para;<br># Allow the prompt to proceed with the additional context&para;<br>sys.exit(0)&para;<br>```&para;<br>&para;<br>#### JSON Output Example: PreToolUse with Approval&para;<br>&para;<br>```python  theme={null}&para;<br>#!/usr/bin/env python3&para;<br>import json&para;<br>import sys&para;<br>&para;<br># Load input from stdin&para;<br>try:&para;<br>    input_data = json.load(sys.stdin)&para;<br>except json.JSONDecodeError as e:&para;<br>    print(f"Error: Invalid JSON input: {e}", file=sys.stderr)&para;<br>    sys.exit(1)&para;<br>&para;<br>tool_name = input_data.get("tool_name", "")&para;<br>tool_input = input_data.get("tool_input", {})&para;<br>&para;<br># Example: Auto-approve file reads for documentation files&para;<br>if tool_name == "Read":&para;<br>    file_path = tool_input.get("file_path", "")&para;<br>    if file_path.endswith((".md", ".mdx", ".txt", ".json")):&para;<br>        # Use JSON output to auto-approve the tool call&para;<br>        output = {&para;<br>            "decision": "approve",&para;<br>            "reason": "Documentation file auto-approved",&para;<br>            "suppressOutput": True  # Don't show in verbose mode&para;<br>        }&para;<br>        print(json.dumps(output))&para;<br>        sys.exit(0)&para;<br>&para;<br># For other cases, let the normal permission flow proceed&para;<br>sys.exit(0)&para;<br>```&para;<br>&para;<br>## Working with MCP Tools&para;<br>&para;<br>Claude Code hooks work seamlessly with&para;<br>[Model Context Protocol (MCP) tools](/en/mcp). When MCP servers&para;<br>provide tools, they appear with a special naming pattern that you can match in&para;<br>your hooks.&para;<br>&para;<br>### MCP Tool Naming&para;<br>&para;<br>MCP tools follow the pattern `mcp__&lt;server&gt;__&lt;tool&gt;`, for example:&para;<br>&para;<br>* `mcp__memory__create_entities` - Memory server's create entities tool&para;<br>* `mcp__filesystem__read_file` - Filesystem server's read file tool&para;<br>* `mcp__github__search_repositories` - GitHub server's search tool&para;<br>&para;<br>### Configuring Hooks for MCP Tools&para;<br>&para;<br>You can target specific MCP tools or entire MCP servers:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PreToolUse": [&para;<br>      {&para;<br>        "matcher": "mcp__memory__.*",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "echo 'Memory operation initiated' &gt;&gt; ~/mcp-operations.log"&para;<br>          }&para;<br>        ]&para;<br>      },&para;<br>      {&para;<br>        "matcher": "mcp__.*__write.*",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "/home/user/scripts/validate-mcp-write.py"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>## Examples&para;<br>&para;<br>&lt;Tip&gt;&para;<br>  For practical examples including code formatting, notifications, and file protection, see [More Examples](/en/hooks-guide#more-examples) in the get started guide.&para;<br>&lt;/Tip&gt;&para;<br>&para;<br>## Security Considerations&para;<br>&para;<br>### Disclaimer&para;<br>&para;<br>**USE AT YOUR OWN RISK**: Claude Code hooks execute arbitrary shell commands on&para;<br>your system automatically. By using hooks, you acknowledge that:&para;<br>&para;<br>* You are solely responsible for the commands you configure&para;<br>* Hooks can modify, delete, or access any files your user account can access&para;<br>* Malicious or poorly written hooks can cause data loss or system damage&para;<br>* Anthropic provides no warranty and assumes no liability for any damages&para;<br>  resulting from hook usage&para;<br>* You should thoroughly test hooks in a safe environment before production use&para;<br>&para;<br>Always review and understand any hook commands before adding them to your&para;<br>configuration.&para;<br>&para;<br>### Security Best Practices&para;<br>&para;<br>Here are some key practices for writing more secure hooks:&para;<br>&para;<br>1. **Validate and sanitize inputs** - Never trust input data blindly&para;<br>2. **Always quote shell variables** - Use `"$VAR"` not `$VAR`&para;<br>3. **Block path traversal** - Check for `..` in file paths&para;<br>4. **Use absolute paths** - Specify full paths for scripts (use&para;<br>   "\$CLAUDE\_PROJECT\_DIR" for the project path)&para;<br>5. **Skip sensitive files** - Avoid `.env`, `.git/`, keys, etc.&para;<br>&para;<br>### Configuration Safety&para;<br>&para;<br>Direct edits to hooks in settings files don't take effect immediately. Claude&para;<br>Code:&para;<br>&para;<br>1. Captures a snapshot of hooks at startup&para;<br>2. Uses this snapshot throughout the session&para;<br>3. Warns if hooks are modified externally&para;<br>4. Requires review in `/hooks` menu for changes to apply&para;<br>&para;<br>This prevents malicious hook modifications from affecting your current session.&para;<br>&para;<br>## Hook Execution Details&para;<br>&para;<br>* **Timeout**: 60-second execution limit by default, configurable per command.&para;<br>  * A timeout for an individual command does not affect the other commands.&para;<br>* **Parallelization**: All matching hooks run in parallel&para;<br>* **Deduplication**: Multiple identical hook commands are deduplicated automatically&para;<br>* **Environment**: Runs in current directory with Claude Code's environment&para;<br>  * The `CLAUDE_PROJECT_DIR` environment variable is available and contains the&para;<br>    absolute path to the project root directory (where Claude Code was started)&para;<br>  * The `CLAUDE_CODE_REMOTE` environment variable indicates whether the hook is running in a remote (web) environment (`"true"`) or local CLI environment (not set or empty). Use this to run different logic based on execution context.&para;<br>* **Input**: JSON via stdin&para;<br>* **Output**:&para;<br>  * PreToolUse/PermissionRequest/PostToolUse/Stop/SubagentStop: Progress shown in verbose mode (ctrl+o)&para;<br>  * Notification/SessionEnd: Logged to debug only (`--debug`)&para;<br>  * UserPromptSubmit/SessionStart/Setup: stdout added as context for Claude&para;<br>&para;<br>## Debugging&para;<br>&para;<br>### Basic Troubleshooting&para;<br>&para;<br>If your hooks aren't working:&para;<br>&para;<br>1. **Check configuration** - Run `/hooks` to see if your hook is registered&para;<br>2. **Verify syntax** - Ensure your JSON settings are valid&para;<br>3. **Test commands** - Run hook commands manually first&para;<br>4. **Check permissions** - Make sure scripts are executable&para;<br>5. **Review logs** - Use `claude --debug` to see hook execution details&para;<br>&para;<br>Common issues:&para;<br>&para;<br>* **Quotes not escaped** - Use `\"` inside JSON strings&para;<br>* **Wrong matcher** - Check tool names match exactly (case-sensitive)&para;<br>* **Command not found** - Use full paths for scripts&para;<br>&para;<br>### Advanced Debugging&para;<br>&para;<br>For complex hook issues:&para;<br>&para;<br>1. **Inspect hook execution** - Use `claude --debug` to see detailed hook&para;<br>   execution&para;<br>2. **Validate JSON schemas** - Test hook input/output with external tools&para;<br>3. **Check environment variables** - Verify Claude Code's environment is correct&para;<br>4. **Test edge cases** - Try hooks with unusual file paths or inputs&para;<br>5. **Monitor system resources** - Check for resource exhaustion during hook&para;<br>   execution&para;<br>6. **Use structured logging** - Implement logging in your hook scripts&para;<br>&para;<br>### Debug Output Example&para;<br>&para;<br>Use `claude --debug` to see hook execution details:&para;<br>&para;<br>```&para;<br>[DEBUG] Executing hooks for PostToolUse:Write&para;<br>[DEBUG] Getting matching hook commands for PostToolUse with query: Write&para;<br>[DEBUG] Found 1 hook matchers in settings&para;<br>[DEBUG] Matched 1 hooks for query "Write"&para;<br>[DEBUG] Found 1 hook commands to execute&para;<br>[DEBUG] Executing hook command: &lt;Your command&gt; with timeout 60000ms&para;<br>[DEBUG] Hook command completed with status 0: &lt;Your stdout&gt;&para;<br>```&para;<br>&para;<br>Progress messages appear in verbose mode (ctrl+o) showing:&para;<br>&para;<br>* Which hook is running&para;<br>* Command being executed&para;<br>* Success/failure status&para;<br>* Output or error messages</del><ins style="background:#e6ffe6;">The table below summarizes when each event fires. The [Hook events](#hook-events) section documents the full input schema and decision control options for each one.&para;<br>&para;<br>| Event                | When it fires                                        |&para;<br>| :------------------- | :--------------------------------------------------- |&para;<br>| `SessionStart`       | When a session begins or resumes                     |&para;<br>| `UserPromptSubmit`   | When you submit a prompt, before Claude processes it |&para;<br>| `PreToolUse`         | Before a tool call executes. Can block it            |&para;<br>| `PermissionRequest`  | When a permission dialog appears                     |&para;<br>| `PostToolUse`        | After a tool call succeeds                           |&para;<br>| `PostToolUseFailure` | After a tool call fails                              |&para;<br>| `Notification`       | When Claude Code sends a notification                |&para;<br>| `SubagentStart`      | When a subagent is spawned                           |&para;<br>| `SubagentStop`       | When a subagent finishes                             |&para;<br>| `Stop`               | When Claude finishes responding                      |&para;<br>| `PreCompact`         | Before context compaction                            |&para;<br>| `SessionEnd`         | When a session terminates                            |&para;<br>&para;<br>### How a hook resolves&para;<br>&para;<br>To see how these pieces fit together, consider this `PreToolUse` hook that blocks destructive shell commands. The hook runs `block-rm.sh` before every Bash tool call:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PreToolUse": [&para;<br>      {&para;<br>        "matcher": "Bash",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": ".claude/hooks/block-rm.sh"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>The script reads the JSON input from stdin, extracts the command, and blocks it if it contains `rm -rf`:&para;<br>&para;<br>```bash  theme={null}&para;<br>#!/bin/bash&para;<br># .claude/hooks/block-rm.sh&para;<br>COMMAND=$(jq -r '.tool_input.command')&para;<br>&para;<br>if echo "$COMMAND" | grep -q 'rm -rf'; then&para;<br>  echo '{"decision":"block","reason":"Destructive command blocked by hook"}'&para;<br>else&para;<br>  exit 0  # allow the command&para;<br>fi&para;<br>```&para;<br>&para;<br>Now suppose Claude Code decides to run `Bash "rm -rf /tmp/build"`. Here's what happens:&para;<br>&para;<br>&lt;Frame&gt;&para;<br>  &lt;img src="https://mintcdn.com/claude-code/s7NM0vfd_wres2nf/images/hook-resolution.svg?fit=max&amp;auto=format&amp;n=s7NM0vfd_wres2nf&amp;q=85&amp;s=7c13f51ffcbc37d22a593b27e2f2de72" alt="Hook resolution flow: PreToolUse event fires, matcher checks for Bash match, hook handler runs, result returns to Claude Code" data-og-width="780" width="780" data-og-height="290" height="290" data-path="images/hook-resolution.svg" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/claude-code/s7NM0vfd_wres2nf/images/hook-resolution.svg?w=280&amp;fit=max&amp;auto=format&amp;n=s7NM0vfd_wres2nf&amp;q=85&amp;s=36a39a07e8bc1995dcb4639e09846905 280w, https://mintcdn.com/claude-code/s7NM0vfd_wres2nf/images/hook-resolution.svg?w=560&amp;fit=max&amp;auto=format&amp;n=s7NM0vfd_wres2nf&amp;q=85&amp;s=6568d90c596c7605bbac2c325b0a0c86 560w, https://mintcdn.com/claude-code/s7NM0vfd_wres2nf/images/hook-resolution.svg?w=840&amp;fit=max&amp;auto=format&amp;n=s7NM0vfd_wres2nf&amp;q=85&amp;s=255a6f68b9475a0e41dbde7b88002dad 840w, https://mintcdn.com/claude-code/s7NM0vfd_wres2nf/images/hook-resolution.svg?w=1100&amp;fit=max&amp;auto=format&amp;n=s7NM0vfd_wres2nf&amp;q=85&amp;s=dcecf8d5edc88cd2bc49deb006d5760d 1100w, https://mintcdn.com/claude-code/s7NM0vfd_wres2nf/images/hook-resolution.svg?w=1650&amp;fit=max&amp;auto=format&amp;n=s7NM0vfd_wres2nf&amp;q=85&amp;s=04fe51bf69ae375e9fd517f18674e35f 1650w, https://mintcdn.com/claude-code/s7NM0vfd_wres2nf/images/hook-resolution.svg?w=2500&amp;fit=max&amp;auto=format&amp;n=s7NM0vfd_wres2nf&amp;q=85&amp;s=b1b76e0b77fddb5c7fa7bf302dacd80b 2500w" /&gt;&para;<br>&lt;/Frame&gt;&para;<br>&para;<br>&lt;Steps&gt;&para;<br>  &lt;Step title="Event fires"&gt;&para;<br>    The `PreToolUse` event fires. Claude Code sends the tool input as JSON on stdin to the hook:&para;<br>&para;<br>    ```json  theme={null}&para;<br>    { "tool_name": "Bash", "tool_input": { "command": "rm -rf /tmp/build" }, ... }&para;<br>    ```&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Matcher checks"&gt;&para;<br>    The matcher `"Bash"` matches the tool name, so `block-rm.sh` runs. If you omit the matcher or use `"*"`, the hook runs on every occurrence of the event. Hooks only skip when a matcher is defined and doesn't match.&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Hook handler runs"&gt;&para;<br>    The script extracts `"rm -rf /tmp/build"` from the input and finds `rm -rf`, so it prints a decision to stdout:&para;<br>&para;<br>    ```json  theme={null}&para;<br>    { "decision": "block", "reason": "Destructive command blocked by hook" }&para;<br>    ```&para;<br>&para;<br>    If the command had been safe (like `npm test`), the script would hit `exit 0` instead, which tells Claude Code to allow the tool call with no further action.&para;<br>  &lt;/Step&gt;&para;<br>&para;<br>  &lt;Step title="Claude Code acts on the result"&gt;&para;<br>    Claude Code reads the JSON decision, blocks the tool call, and shows Claude the reason.&para;<br>  &lt;/Step&gt;&para;<br>&lt;/Steps&gt;&para;<br>&para;<br>The [Configuration](#configuration) section below documents the full schema, and each [hook event](#hook-events) section documents what input your command receives and what output it can return.&para;<br>&para;<br>## Configuration&para;<br>&para;<br>Hooks are defined in JSON settings files. The configuration has three levels of nesting:&para;<br>&para;<br>1. Choose a [hook event](#hook-events) to respond to, like `PreToolUse` or `Stop`&para;<br>2. Add a [matcher group](#matcher-patterns) to filter when it fires, like "only for the Bash tool"&para;<br>3. Define one or more [hook handlers](#hook-handler-fields) to run when matched&para;<br>&para;<br>See [How a hook resolves](#how-a-hook-resolves) above for a complete walkthrough with an annotated example.&para;<br>&para;<br>&lt;Note&gt;&para;<br>  This page uses specific terms for each level: **hook event** for the lifecycle point, **matcher group** for the filter, and **hook handler** for the shell command, prompt, or agent that runs. "Hook" on its own refers to the general feature.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>### Hook locations&para;<br>&para;<br>Where you define a hook determines its scope:&para;<br>&para;<br>| Location                                                   | Scope                         | Shareable                          |&para;<br>| :--------------------------------------------------------- | :---------------------------- | :--------------------------------- |&para;<br>| `~/.claude/settings.json`                                  | All your projects             | No, local to your machine          |&para;<br>| `.claude/settings.json`                                    | Single project                | Yes, can be committed to the repo  |&para;<br>| `.claude/settings.local.json`                              | Single project                | No, gitignored                     |&para;<br>| Managed policy settings                                    | Organization-wide             | Yes, admin-controlled              |&para;<br>| [Plugin](/en/plugins) `hooks/hooks.json`                   | When plugin is enabled        | Yes, bundled with the plugin       |&para;<br>| [Skill](/en/skills) or [agent](/en/sub-agents) frontmatter | While the component is active | Yes, defined in the component file |&para;<br>&para;<br>For details on settings file resolution, see [settings](/en/settings). Enterprise administrators can use `allowManagedHooksOnly` to block user, project, and plugin hooks. See [Hook configuration](/en/settings#hook-configuration).&para;<br>&para;<br>### Matcher patterns&para;<br>&para;<br>The `matcher` field is a regex string that filters when hooks fire. Use `"*"`, `""`, or omit `matcher` entirely to match all occurrences. Each event type matches on a different field:&para;<br>&para;<br>| Event                                                                  | What the matcher filters  | Example matcher values                                                         |&para;<br>| :--------------------------------------------------------------------- | :------------------------ | :----------------------------------------------------------------------------- |&para;<br>| `PreToolUse`, `PostToolUse`, `PostToolUseFailure`, `PermissionRequest` | tool name                 | `Bash`, `Edit\|Write`, `mcp__.*`                                               |&para;<br>| `SessionStart`                                                         | how the session started   | `startup`, `resume`, `clear`, `compact`                                        |&para;<br>| `SessionEnd`                                                           | why the session ended     | `clear`, `logout`, `prompt_input_exit`, `bypass_permissions_disabled`, `other` |&para;<br>| `Notification`                                                         | notification type         | `permission_prompt`, `idle_prompt`, `auth_success`, `elicitation_dialog`       |&para;<br>| `SubagentStart`                                                        | agent type                | `Bash`, `Explore`, `Plan`, or custom agent names                               |&para;<br>| `PreCompact`                                                           | what triggered compaction | `manual`, `auto`                                                               |&para;<br>| `SubagentStop`                                                         | agent type                | same values as `SubagentStart`                                                 |&para;<br>| `UserPromptSubmit`, `Stop`                                             | no matcher support        | always fires on every occurrence                                               |&para;<br>&para;<br>The matcher is a regex, so `Edit|Write` matches either tool and `Notebook.*` matches any tool starting with Notebook. The matcher runs against a field from the [JSON input](#hook-input-and-output) that Claude Code sends to your hook on stdin. For tool events, that field is `tool_name`. Each [hook event](#hook-events) section lists the full set of matcher values and the input schema for that event.&para;<br>&para;<br>This example runs a linting script only when Claude writes or edits a file:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PostToolUse": [&para;<br>      {&para;<br>        "matcher": "Edit|Write",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "/path/to/lint-check.sh"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>`UserPromptSubmit` and `Stop` don't support matchers and always fire on every occurrence. If you add a `matcher` field to these events, it is silently ignored.&para;<br>&para;<br>#### Match MCP tools&para;<br>&para;<br>[MCP](/en/mcp) server tools appear as regular tools in tool events (`PreToolUse`, `PostToolUse`, `PostToolUseFailure`, `PermissionRequest`), so you can match them the same way you match any other tool name.&para;<br>&para;<br>MCP tools follow the naming pattern `mcp__&lt;server&gt;__&lt;tool&gt;`, for example:&para;<br>&para;<br>* `mcp__memory__create_entities`: Memory server's create entities tool&para;<br>* `mcp__filesystem__read_file`: Filesystem server's read file tool&para;<br>* `mcp__github__search_repositories`: GitHub server's search tool&para;<br>&para;<br>Use regex patterns to target specific MCP tools or groups of tools:&para;<br>&para;<br>* `mcp__memory__.*` matches all tools from the `memory` server&para;<br>* `mcp__.*__write.*` matches any tool containing "write" from any server&para;<br>&para;<br>This example logs all memory server operations and validates write operations from any MCP server:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PreToolUse": [&para;<br>      {&para;<br>        "matcher": "mcp__memory__.*",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "echo 'Memory operation initiated' &gt;&gt; ~/mcp-operations.log"&para;<br>          }&para;<br>        ]&para;<br>      },&para;<br>      {&para;<br>        "matcher": "mcp__.*__write.*",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "/home/user/scripts/validate-mcp-write.py"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### Hook handler fields&para;<br>&para;<br>Each object in the inner `hooks` array is a hook handler: the shell command, LLM prompt, or agent that runs when the matcher matches. There are three types:&para;<br>&para;<br>* **[Command hooks](#command-hook-fields)** (`type: "command"`): run a shell command. Your script receives the event's [JSON input](#hook-input-and-output) on stdin and communicates results back through exit codes and stdout.&para;<br>* **[Prompt hooks](#prompt-and-agent-hook-fields)** (`type: "prompt"`): send a prompt to a Claude model for single-turn evaluation. The model returns a yes/no decision as JSON. See [Prompt-based hooks](#prompt-based-hooks).&para;<br>* **[Agent hooks](#prompt-and-agent-hook-fields)** (`type: "agent"`): spawn a subagent that can use tools like Read, Grep, and Glob to verify conditions before returning a decision. See [Agent-based hooks](#agent-based-hooks).&para;<br>&para;<br>#### Common fields&para;<br>&para;<br>These fields apply to all hook types:&para;<br>&para;<br>| Field           | Required | Description                                                                                                                                   |&para;<br>| :-------------- | :------- | :-------------------------------------------------------------------------------------------------------------------------------------------- |&para;<br>| `type`          | yes      | `"command"`, `"prompt"`, or `"agent"`                                                                                                         |&para;<br>| `timeout`       | no       | Seconds before canceling. Defaults: 600 for command, 30 for prompt, 60 for agent                                                              |&para;<br>| `statusMessage` | no       | Custom spinner message displayed while the hook runs                                                                                          |&para;<br>| `once`          | no       | If `true`, runs only once per session then is removed. Skills only, not agents. See [Hooks in skills and agents](#hooks-in-skills-and-agents) |&para;<br>&para;<br>#### Command hook fields&para;<br>&para;<br>In addition to the [common fields](#common-fields), command hooks accept these fields:&para;<br>&para;<br>| Field     | Required | Description                                                                                                         |&para;<br>| :-------- | :------- | :------------------------------------------------------------------------------------------------------------------ |&para;<br>| `command` | yes      | Shell command to execute                                                                                            |&para;<br>| `async`   | no       | If `true`, runs in the background without blocking. See [Run hooks in the background](#run-hooks-in-the-background) |&para;<br>&para;<br>#### Prompt and agent hook fields&para;<br>&para;<br>In addition to the [common fields](#common-fields), prompt and agent hooks accept these fields:&para;<br>&para;<br>| Field    | Required | Description                                                                                 |&para;<br>| :------- | :------- | :------------------------------------------------------------------------------------------ |&para;<br>| `prompt` | yes      | Prompt text to send to the model. Use `$ARGUMENTS` as a placeholder for the hook input JSON |&para;<br>| `model`  | no       | Model to use for evaluation. Defaults to a fast model                                       |&para;<br>&para;<br>All matching hooks run in parallel, and identical handlers are deduplicated automatically. Handlers run in the current directory with Claude Code's environment. The `$CLAUDE_CODE_REMOTE` environment variable is set to `"true"` in remote web environments and not set in the local CLI.&para;<br>&para;<br>### Reference scripts by path&para;<br>&para;<br>Use environment variables to reference hook scripts relative to the project or plugin root, regardless of the working directory when the hook runs:&para;<br>&para;<br>* `$CLAUDE_PROJECT_DIR`: the project root. Wrap in quotes to handle paths with spaces.&para;<br>* `${CLAUDE_PLUGIN_ROOT}`: the plugin's root directory, for scripts bundled with a [plugin](/en/plugins).&para;<br>&para;<br>&lt;Tabs&gt;&para;<br>  &lt;Tab title="Project scripts"&gt;&para;<br>    This example uses `$CLAUDE_PROJECT_DIR` to run a style checker from the project's `.claude/hooks/` directory after any `Write` or `Edit` tool call:&para;<br>&para;<br>    ```json  theme={null}&para;<br>    {&para;<br>      "hooks": {&para;<br>        "PostToolUse": [&para;<br>          {&para;<br>            "matcher": "Write|Edit",&para;<br>            "hooks": [&para;<br>              {&para;<br>                "type": "command",&para;<br>                "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/check-style.sh"&para;<br>              }&para;<br>            ]&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    }&para;<br>    ```&para;<br>  &lt;/Tab&gt;&para;<br>&para;<br>  &lt;Tab title="Plugin scripts"&gt;&para;<br>    Define plugin hooks in `hooks/hooks.json` with an optional top-level `description` field. When a plugin is enabled, its hooks merge with your user and project hooks.&para;<br>&para;<br>    This example runs a formatting script bundled with the plugin:&para;<br>&para;<br>    ```json  theme={null}&para;<br>    {&para;<br>      "description": "Automatic code formatting",&para;<br>      "hooks": {&para;<br>        "PostToolUse": [&para;<br>          {&para;<br>            "matcher": "Write|Edit",&para;<br>            "hooks": [&para;<br>              {&para;<br>                "type": "command",&para;<br>                "command": "${CLAUDE_PLUGIN_ROOT}/scripts/format.sh",&para;<br>                "timeout": 30&para;<br>              }&para;<br>            ]&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    }&para;<br>    ```&para;<br>&para;<br>    See the [plugin components reference](/en/plugins-reference#hooks) for details on creating plugin hooks.&para;<br>  &lt;/Tab&gt;&para;<br>&lt;/Tabs&gt;&para;<br>&para;<br>### Hooks in skills and agents&para;<br>&para;<br>In addition to settings files and plugins, hooks can be defined directly in [skills](/en/skills) and [subagents](/en/sub-agents) using frontmatter. These hooks are scoped to the component's lifecycle and only run when that component is active.&para;<br>&para;<br>All hook events are supported. For subagents, `Stop` hooks are automatically converted to `SubagentStop` since that is the event that fires when a subagent completes.&para;<br>&para;<br>Hooks use the same configuration format as settings-based hooks but are scoped to the component's lifetime and cleaned up when it finishes.&para;<br>&para;<br>This skill defines a `PreToolUse` hook that runs a security validation script before each `Bash` command:&para;<br>&para;<br>```yaml  theme={null}&para;<br>---&para;<br>name: secure-operations&para;<br>description: Perform operations with security checks&para;<br>hooks:&para;<br>  PreToolUse:&para;<br>    - matcher: "Bash"&para;<br>      hooks:&para;<br>        - type: command&para;<br>          command: "./scripts/security-check.sh"&para;<br>---&para;<br>```&para;<br>&para;<br>Agents use the same format in their YAML frontmatter.&para;<br>&para;<br>### The `/hooks` menu&para;<br>&para;<br>Type `/hooks` in Claude Code to open the interactive hooks manager, where you can view, add, and delete hooks without editing settings files directly. For a step-by-step walkthrough, see [Set up your first hook](/en/hooks-guide#set-up-your-first-hook) in the guide.&para;<br>&para;<br>Each hook in the menu is labeled with a bracket prefix indicating its source:&para;<br>&para;<br>* `[User]`: from `~/.claude/settings.json`&para;<br>* `[Project]`: from `.claude/settings.json`&para;<br>* `[Local]`: from `.claude/settings.local.json`&para;<br>* `[Plugin]`: from a plugin's `hooks/hooks.json`, read-only&para;<br>&para;<br>### Disable or remove hooks&para;<br>&para;<br>To remove a hook, delete its entry from the settings JSON file, or use the `/hooks` menu and select the hook to delete it.&para;<br>&para;<br>To temporarily disable all hooks without removing them, set `"disableAllHooks": true` in your settings file or use the toggle in the `/hooks` menu. There is no way to disable an individual hook while keeping it in the configuration.&para;<br>&para;<br>Direct edits to hooks in settings files don't take effect immediately. Claude Code captures a snapshot of hooks at startup and uses it throughout the session. This prevents malicious or accidental hook modifications from taking effect mid-session without your review. If hooks are modified externally, Claude Code warns you and requires review in the `/hooks` menu before changes apply.&para;<br>&para;<br>## Hook input and output&para;<br>&para;<br>Hooks receive JSON data via stdin and communicate results through exit codes, stdout, and stderr. This section covers fields and behavior common to all events. Each event's section under [Hook events](#hook-events) includes its specific input schema and decision control options.&para;<br>&para;<br>### Common input fields&para;<br>&para;<br>All hook events receive these fields via stdin as JSON, in addition to event-specific fields documented in each [hook event](#hook-events) section:&para;<br>&para;<br>| Field             | Description                                                                                                                        |&para;<br>| :---------------- | :--------------------------------------------------------------------------------------------------------------------------------- |&para;<br>| `session_id`      | Current session identifier                                                                                                         |&para;<br>| `transcript_path` | Path to conversation JSON                                                                                                          |&para;<br>| `cwd`             | Current working directory when the hook is invoked                                                                                 |&para;<br>| `permission_mode` | Current [permission mode](/en/iam#permission-modes): `"default"`, `"plan"`, `"acceptEdits"`, `"dontAsk"`, or `"bypassPermissions"` |&para;<br>| `hook_event_name` | Name of the event that fired                                                                                                       |&para;<br>&para;<br>For example, a `PreToolUse` hook for a Bash command receives this on stdin:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/home/user/.claude/projects/.../transcript.jsonl",&para;<br>  "cwd": "/home/user/my-project",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "PreToolUse",&para;<br>  "tool_name": "Bash",&para;<br>  "tool_input": {&para;<br>    "command": "npm test"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>The `tool_name` and `tool_input` fields are event-specific. Each [hook event](#hook-events) section documents the additional fields for that event.&para;<br>&para;<br>### Exit code output&para;<br>&para;<br>The exit code from your hook command tells Claude Code whether the action should proceed, be blocked, or be ignored.&para;<br>&para;<br>**Exit 0** means success. Claude Code parses stdout for [JSON output fields](#json-output) like `decision` or `reason`. JSON output is only processed on exit 0. For most events, stdout is only shown in verbose mode (`Ctrl+O`). The exceptions are `UserPromptSubmit` and `SessionStart`, where stdout is added as context that Claude can see and act on.&para;<br>&para;<br>**Exit 2** means a blocking error. Claude Code ignores stdout and any JSON in it. Instead, stderr text is fed back to Claude as an error message. The effect depends on the event: `PreToolUse` blocks the tool call, `UserPromptSubmit` rejects the prompt, and so on. See [exit code 2 behavior](#exit-code-2-behavior-per-event) for the full list.&para;<br>&para;<br>**Any other exit code** is a non-blocking error. stderr is shown in verbose mode (`Ctrl+O`) and execution continues.&para;<br>&para;<br>For example, a hook command script that blocks dangerous Bash commands:&para;<br>&para;<br>```bash  theme={null}&para;<br>#!/bin/bash&para;<br># Reads JSON input from stdin, checks the command&para;<br>command=$(jq -r '.tool_input.command' &lt; /dev/stdin)&para;<br>&para;<br>if [[ "$command" == rm* ]]; then&para;<br>  echo "Blocked: rm commands are not allowed" &gt;&amp;2&para;<br>  exit 2  # Blocking error: tool call is prevented&para;<br>fi&para;<br>&para;<br>exit 0  # Success: tool call proceeds&para;<br>```&para;<br>&para;<br>#### Exit code 2 behavior per event&para;<br>&para;<br>Exit code 2 is the way a hook signals "stop, don't do this." The effect depends on the event, because some events represent actions that can be blocked (like a tool call that hasn't happened yet) and others represent things that already happened or can't be prevented.&para;<br>&para;<br>| Hook event           | Can block? | What happens on exit 2                                    |&para;<br>| :------------------- | :--------- | :-------------------------------------------------------- |&para;<br>| `PreToolUse`         | Yes        | Blocks the tool call                                      |&para;<br>| `PermissionRequest`  | Yes        | Denies the permission                                     |&para;<br>| `UserPromptSubmit`   | Yes        | Blocks prompt processing and erases the prompt            |&para;<br>| `Stop`               | Yes        | Prevents Claude from stopping, continues the conversation |&para;<br>| `SubagentStop`       | Yes        | Prevents the subagent from stopping                       |&para;<br>| `PostToolUse`        | No         | Shows stderr to Claude (tool already ran)                 |&para;<br>| `PostToolUseFailure` | No         | Shows stderr to Claude (tool already failed)              |&para;<br>| `Notification`       | No         | Shows stderr to user only                                 |&para;<br>| `SubagentStart`      | No         | Shows stderr to user only                                 |&para;<br>| `SessionStart`       | No         | Shows stderr to user only                                 |&para;<br>| `SessionEnd`         | No         | Shows stderr to user only                                 |&para;<br>| `PreCompact`         | No         | Shows stderr to user only                                 |&para;<br>&para;<br>### JSON output&para;<br>&para;<br>You must choose one approach per hook, not both: either use exit codes alone for signaling, or exit 0 and print JSON for structured control. Claude Code only processes JSON on exit 0. If you exit 2, any JSON is ignored.&para;<br>&para;<br>Instead of relying on exit codes alone, hooks can print JSON to stdout on exit 0. Claude Code reads specific fields from this JSON to decide what to do next.&para;<br>&para;<br>Your hook's stdout must contain only the JSON object. If your shell profile prints text on startup, it can interfere with JSON parsing. See [JSON validation failed](/en/hooks-guide#json-validation-failed) in the troubleshooting guide.&para;<br>&para;<br>The JSON object has two parts:&para;<br>&para;<br>* **Top-level fields** like `continue` and `decision` work across all events. These are listed in the table below.&para;<br>* **`hookSpecificOutput`** is a nested object for event-specific fields like `permissionDecision` or `additionalContext`. It requires a `hookEventName` field set to the event name, like `"PreToolUse"` or `"Stop"`. Each event's decision control section under [Hook events](#hook-events) documents what fields go here.&para;<br>&para;<br>| Field            | Default | Description                                                                                                                                           |&para;<br>| :--------------- | :------ | :---------------------------------------------------------------------------------------------------------------------------------------------------- |&para;<br>| `continue`       | `true`  | If `false`, Claude stops processing entirely after the hook runs. Takes precedence over event-specific fields like `decision` or `permissionDecision` |&para;<br>| `stopReason`     | none    | Message shown to the user when `continue` is `false`. Not shown to Claude                                                                             |&para;<br>| `suppressOutput` | `false` | If `true`, hides stdout from verbose mode output                                                                                                      |&para;<br>| `systemMessage`  | none    | Warning message shown to the user                                                                                                                     |&para;<br>&para;<br>This example uses a top-level field to stop Claude:&para;<br>&para;<br>```json  theme={null}&para;<br>{ "continue": false, "stopReason": "Build failed, fix errors before continuing" }&para;<br>```&para;<br>&para;<br>This example uses `hookSpecificOutput` to deny a PreToolUse tool call:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "PreToolUse",&para;<br>    "permissionDecision": "deny",&para;<br>    "permissionDecisionReason": "Database writes are not allowed"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>For extended examples including Bash command validation, prompt filtering, and auto-approval scripts, see [What you can automate](/en/hooks-guide#what-you-can-automate) in the guide and the [Bash command validator reference implementation](https://github.com/anthropics/claude-code/blob/main/examples/hooks/bash_command_validator_example.py).&para;<br>&para;<br>## Hook events&para;<br>&para;<br>Each event corresponds to a point in Claude Code's lifecycle where hooks can run. The sections below are ordered to match the lifecycle: from session setup through the agentic loop to session end. Each section describes when the event fires, what matchers it supports, the JSON input it receives, and how to control behavior through output.&para;<br>&para;<br>### SessionStart&para;<br>&para;<br>Runs when Claude Code starts a new session or resumes an existing session. Useful for loading development context like existing issues or recent changes to your codebase, or setting up environment variables. For static context that does not require a script, use [CLAUDE.md](/en/memory) instead.&para;<br>&para;<br>SessionStart runs on every session, so keep these hooks fast.&para;<br>&para;<br>The matcher value corresponds to how the session was initiated:&para;<br>&para;<br>| Matcher   | When it fires                          |&para;<br>| :-------- | :------------------------------------- |&para;<br>| `startup` | New session                            |&para;<br>| `resume`  | `--resume`, `--continue`, or `/resume` |&para;<br>| `clear`   | `/clear`                               |&para;<br>| `compact` | Auto or manual compaction              |&para;<br>&para;<br>#### SessionStart input&para;<br>&para;<br>In addition to the [common input fields](#common-input-fields), SessionStart hooks receive `source`, `model`, and optionally `agent_type`. The `source` field indicates how the session started: `"startup"` for new sessions, `"resume"` for resumed sessions, `"clear"` after `/clear`, or `"compact"` after compaction. The `model` field contains the model identifier. If you start Claude Code with `claude --agent &lt;name&gt;`, an `agent_type` field contains the agent name.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "SessionStart",&para;<br>  "source": "startup",&para;<br>  "model": "claude-sonnet-4-5-20250929"&para;<br>}&para;<br>```&para;<br>&para;<br>#### SessionStart decision control&para;<br>&para;<br>Any text your hook script prints to stdout is added as context for Claude. In addition to the [JSON output fields](#json-output) available to all hooks, you can return these event-specific fields:&para;<br>&para;<br>| Field               | Description                                                               |&para;<br>| :------------------ | :------------------------------------------------------------------------ |&para;<br>| `additionalContext` | String added to Claude's context. Multiple hooks' values are concatenated |&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "SessionStart",&para;<br>    "additionalContext": "My additional context here"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>#### Persist environment variables&para;<br>&para;<br>SessionStart hooks have access to the `CLAUDE_ENV_FILE` environment variable, which provides a file path where you can persist environment variables for subsequent Bash commands.&para;<br>&para;<br>To set individual environment variables, write `export` statements to `CLAUDE_ENV_FILE`. Use append (`&gt;&gt;`) to preserve variables set by other hooks:&para;<br>&para;<br>```bash  theme={null}&para;<br>#!/bin/bash&para;<br>&para;<br>if [ -n "$CLAUDE_ENV_FILE" ]; then&para;<br>  echo 'export NODE_ENV=production' &gt;&gt; "$CLAUDE_ENV_FILE"&para;<br>  echo 'export DEBUG_LOG=true' &gt;&gt; "$CLAUDE_ENV_FILE"&para;<br>  echo 'export PATH="$PATH:./node_modules/.bin"' &gt;&gt; "$CLAUDE_ENV_FILE"&para;<br>fi&para;<br>&para;<br>exit 0&para;<br>```&para;<br>&para;<br>To capture all environment changes from setup commands, compare the exported variables before and after:&para;<br>&para;<br>```bash  theme={null}&para;<br>#!/bin/bash&para;<br>&para;<br>ENV_BEFORE=$(export -p | sort)&para;<br>&para;<br># Run your setup commands that modify the environment&para;<br>source ~/.nvm/nvm.sh&para;<br>nvm use 20&para;<br>&para;<br>if [ -n "$CLAUDE_ENV_FILE" ]; then&para;<br>  ENV_AFTER=$(export -p | sort)&para;<br>  comm -13 &lt;(echo "$ENV_BEFORE") &lt;(echo "$ENV_AFTER") &gt;&gt; "$CLAUDE_ENV_FILE"&para;<br>fi&para;<br>&para;<br>exit 0&para;<br>```&para;<br>&para;<br>Any variables written to this file will be available in all subsequent Bash commands that Claude Code executes during the session.&para;<br>&para;<br>&lt;Note&gt;&para;<br>  `CLAUDE_ENV_FILE` is available for SessionStart hooks. Other hook types do not have access to this variable.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>### UserPromptSubmit&para;<br>&para;<br>Runs when the user submits a prompt, before Claude processes it. This allows you&para;<br>to add additional context based on the prompt/conversation, validate prompts, or&para;<br>block certain types of prompts.&para;<br>&para;<br>#### UserPromptSubmit input&para;<br>&para;<br>In addition to the [common input fields](#common-input-fields), UserPromptSubmit hooks receive the `prompt` field containing the text the user submitted.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "UserPromptSubmit",&para;<br>  "prompt": "Write a function to calculate the factorial of a number"&para;<br>}&para;<br>```&para;<br>&para;<br>#### UserPromptSubmit decision control&para;<br>&para;<br>`UserPromptSubmit` hooks can control whether a user prompt is processed and add context. All [JSON output fields](#json-output) are available.&para;<br>&para;<br>There are two ways to add context to the conversation on exit code 0:&para;<br>&para;<br>* **Plain text stdout**: any non-JSON text written to stdout is added as context&para;<br>* **JSON with `additionalContext`**: use the JSON format below for more control. The `additionalContext` field is added as context&para;<br>&para;<br>Plain stdout is shown as hook output in the transcript. The `additionalContext` field is added more discretely.&para;<br>&para;<br>To block a prompt, return a JSON object with `decision` set to `"block"`:&para;<br>&para;<br>| Field               | Description                                                                                                        |&para;<br>| :------------------ | :----------------------------------------------------------------------------------------------------------------- |&para;<br>| `decision`          | `"block"` prevents the prompt from being processed and erases it from context. Omit to allow the prompt to proceed |&para;<br>| `reason`            | Shown to the user when `decision` is `"block"`. Not added to context                                               |&para;<br>| `additionalContext` | String added to Claude's context                                                                                   |&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "decision": "block",&para;<br>  "reason": "Explanation for decision",&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "UserPromptSubmit",&para;<br>    "additionalContext": "My additional context here"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;Note&gt;&para;<br>  The JSON format isn't required for simple use cases. To add context, you can print plain text to stdout with exit code 0. Use JSON when you need to&para;<br>  block prompts or want more structured control.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>### PreToolUse&para;<br>&para;<br>Runs after Claude creates tool parameters and before processing the tool call. Matches on tool name: `Bash`, `Edit`, `Write`, `Read`, `Glob`, `Grep`, `Task`, `WebFetch`, `WebSearch`, and any [MCP tool names](#match-mcp-tools).&para;<br>&para;<br>Use [PreToolUse decision control](#pretooluse-decision-control) to allow, deny, or ask for permission to use the tool.&para;<br>&para;<br>#### PreToolUse input&para;<br>&para;<br>In addition to the [common input fields](#common-input-fields), PreToolUse hooks receive `tool_name`, `tool_input`, and `tool_use_id`. The `tool_input` fields depend on the tool:&para;<br>&para;<br>##### Bash&para;<br>&para;<br>Executes shell commands.&para;<br>&para;<br>| Field               | Type    | Example            | Description                                   |&para;<br>| :------------------ | :------ | :----------------- | :-------------------------------------------- |&para;<br>| `command`           | string  | `"npm test"`       | The shell command to execute                  |&para;<br>| `description`       | string  | `"Run test suite"` | Optional description of what the command does |&para;<br>| `timeout`           | number  | `120000`           | Optional timeout in milliseconds              |&para;<br>| `run_in_background` | boolean | `false`            | Whether to run the command in background      |&para;<br>&para;<br>##### Write&para;<br>&para;<br>Creates or overwrites a file.&para;<br>&para;<br>| Field       | Type   | Example               | Description                        |&para;<br>| :---------- | :----- | :-------------------- | :--------------------------------- |&para;<br>| `file_path` | string | `"/path/to/file.txt"` | Absolute path to the file to write |&para;<br>| `content`   | string | `"file content"`      | Content to write to the file       |&para;<br>&para;<br>##### Edit&para;<br>&para;<br>Replaces a string in an existing file.&para;<br>&para;<br>| Field         | Type    | Example               | Description                        |&para;<br>| :------------ | :------ | :-------------------- | :--------------------------------- |&para;<br>| `file_path`   | string  | `"/path/to/file.txt"` | Absolute path to the file to edit  |&para;<br>| `old_string`  | string  | `"original text"`     | Text to find and replace           |&para;<br>| `new_string`  | string  | `"replacement text"`  | Replacement text                   |&para;<br>| `replace_all` | boolean | `false`               | Whether to replace all occurrences |&para;<br>&para;<br>##### Read&para;<br>&para;<br>Reads file contents.&para;<br>&para;<br>| Field       | Type   | Example               | Description                                |&para;<br>| :---------- | :----- | :-------------------- | :----------------------------------------- |&para;<br>| `file_path` | string | `"/path/to/file.txt"` | Absolute path to the file to read          |&para;<br>| `offset`    | number | `10`                  | Optional line number to start reading from |&para;<br>| `limit`     | number | `50`                  | Optional number of lines to read           |&para;<br>&para;<br>##### Glob&para;<br>&para;<br>Finds files matching a glob pattern.&para;<br>&para;<br>| Field     | Type   | Example          | Description                                                            |&para;<br>| :-------- | :----- | :--------------- | :--------------------------------------------------------------------- |&para;<br>| `pattern` | string | `"**/*.ts"`      | Glob pattern to match files against                                    |&para;<br>| `path`    | string | `"/path/to/dir"` | Optional directory to search in. Defaults to current working directory |&para;<br>&para;<br>##### Grep&para;<br>&para;<br>Searches file contents with regular expressions.&para;<br>&para;<br>| Field         | Type    | Example          | Description                                                                           |&para;<br>| :------------ | :------ | :--------------- | :------------------------------------------------------------------------------------ |&para;<br>| `pattern`     | string  | `"TODO.*fix"`    | Regular expression pattern to search for                                              |&para;<br>| `path`        | string  | `"/path/to/dir"` | Optional file or directory to search in                                               |&para;<br>| `glob`        | string  | `"*.ts"`         | Optional glob pattern to filter files                                                 |&para;<br>| `output_mode` | string  | `"content"`      | `"content"`, `"files_with_matches"`, or `"count"`. Defaults to `"files_with_matches"` |&para;<br>| `-i`          | boolean | `true`           | Case insensitive search                                                               |&para;<br>| `multiline`   | boolean | `false`          | Enable multiline matching                                                             |&para;<br>&para;<br>##### WebFetch&para;<br>&para;<br>Fetches and processes web content.&para;<br>&para;<br>| Field    | Type   | Example                       | Description                          |&para;<br>| :------- | :----- | :---------------------------- | :----------------------------------- |&para;<br>| `url`    | string | `"https://example.com/api"`   | URL to fetch content from            |&para;<br>| `prompt` | string | `"Extract the API endpoints"` | Prompt to run on the fetched content |&para;<br>&para;<br>##### WebSearch&para;<br>&para;<br>Searches the web.&para;<br>&para;<br>| Field             | Type   | Example                        | Description                                       |&para;<br>| :---------------- | :----- | :----------------------------- | :------------------------------------------------ |&para;<br>| `query`           | string | `"react hooks best practices"` | Search query                                      |&para;<br>| `allowed_domains` | array  | `["docs.example.com"]`         | Optional: only include results from these domains |&para;<br>| `blocked_domains` | array  | `["spam.example.com"]`         | Optional: exclude results from these domains      |&para;<br>&para;<br>##### Task&para;<br>&para;<br>Spawns a [subagent](/en/sub-agents).&para;<br>&para;<br>| Field           | Type   | Example                    | Description                                  |&para;<br>| :-------------- | :----- | :------------------------- | :------------------------------------------- |&para;<br>| `prompt`        | string | `"Find all API endpoints"` | The task for the agent to perform            |&para;<br>| `description`   | string | `"Find API endpoints"`     | Short description of the task                |&para;<br>| `subagent_type` | string | `"Explore"`                | Type of specialized agent to use             |&para;<br>| `model`         | string | `"sonnet"`                 | Optional model alias to override the default |&para;<br>&para;<br>#### PreToolUse decision control&para;<br>&para;<br>`PreToolUse` hooks can control whether a tool call proceeds. In addition to the [JSON output fields](#json-output) available to all hooks, your hook script can return a `hookSpecificOutput` object with these event-specific fields:&para;<br>&para;<br>| Field                      | Description                                                                                                                                      |&para;<br>| :------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------- |&para;<br>| `permissionDecision`       | `"allow"` bypasses the permission system, `"deny"` prevents the tool call, `"ask"` prompts the user to confirm                                   |&para;<br>| `permissionDecisionReason` | For `"allow"` and `"ask"`, shown to the user but not Claude. For `"deny"`, shown to Claude                                                       |&para;<br>| `updatedInput`             | Modifies the tool's input parameters before execution. Combine with `"allow"` to auto-approve, or `"ask"` to show the modified input to the user |&para;<br>| `additionalContext`        | String added to Claude's context before the tool executes                                                                                        |&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "PreToolUse",&para;<br>    "permissionDecision": "allow",&para;<br>    "permissionDecisionReason": "My reason here",&para;<br>    "updatedInput": {&para;<br>      "field_to_modify": "new value"&para;<br>    },&para;<br>    "additionalContext": "Current environment: production. Proceed with caution."&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>&lt;Note&gt;&para;<br>  The `decision` and `reason` fields are deprecated for PreToolUse hooks.&para;<br>  Use `hookSpecificOutput.permissionDecision` and&para;<br>  `hookSpecificOutput.permissionDecisionReason` instead. The deprecated fields&para;<br>  `"approve"` and `"block"` map to `"allow"` and `"deny"` respectively.&para;<br>&lt;/Note&gt;&para;<br>&para;<br>### PermissionRequest&para;<br>&para;<br>Runs when the user is shown a permission dialog.&para;<br>Use [PermissionRequest decision control](#permissionrequest-decision-control) to allow or deny on behalf of the user.&para;<br>&para;<br>Matches on tool name, same values as PreToolUse.&para;<br>&para;<br>#### PermissionRequest input&para;<br>&para;<br>PermissionRequest hooks receive `tool_name` and `tool_input` fields like PreToolUse hooks, but without `tool_use_id`. An optional `permission_suggestions` array contains the "always allow" options the user would normally see in the permission dialog. The difference is when the hook fires: PermissionRequest hooks run when a permission dialog is about to be shown to the user, while PreToolUse hooks run before tool execution regardless of permission status.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "PermissionRequest",&para;<br>  "tool_name": "Bash",&para;<br>  "tool_input": {&para;<br>    "command": "rm -rf node_modules",&para;<br>    "description": "Remove node_modules directory"&para;<br>  },&para;<br>  "permission_suggestions": [&para;<br>    { "type": "toolAlwaysAllow", "tool": "Bash" }&para;<br>  ]&para;<br>}&para;<br>```&para;<br>&para;<br>#### PermissionRequest decision control&para;<br>&para;<br>`PermissionRequest` hooks can allow or deny permission requests. In addition to the [JSON output fields](#json-output) available to all hooks, your hook script can return a `decision` object with these event-specific fields:&para;<br>&para;<br>| Field                | Description                                                                                                    |&para;<br>| :------------------- | :------------------------------------------------------------------------------------------------------------- |&para;<br>| `behavior`           | `"allow"` grants the permission, `"deny"` denies it                                                            |&para;<br>| `updatedInput`       | For `"allow"` only: modifies the tool's input parameters before execution                                      |&para;<br>| `updatedPermissions` | For `"allow"` only: applies permission rule updates, equivalent to the user selecting an "always allow" option |&para;<br>| `message`            | For `"deny"` only: tells Claude why the permission was denied                                                  |&para;<br>| `interrupt`          | For `"deny"` only: if `true`, stops Claude                                                                     |&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "PermissionRequest",&para;<br>    "decision": {&para;<br>      "behavior": "allow",&para;<br>      "updatedInput": {&para;<br>        "command": "npm run lint"&para;<br>      }&para;<br>    }&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### PostToolUse&para;<br>&para;<br>Runs immediately after a tool completes successfully.&para;<br>&para;<br>Matches on tool name, same values as PreToolUse.&para;<br>&para;<br>#### PostToolUse input&para;<br>&para;<br>`PostToolUse` hooks fire after a tool has already executed successfully. The input includes both `tool_input`, the arguments sent to the tool, and `tool_response`, the result it returned. The exact schema for both depends on the tool.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "PostToolUse",&para;<br>  "tool_name": "Write",&para;<br>  "tool_input": {&para;<br>    "file_path": "/path/to/file.txt",&para;<br>    "content": "file content"&para;<br>  },&para;<br>  "tool_response": {&para;<br>    "filePath": "/path/to/file.txt",&para;<br>    "success": true&para;<br>  },&para;<br>  "tool_use_id": "toolu_01ABC123..."&para;<br>}&para;<br>```&para;<br>&para;<br>#### PostToolUse decision control&para;<br>&para;<br>`PostToolUse` hooks can provide feedback to Claude after tool execution. In addition to the [JSON output fields](#json-output) available to all hooks, your hook script can return these event-specific fields:&para;<br>&para;<br>| Field                  | Description                                                                                |&para;<br>| :--------------------- | :----------------------------------------------------------------------------------------- |&para;<br>| `decision`             | `"block"` prompts Claude with the `reason`. Omit to allow the action to proceed            |&para;<br>| `reason`               | Explanation shown to Claude when `decision` is `"block"`                                   |&para;<br>| `additionalContext`    | Additional context for Claude to consider                                                  |&para;<br>| `updatedMCPToolOutput` | For [MCP tools](#match-mcp-tools) only: replaces the tool's output with the provided value |&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "decision": "block",&para;<br>  "reason": "Explanation for decision",&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "PostToolUse",&para;<br>    "additionalContext": "Additional information for Claude"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### PostToolUseFailure&para;<br>&para;<br>Runs when a tool execution fails. This event fires for tool calls that throw errors or return failure results. Use this to log failures, send alerts, or provide corrective feedback to Claude.&para;<br>&para;<br>Matches on tool name, same values as PreToolUse.&para;<br>&para;<br>#### PostToolUseFailure input&para;<br>&para;<br>PostToolUseFailure hooks receive the same `tool_name` and `tool_input` fields as PostToolUse, along with error information as top-level fields:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "PostToolUseFailure",&para;<br>  "tool_name": "Bash",&para;<br>  "tool_input": {&para;<br>    "command": "npm test",&para;<br>    "description": "Run test suite"&para;<br>  },&para;<br>  "tool_use_id": "toolu_01ABC123...",&para;<br>  "error": "Command exited with non-zero status code 1",&para;<br>  "is_interrupt": false&para;<br>}&para;<br>```&para;<br>&para;<br>| Field          | Description                                                                     |&para;<br>| :------------- | :------------------------------------------------------------------------------ |&para;<br>| `error`        | String describing what went wrong                                               |&para;<br>| `is_interrupt` | Optional boolean indicating whether the failure was caused by user interruption |&para;<br>&para;<br>#### PostToolUseFailure decision control&para;<br>&para;<br>`PostToolUseFailure` hooks can provide context to Claude after a tool failure. In addition to the [JSON output fields](#json-output) available to all hooks, your hook script can return these event-specific fields:&para;<br>&para;<br>| Field               | Description                                                   |&para;<br>| :------------------ | :------------------------------------------------------------ |&para;<br>| `additionalContext` | Additional context for Claude to consider alongside the error |&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "PostToolUseFailure",&para;<br>    "additionalContext": "Additional information about the failure for Claude"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### Notification&para;<br>&para;<br>Runs when Claude Code sends notifications. Matches on notification type: `permission_prompt`, `idle_prompt`, `auth_success`, `elicitation_dialog`. Omit the matcher to run hooks for all notification types.&para;<br>&para;<br>Use separate matchers to run different handlers depending on the notification type. This configuration triggers a permission-specific alert script when Claude needs permission approval and a different notification when Claude has been idle:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "Notification": [&para;<br>      {&para;<br>        "matcher": "permission_prompt",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "/path/to/permission-alert.sh"&para;<br>          }&para;<br>        ]&para;<br>      },&para;<br>      {&para;<br>        "matcher": "idle_prompt",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "/path/to/idle-notification.sh"&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>#### Notification input&para;<br>&para;<br>In addition to the [common input fields](#common-input-fields), Notification hooks receive `message` with the notification text, an optional `title`, and `notification_type` indicating which type fired.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "Notification",&para;<br>  "message": "Claude needs your permission to use Bash",&para;<br>  "title": "Permission needed",&para;<br>  "notification_type": "permission_prompt"&para;<br>}&para;<br>```&para;<br>&para;<br>Notification hooks cannot block or modify notifications. In addition to the [JSON output fields](#json-output) available to all hooks, you can return `additionalContext` to add context to the conversation:&para;<br>&para;<br>| Field               | Description                      |&para;<br>| :------------------ | :------------------------------- |&para;<br>| `additionalContext` | String added to Claude's context |&para;<br>&para;<br>### SubagentStart&para;<br>&para;<br>Runs when a Claude Code subagent is spawned via the Task tool. Supports matchers to filter by agent type name (built-in agents like `Bash`, `Explore`, `Plan`, or custom agent names from `.claude/agents/`).&para;<br>&para;<br>#### SubagentStart input&para;<br>&para;<br>In addition to the [common input fields](#common-input-fields), SubagentStart hooks receive `agent_id` with the unique identifier for the subagent and `agent_type` with the agent name (built-in agents like `"Bash"`, `"Explore"`, `"Plan"`, or custom agent names).&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "SubagentStart",&para;<br>  "agent_id": "agent-abc123",&para;<br>  "agent_type": "Explore"&para;<br>}&para;<br>```&para;<br>&para;<br>SubagentStart hooks cannot block subagent creation, but they can inject context into the subagent. In addition to the [JSON output fields](#json-output) available to all hooks, you can return:&para;<br>&para;<br>| Field               | Description                            |&para;<br>| :------------------ | :------------------------------------- |&para;<br>| `additionalContext` | String added to the subagent's context |&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hookSpecificOutput": {&para;<br>    "hookEventName": "SubagentStart",&para;<br>    "additionalContext": "Follow security guidelines for this task"&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### SubagentStop&para;<br>&para;<br>Runs when a Claude Code subagent has finished responding. Matches on agent type, same values as SubagentStart.&para;<br>&para;<br>#### SubagentStop input&para;<br>&para;<br>In addition to the [common input fields](#common-input-fields), SubagentStop hooks receive `stop_hook_active`, `agent_id`, `agent_type`, and `agent_transcript_path`. The `agent_type` field is the value used for matcher filtering. The `transcript_path` is the main session's transcript, while `agent_transcript_path` is the subagent's own transcript stored in a nested `subagents/` folder.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "~/.claude/projects/.../abc123.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "SubagentStop",&para;<br>  "stop_hook_active": false,&para;<br>  "agent_id": "def456",&para;<br>  "agent_type": "Explore",&para;<br>  "agent_transcript_path": "~/.claude/projects/.../abc123/subagents/agent-def456.jsonl"&para;<br>}&para;<br>```&para;<br>&para;<br>SubagentStop hooks use the same decision control format as [Stop hooks](#stop-decision-control).&para;<br>&para;<br>### Stop&para;<br>&para;<br>Runs when the main Claude Code agent has finished responding. Does not run if&para;<br>the stoppage occurred due to a user interrupt.&para;<br>&para;<br>#### Stop input&para;<br>&para;<br>In addition to the [common input fields](#common-input-fields), Stop hooks receive `stop_hook_active`. This field is `true` when Claude Code is already continuing as a result of a stop hook. Check this value or process the transcript to prevent Claude Code from running indefinitely.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "Stop",&para;<br>  "stop_hook_active": true&para;<br>}&para;<br>```&para;<br>&para;<br>#### Stop decision control&para;<br>&para;<br>`Stop` and `SubagentStop` hooks can control whether Claude continues. In addition to the [JSON output fields](#json-output) available to all hooks, your hook script can return these event-specific fields:&para;<br>&para;<br>| Field      | Description                                                                |&para;<br>| :--------- | :------------------------------------------------------------------------- |&para;<br>| `decision` | `"block"` prevents Claude from stopping. Omit to allow Claude to stop      |&para;<br>| `reason`   | Required when `decision` is `"block"`. Tells Claude why it should continue |&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "decision": "block",&para;<br>  "reason": "Must be provided when Claude is blocked from stopping"&para;<br>}&para;<br>```&para;<br>&para;<br>### PreCompact&para;<br>&para;<br>Runs before Claude Code is about to run a compact operation.&para;<br>&para;<br>The matcher value indicates whether compaction was triggered manually or automatically:&para;<br>&para;<br>| Matcher  | When it fires                                |&para;<br>| :------- | :------------------------------------------- |&para;<br>| `manual` | `/compact`                                   |&para;<br>| `auto`   | Auto-compact when the context window is full |&para;<br>&para;<br>#### PreCompact input&para;<br>&para;<br>In addition to the [common input fields](#common-input-fields), PreCompact hooks receive `trigger` and `custom_instructions`. For `manual`, `custom_instructions` contains what the user passes into `/compact`. For `auto`, `custom_instructions` is empty.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "PreCompact",&para;<br>  "trigger": "manual",&para;<br>  "custom_instructions": ""&para;<br>}&para;<br>```&para;<br>&para;<br>### SessionEnd&para;<br>&para;<br>Runs when a Claude Code session ends. Useful for cleanup tasks, logging session&para;<br>statistics, or saving session state. Supports matchers to filter by exit reason.&para;<br>&para;<br>The `reason` field in the hook input indicates why the session ended:&para;<br>&para;<br>| Reason                        | Description                                |&para;<br>| :---------------------------- | :----------------------------------------- |&para;<br>| `clear`                       | Session cleared with `/clear` command      |&para;<br>| `logout`                      | User logged out                            |&para;<br>| `prompt_input_exit`           | User exited while prompt input was visible |&para;<br>| `bypass_permissions_disabled` | Bypass permissions mode was disabled       |&para;<br>| `other`                       | Other exit reasons                         |&para;<br>&para;<br>#### SessionEnd input&para;<br>&para;<br>In addition to the [common input fields](#common-input-fields), SessionEnd hooks receive a `reason` field indicating why the session ended. See the [reason table](#sessionend) above for all values.&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "session_id": "abc123",&para;<br>  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",&para;<br>  "cwd": "/Users/...",&para;<br>  "permission_mode": "default",&para;<br>  "hook_event_name": "SessionEnd",&para;<br>  "reason": "other"&para;<br>}&para;<br>```&para;<br>&para;<br>SessionEnd hooks have no decision control. They cannot block session termination but can perform cleanup tasks.&para;<br>&para;<br>## Prompt-based hooks&para;<br>&para;<br>In addition to Bash command hooks (`type: "command"`), Claude Code supports prompt-based hooks (`type: "prompt"`) that use an LLM to evaluate whether to allow or block an action. Prompt-based hooks work with the following events: `PreToolUse`, `PostToolUse`, `PostToolUseFailure`, `PermissionRequest`, `UserPromptSubmit`, `Stop`, and `SubagentStop`.&para;<br>&para;<br>### How prompt-based hooks work&para;<br>&para;<br>Instead of executing a Bash command, prompt-based hooks:&para;<br>&para;<br>1. Send the hook input and your prompt to a Claude model, Haiku by default&para;<br>2. The LLM responds with structured JSON containing a decision&para;<br>3. Claude Code processes the decision automatically&para;<br>&para;<br>### Prompt hook configuration&para;<br>&para;<br>Set `type` to `"prompt"` and provide a `prompt` string instead of a `command`. Use the `$ARGUMENTS` placeholder to inject the hook's JSON input data into your prompt text. Claude Code sends the combined prompt and input to a fast Claude model, which returns a JSON decision.&para;<br>&para;<br>This `Stop` hook asks the LLM to evaluate whether all tasks are complete before allowing Claude to finish:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "Stop": [&para;<br>      {&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "prompt",&para;<br>            "prompt": "Evaluate if Claude should stop: $ARGUMENTS. Check if all tasks are complete."&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>| Field     | Required | Description                                                                                                                                                         |&para;<br>| :-------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------ |&para;<br>| `type`    | yes      | Must be `"prompt"`                                                                                                                                                  |&para;<br>| `prompt`  | yes      | The prompt text to send to the LLM. Use `$ARGUMENTS` as a placeholder for the hook input JSON. If `$ARGUMENTS` is not present, input JSON is appended to the prompt |&para;<br>| `model`   | no       | Model to use for evaluation. Defaults to a fast model                                                                                                               |&para;<br>| `timeout` | no       | Timeout in seconds. Default: 30                                                                                                                                     |&para;<br>&para;<br>### Response schema&para;<br>&para;<br>The LLM must respond with JSON containing:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "ok": true | false,&para;<br>  "reason": "Explanation for the decision"&para;<br>}&para;<br>```&para;<br>&para;<br>| Field    | Description                                                |&para;<br>| :------- | :--------------------------------------------------------- |&para;<br>| `ok`     | `true` allows the action, `false` prevents it              |&para;<br>| `reason` | Required when `ok` is `false`. Explanation shown to Claude |&para;<br>&para;<br>### Example: Multi-criteria Stop hook&para;<br>&para;<br>This `Stop` hook uses a detailed prompt to check three conditions before allowing Claude to stop. If `"ok"` is `false`, Claude continues working with the provided reason as its next instruction. `SubagentStop` hooks use the same format to evaluate whether a [subagent](/en/sub-agents) should stop:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "Stop": [&para;<br>      {&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "prompt",&para;<br>            "prompt": "You are evaluating whether Claude should stop working. Context: $ARGUMENTS\n\nAnalyze the conversation and determine if:\n1. All user-requested tasks are complete\n2. Any errors need to be addressed\n3. Follow-up work is needed\n\nRespond with JSON: {\"ok\": true} to allow stopping, or {\"ok\": false, \"reason\": \"your explanation\"} to continue working.",&para;<br>            "timeout": 30&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>## Agent-based hooks&para;<br>&para;<br>Agent-based hooks (`type: "agent"`) are like prompt-based hooks but with multi-turn tool access. Instead of a single LLM call, an agent hook spawns a subagent that can read files, search code, and inspect the codebase to verify conditions. Agent hooks support the same events as prompt-based hooks.&para;<br>&para;<br>### How agent hooks work&para;<br>&para;<br>When an agent hook fires:&para;<br>&para;<br>1. Claude Code spawns a subagent with your prompt and the hook's JSON input&para;<br>2. The subagent can use tools like Read, Grep, and Glob to investigate&para;<br>3. After up to 50 turns, the subagent returns a structured `{ "ok": true/false }` decision&para;<br>4. Claude Code processes the decision the same way as a prompt hook&para;<br>&para;<br>Agent hooks are useful when verification requires inspecting actual files or test output, not just evaluating the hook input data alone.&para;<br>&para;<br>### Agent hook configuration&para;<br>&para;<br>Set `type` to `"agent"` and provide a `prompt` string. The configuration fields are the same as [prompt hooks](#prompt-hook-configuration), with a longer default timeout:&para;<br>&para;<br>| Field     | Required | Description                                                                                 |&para;<br>| :-------- | :------- | :------------------------------------------------------------------------------------------ |&para;<br>| `type`    | yes      | Must be `"agent"`                                                                           |&para;<br>| `prompt`  | yes      | Prompt describing what to verify. Use `$ARGUMENTS` as a placeholder for the hook input JSON |&para;<br>| `model`   | no       | Model to use. Defaults to a fast model                                                      |&para;<br>| `timeout` | no       | Timeout in seconds. Default: 60                                                             |&para;<br>&para;<br>The response schema is the same as prompt hooks: `{ "ok": true }` to allow or `{ "ok": false, "reason": "..." }` to block.&para;<br>&para;<br>This `Stop` hook verifies that all unit tests pass before allowing Claude to finish:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "Stop": [&para;<br>      {&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "agent",&para;<br>            "prompt": "Verify that all unit tests pass. Run the test suite and check the results. $ARGUMENTS",&para;<br>            "timeout": 120&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>## Run hooks in the background&para;<br>&para;<br>By default, hooks block Claude's execution until they complete. For long-running tasks like deployments, test suites, or external API calls, set `"async": true` to run the hook in the background while Claude continues working. Async hooks cannot block or control Claude's behavior: response fields like `decision`, `permissionDecision`, and `continue` have no effect, because the action they would have controlled has already completed.&para;<br>&para;<br>### Configure an async hook&para;<br>&para;<br>Add `"async": true` to a command hook's configuration to run it in the background without blocking Claude. This field is only available on `type: "command"` hooks.&para;<br>&para;<br>This hook runs a test script after every `Write` tool call. Claude continues working immediately while `run-tests.sh` executes for up to 120 seconds. When the script finishes, its output is delivered on the next conversation turn:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PostToolUse": [&para;<br>      {&para;<br>        "matcher": "Write",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "/path/to/run-tests.sh",&para;<br>            "async": true,&para;<br>            "timeout": 120&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>The `timeout` field sets the maximum time in seconds for the background process. If not specified, async hooks use the same 10-minute default as sync hooks.&para;<br>&para;<br>### How async hooks execute&para;<br>&para;<br>When an async hook fires, Claude Code starts the hook process and immediately continues without waiting for it to finish. The hook receives the same JSON input via stdin as a synchronous hook.&para;<br>&para;<br>After the background process exits, if the hook produced a JSON response with a `systemMessage` or `additionalContext` field, that content is delivered to Claude as context on the next conversation turn.&para;<br>&para;<br>### Example: run tests after file changes&para;<br>&para;<br>This hook starts a test suite in the background whenever Claude writes a file, then reports the results back to Claude when the tests finish. Save this script to `.claude/hooks/run-tests-async.sh` in your project and make it executable with `chmod +x`:&para;<br>&para;<br>```bash  theme={null}&para;<br>#!/bin/bash&para;<br># run-tests-async.sh&para;<br>&para;<br># Read hook input from stdin&para;<br>INPUT=$(cat)&para;<br>FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // empty')&para;<br>&para;<br># Only run tests for source files&para;<br>if [[ "$FILE_PATH" != *.ts &amp;&amp; "$FILE_PATH" != *.js ]]; then&para;<br>  exit 0&para;<br>fi&para;<br>&para;<br># Run tests and report results via systemMessage&para;<br>RESULT=$(npm test 2&gt;&amp;1)&para;<br>EXIT_CODE=$?&para;<br>&para;<br>if [ $EXIT_CODE -eq 0 ]; then&para;<br>  echo "{\"systemMessage\": \"Tests passed after editing $FILE_PATH\"}"&para;<br>else&para;<br>  echo "{\"systemMessage\": \"Tests failed after editing $FILE_PATH: $RESULT\"}"&para;<br>fi&para;<br>```&para;<br>&para;<br>Then add this configuration to `.claude/settings.json` in your project root. The `async: true` flag lets Claude keep working while tests run:&para;<br>&para;<br>```json  theme={null}&para;<br>{&para;<br>  "hooks": {&para;<br>    "PostToolUse": [&para;<br>      {&para;<br>        "matcher": "Write|Edit",&para;<br>        "hooks": [&para;<br>          {&para;<br>            "type": "command",&para;<br>            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/run-tests-async.sh",&para;<br>            "async": true,&para;<br>            "timeout": 300&para;<br>          }&para;<br>        ]&para;<br>      }&para;<br>    ]&para;<br>  }&para;<br>}&para;<br>```&para;<br>&para;<br>### Limitations&para;<br>&para;<br>Async hooks have several constraints compared to synchronous hooks:&para;<br>&para;<br>* Only `type: "command"` hooks support `async`. Prompt-based hooks cannot run asynchronously.&para;<br>* Async hooks cannot block tool calls or return decisions. By the time the hook completes, the triggering action has already proceeded.&para;<br>* Hook output is delivered on the next conversation turn. If the session is idle, the response waits until the next user interaction.&para;<br>* Each execution creates a separate background process. There is no deduplication across multiple firings of the same async hook.&para;<br>&para;<br>## Security considerations&para;<br>&para;<br>### Disclaimer&para;<br>&para;<br>Hooks run with your system user's full permissions.&para;<br>&para;<br>&lt;Warning&gt;&para;<br>  Hooks execute shell commands with your full user permissions. They can modify, delete, or access any files your user account can access. Review and test all hook commands before adding them to your configuration.&para;<br>&lt;/Warning&gt;&para;<br>&para;<br>### Security best practices&para;<br>&para;<br>Keep these practices in mind when writing hooks:&para;<br>&para;<br>* **Validate and sanitize inputs**: never trust input data blindly&para;<br>* **Always quote shell variables**: use `"$VAR"` not `$VAR`&para;<br>* **Block path traversal**: check for `..` in file paths&para;<br>* **Use absolute paths**: specify full paths for scripts, using `"$CLAUDE_PROJECT_DIR"` for the project root&para;<br>* **Skip sensitive files**: avoid `.env`, `.git/`, keys, etc.&para;<br>&para;<br>## Debug hooks&para;<br>&para;<br>Run `claude --debug` to see hook execution details, including which hooks matched, their exit codes, and output. Toggle verbose mode with `Ctrl+O` to see hook progress in the transcript.&para;<br>&para;<br>```&para;<br>[DEBUG] Executing hooks for PostToolUse:Write&para;<br>[DEBUG] Getting matching hook commands for PostToolUse with query: Write&para;<br>[DEBUG] Found 1 hook matchers in settings&para;<br>[DEBUG] Matched 1 hooks for query "Write"&para;<br>[DEBUG] Found 1 hook commands to execute&para;<br>[DEBUG] Executing hook command: &lt;Your command&gt; with timeout 600000ms&para;<br>[DEBUG] Hook command completed with status 0: &lt;Your stdout&gt;&para;<br>```&para;<br>&para;<br>For troubleshooting common issues like hooks not firing, infinite Stop hook loops, or configuration errors, see [Limitations and troubleshooting](/en/hooks-guide#limitations-and-troubleshooting) in the guide.</ins><span>&para;<br></span></div>
        </div>

        <h2 style="margin-top: 2rem; margin-bottom: 1rem;">Unified Diff</h2>
        <pre><code>--- a/hooks.md
+++ b/hooks.md
@@ -4,15 +4,17 @@
 
 # Hooks reference
 
-&gt; This page provides reference documentation for implementing hooks in Claude Code.
+&gt; Reference for Claude Code hook events, configuration schema, JSON input/output formats, exit codes, async hooks, prompt hooks, and MCP tool hooks.
 
 &lt;Tip&gt;
-  For a quickstart guide with examples, see [Get started with Claude Code hooks](/en/hooks-guide).
+  For a quickstart guide with examples, see [Automate workflows with hooks](/en/hooks-guide).
 &lt;/Tip&gt;
 
+Hooks are user-defined shell commands or LLM prompts that execute automatically at specific points in Claude Code&#39;s lifecycle. Use this reference to look up event schemas, configuration options, JSON input/output formats, and advanced features like async hooks and MCP tool hooks. If you&#39;re setting up hooks for the first time, start with the [guide](/en/hooks-guide) instead.
+
 ## Hook lifecycle
 
-Hooks fire at specific points during a Claude Code session.
+Hooks fire at specific points during a Claude Code session. When an event fires and a matcher matches, Claude Code passes JSON context about the event to your hook handler. For command hooks, this arrives on stdin. Your handler can then inspect the input, take action, and optionally return a decision. Some events fire once per session, while others fire repeatedly inside the agentic loop:
 
 &lt;div style={{maxWidth: &#34;500px&#34;, margin: &#34;0 auto&#34;}}&gt;
   &lt;Frame&gt;
@@ -20,48 +22,37 @@
   &lt;/Frame&gt;
 &lt;/div&gt;
 
-| Hook                 | When it fires                   |
-| :------------------- | :------------------------------ |
-| `SessionStart`       | Session begins or resumes       |
-| `UserPromptSubmit`   | User submits a prompt           |
-| `PreToolUse`         | Before tool execution           |
-| `PermissionRequest`  | When permission dialog appears  |
-| `PostToolUse`        | After tool succeeds             |
-| `PostToolUseFailure` | After tool fails                |
-| `SubagentStart`      | When spawning a subagent        |
-| `SubagentStop`       | When subagent finishes          |
-| `Stop`               | Claude finishes responding      |
-| `PreCompact`         | Before context compaction       |
-| `SessionEnd`         | Session terminates              |
-| `Notification`       | Claude Code sends notifications |
-
-## Configuration
-
-Claude Code hooks are configured in your [settings files](/en/settings):
-
-* `~/.claude/settings.json` - User settings
-* `.claude/settings.json` - Project settings
-* `.claude/settings.local.json` - Local project settings (not committed)
-* Managed policy settings
-
-&lt;Note&gt;
-  Enterprise administrators can use `allowManagedHooksOnly` to block user, project, and plugin hooks. See [Hook configuration](/en/settings#hook-configuration).
-&lt;/Note&gt;
-
-### Structure
-
-Hooks are organized by matchers, where each matcher can have multiple hooks:
+The table below summarizes when each event fires. The [Hook events](#hook-events) section documents the full input schema and decision control options for each one.
+
+| Event                | When it fires                                        |
+| :------------------- | :--------------------------------------------------- |
+| `SessionStart`       | When a session begins or resumes                     |
+| `UserPromptSubmit`   | When you submit a prompt, before Claude processes it |
+| `PreToolUse`         | Before a tool call executes. Can block it            |
+| `PermissionRequest`  | When a permission dialog appears                     |
+| `PostToolUse`        | After a tool call succeeds                           |
+| `PostToolUseFailure` | After a tool call fails                              |
+| `Notification`       | When Claude Code sends a notification                |
+| `SubagentStart`      | When a subagent is spawned                           |
+| `SubagentStop`       | When a subagent finishes                             |
+| `Stop`               | When Claude finishes responding                      |
+| `PreCompact`         | Before context compaction                            |
+| `SessionEnd`         | When a session terminates                            |
+
+### How a hook resolves
+
+To see how these pieces fit together, consider this `PreToolUse` hook that blocks destructive shell commands. The hook runs `block-rm.sh` before every Bash tool call:
 
 ```json  theme={null}
 {
   &#34;hooks&#34;: {
-    &#34;EventName&#34;: [
+    &#34;PreToolUse&#34;: [
       {
-        &#34;matcher&#34;: &#34;ToolPattern&#34;,
+        &#34;matcher&#34;: &#34;Bash&#34;,
         &#34;hooks&#34;: [
           {
             &#34;type&#34;: &#34;command&#34;,
-            &#34;command&#34;: &#34;your-command-here&#34;
+            &#34;command&#34;: &#34;.claude/hooks/block-rm.sh&#34;
           }
         ]
       }
@@ -70,30 +61,114 @@
 }
 ```
 
-* **matcher**: Pattern to match tool names, case-sensitive (only applicable for
-  `PreToolUse`, `PermissionRequest`, and `PostToolUse`)
-  * Simple strings match exactly: `Write` matches only the Write tool
-  * Supports regex: `Edit|Write` or `Notebook.*`
-  * Use `*` to match all tools. You can also use empty string (`&#34;&#34;`) or leave
-    `matcher` blank.
-* **hooks**: Array of hooks to execute when the pattern matches
-  * `type`: Hook execution type - `&#34;command&#34;` for bash commands or `&#34;prompt&#34;` for LLM-based evaluation
-  * `command`: (For `type: &#34;command&#34;`) The bash command to execute (can use `$CLAUDE_PROJECT_DIR` environment variable)
-  * `prompt`: (For `type: &#34;prompt&#34;`) The prompt to send to the LLM for evaluation
-  * `timeout`: (Optional) How long a hook should run, in seconds, before canceling that specific hook
-
-For events like `UserPromptSubmit`, `Stop`, `SubagentStop`, and `Setup`
-that don&#39;t use matchers, you can omit the matcher field:
+The script reads the JSON input from stdin, extracts the command, and blocks it if it contains `rm -rf`:
+
+```bash  theme={null}
+#!/bin/bash
+# .claude/hooks/block-rm.sh
+COMMAND=$(jq -r &#39;.tool_input.command&#39;)
+
+if echo &#34;$COMMAND&#34; | grep -q &#39;rm -rf&#39;; then
+  echo &#39;{&#34;decision&#34;:&#34;block&#34;,&#34;reason&#34;:&#34;Destructive command blocked by hook&#34;}&#39;
+else
+  exit 0  # allow the command
+fi
+```
+
+Now suppose Claude Code decides to run `Bash &#34;rm -rf /tmp/build&#34;`. Here&#39;s what happens:
+
+&lt;Frame&gt;
+  &lt;img src=&#34;https://mintcdn.com/claude-code/s7NM0vfd_wres2nf/images/hook-resolution.svg?fit=max&amp;auto=format&amp;n=s7NM0vfd_wres2nf&amp;q=85&amp;s=7c13f51ffcbc37d22a593b27e2f2de72&#34; alt=&#34;Hook resolution flow: PreToolUse event fires, matcher checks for Bash match, hook handler runs, result returns to Claude Code&#34; data-og-width=&#34;780&#34; width=&#34;780&#34; data-og-height=&#34;290&#34; height=&#34;290&#34; data-path=&#34;images/hook-resolution.svg&#34; data-optimize=&#34;true&#34; data-opv=&#34;3&#34; srcset=&#34;https://mintcdn.com/claude-code/s7NM0vfd_wres2nf/images/hook-resolution.svg?w=280&amp;fit=max&amp;auto=format&amp;n=s7NM0vfd_wres2nf&amp;q=85&amp;s=36a39a07e8bc1995dcb4639e09846905 280w, https://mintcdn.com/claude-code/s7NM0vfd_wres2nf/images/hook-resolution.svg?w=560&amp;fit=max&amp;auto=format&amp;n=s7NM0vfd_wres2nf&amp;q=85&amp;s=6568d90c596c7605bbac2c325b0a0c86 560w, https://mintcdn.com/claude-code/s7NM0vfd_wres2nf/images/hook-resolution.svg?w=840&amp;fit=max&amp;auto=format&amp;n=s7NM0vfd_wres2nf&amp;q=85&amp;s=255a6f68b9475a0e41dbde7b88002dad 840w, https://mintcdn.com/claude-code/s7NM0vfd_wres2nf/images/hook-resolution.svg?w=1100&amp;fit=max&amp;auto=format&amp;n=s7NM0vfd_wres2nf&amp;q=85&amp;s=dcecf8d5edc88cd2bc49deb006d5760d 1100w, https://mintcdn.com/claude-code/s7NM0vfd_wres2nf/images/hook-resolution.svg?w=1650&amp;fit=max&amp;auto=format&amp;n=s7NM0vfd_wres2nf&amp;q=85&amp;s=04fe51bf69ae375e9fd517f18674e35f 1650w, https://mintcdn.com/claude-code/s7NM0vfd_wres2nf/images/hook-resolution.svg?w=2500&amp;fit=max&amp;auto=format&amp;n=s7NM0vfd_wres2nf&amp;q=85&amp;s=b1b76e0b77fddb5c7fa7bf302dacd80b 2500w&#34; /&gt;
+&lt;/Frame&gt;
+
+&lt;Steps&gt;
+  &lt;Step title=&#34;Event fires&#34;&gt;
+    The `PreToolUse` event fires. Claude Code sends the tool input as JSON on stdin to the hook:
+
+    ```json  theme={null}
+    { &#34;tool_name&#34;: &#34;Bash&#34;, &#34;tool_input&#34;: { &#34;command&#34;: &#34;rm -rf /tmp/build&#34; }, ... }
+    ```
+  &lt;/Step&gt;
+
+  &lt;Step title=&#34;Matcher checks&#34;&gt;
+    The matcher `&#34;Bash&#34;` matches the tool name, so `block-rm.sh` runs. If you omit the matcher or use `&#34;*&#34;`, the hook runs on every occurrence of the event. Hooks only skip when a matcher is defined and doesn&#39;t match.
+  &lt;/Step&gt;
+
+  &lt;Step title=&#34;Hook handler runs&#34;&gt;
+    The script extracts `&#34;rm -rf /tmp/build&#34;` from the input and finds `rm -rf`, so it prints a decision to stdout:
+
+    ```json  theme={null}
+    { &#34;decision&#34;: &#34;block&#34;, &#34;reason&#34;: &#34;Destructive command blocked by hook&#34; }
+    ```
+
+    If the command had been safe (like `npm test`), the script would hit `exit 0` instead, which tells Claude Code to allow the tool call with no further action.
+  &lt;/Step&gt;
+
+  &lt;Step title=&#34;Claude Code acts on the result&#34;&gt;
+    Claude Code reads the JSON decision, blocks the tool call, and shows Claude the reason.
+  &lt;/Step&gt;
+&lt;/Steps&gt;
+
+The [Configuration](#configuration) section below documents the full schema, and each [hook event](#hook-events) section documents what input your command receives and what output it can return.
+
+## Configuration
+
+Hooks are defined in JSON settings files. The configuration has three levels of nesting:
+
+1. Choose a [hook event](#hook-events) to respond to, like `PreToolUse` or `Stop`
+2. Add a [matcher group](#matcher-patterns) to filter when it fires, like &#34;only for the Bash tool&#34;
+3. Define one or more [hook handlers](#hook-handler-fields) to run when matched
+
+See [How a hook resolves](#how-a-hook-resolves) above for a complete walkthrough with an annotated example.
+
+&lt;Note&gt;
+  This page uses specific terms for each level: **hook event** for the lifecycle point, **matcher group** for the filter, and **hook handler** for the shell command, prompt, or agent that runs. &#34;Hook&#34; on its own refers to the general feature.
+&lt;/Note&gt;
+
+### Hook locations
+
+Where you define a hook determines its scope:
+
+| Location                                                   | Scope                         | Shareable                          |
+| :--------------------------------------------------------- | :---------------------------- | :--------------------------------- |
+| `~/.claude/settings.json`                                  | All your projects             | No, local to your machine          |
+| `.claude/settings.json`                                    | Single project                | Yes, can be committed to the repo  |
+| `.claude/settings.local.json`                              | Single project                | No, gitignored                     |
+| Managed policy settings                                    | Organization-wide             | Yes, admin-controlled              |
+| [Plugin](/en/plugins) `hooks/hooks.json`                   | When plugin is enabled        | Yes, bundled with the plugin       |
+| [Skill](/en/skills) or [agent](/en/sub-agents) frontmatter | While the component is active | Yes, defined in the component file |
+
+For details on settings file resolution, see [settings](/en/settings). Enterprise administrators can use `allowManagedHooksOnly` to block user, project, and plugin hooks. See [Hook configuration](/en/settings#hook-configuration).
+
+### Matcher patterns
+
+The `matcher` field is a regex string that filters when hooks fire. Use `&#34;*&#34;`, `&#34;&#34;`, or omit `matcher` entirely to match all occurrences. Each event type matches on a different field:
+
+| Event                                                                  | What the matcher filters  | Example matcher values                                                         |
+| :--------------------------------------------------------------------- | :------------------------ | :----------------------------------------------------------------------------- |
+| `PreToolUse`, `PostToolUse`, `PostToolUseFailure`, `PermissionRequest` | tool name                 | `Bash`, `Edit\|Write`, `mcp__.*`                                               |
+| `SessionStart`                                                         | how the session started   | `startup`, `resume`, `clear`, `compact`                                        |
+| `SessionEnd`                                                           | why the session ended     | `clear`, `logout`, `prompt_input_exit`, `bypass_permissions_disabled`, `other` |
+| `Notification`                                                         | notification type         | `permission_prompt`, `idle_prompt`, `auth_success`, `elicitation_dialog`       |
+| `SubagentStart`                                                        | agent type                | `Bash`, `Explore`, `Plan`, or custom agent names                               |
+| `PreCompact`                                                           | what triggered compaction | `manual`, `auto`                                                               |
+| `SubagentStop`                                                         | agent type                | same values as `SubagentStart`                                                 |
+| `UserPromptSubmit`, `Stop`                                             | no matcher support        | always fires on every occurrence                                               |
+
+The matcher is a regex, so `Edit|Write` matches either tool and `Notebook.*` matches any tool starting with Notebook. The matcher runs against a field from the [JSON input](#hook-input-and-output) that Claude Code sends to your hook on stdin. For tool events, that field is `tool_name`. Each [hook event](#hook-events) section lists the full set of matcher values and the input schema for that event.
+
+This example runs a linting script only when Claude writes or edits a file:
 
 ```json  theme={null}
 {
   &#34;hooks&#34;: {
-    &#34;UserPromptSubmit&#34;: [
+    &#34;PostToolUse&#34;: [
       {
+        &#34;matcher&#34;: &#34;Edit|Write&#34;,
         &#34;hooks&#34;: [
           {
             &#34;type&#34;: &#34;command&#34;,
-            &#34;command&#34;: &#34;/path/to/prompt-validator.py&#34;
+            &#34;command&#34;: &#34;/path/to/lint-check.sh&#34;
           }
         ]
       }
@@ -102,22 +177,44 @@
 }
 ```
 
-### Project-Specific Hook Scripts
-
-You can use the environment variable `CLAUDE_PROJECT_DIR` (only available when
-Claude Code spawns the hook command) to reference scripts stored in your project,
-ensuring they work regardless of Claude&#39;s current directory:
+`UserPromptSubmit` and `Stop` don&#39;t support matchers and always fire on every occurrence. If you add a `matcher` field to these events, it is silently ignored.
+
+#### Match MCP tools
+
+[MCP](/en/mcp) server tools appear as regular tools in tool events (`PreToolUse`, `PostToolUse`, `PostToolUseFailure`, `PermissionRequest`), so you can match them the same way you match any other tool name.
+
+MCP tools follow the naming pattern `mcp__&lt;server&gt;__&lt;tool&gt;`, for example:
+
+* `mcp__memory__create_entities`: Memory server&#39;s create entities tool
+* `mcp__filesystem__read_file`: Filesystem server&#39;s read file tool
+* `mcp__github__search_repositories`: GitHub server&#39;s search tool
+
+Use regex patterns to target specific MCP tools or groups of tools:
+
+* `mcp__memory__.*` matches all tools from the `memory` server
+* `mcp__.*__write.*` matches any tool containing &#34;write&#34; from any server
+
+This example logs all memory server operations and validates write operations from any MCP server:
 
 ```json  theme={null}
 {
   &#34;hooks&#34;: {
-    &#34;PostToolUse&#34;: [
+    &#34;PreToolUse&#34;: [
       {
-        &#34;matcher&#34;: &#34;Write|Edit&#34;,
+        &#34;matcher&#34;: &#34;mcp__memory__.*&#34;,
         &#34;hooks&#34;: [
           {
             &#34;type&#34;: &#34;command&#34;,
-            &#34;command&#34;: &#34;\&#34;$CLAUDE_PROJECT_DIR\&#34;/.claude/hooks/check-style.sh&#34;
+            &#34;command&#34;: &#34;echo &#39;Memory operation initiated&#39; &gt;&gt; ~/mcp-operations.log&#34;
+          }
+        ]
+      },
+      {
+        &#34;matcher&#34;: &#34;mcp__.*__write.*&#34;,
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;command&#34;,
+            &#34;command&#34;: &#34;/home/user/scripts/validate-mcp-write.py&#34;
           }
         ]
       }
@@ -126,62 +223,113 @@
 }
 ```
 
-### Plugin hooks
-
-[Plugins](/en/plugins) can provide hooks that integrate seamlessly with your user and project hooks. Plugin hooks are automatically merged with your configuration when plugins are enabled.
-
-**How plugin hooks work**:
-
-* Plugin hooks are defined in the plugin&#39;s `hooks/hooks.json` file or in a file given by a custom path to the `hooks` field.
-* When a plugin is enabled, its hooks are merged with user and project hooks
-* Multiple hooks from different sources can respond to the same event
-* Plugin hooks use the `${CLAUDE_PLUGIN_ROOT}` environment variable to reference plugin files
-
-**Example plugin hook configuration**:
-
-```json  theme={null}
-{
-  &#34;description&#34;: &#34;Automatic code formatting&#34;,
-  &#34;hooks&#34;: {
-    &#34;PostToolUse&#34;: [
-      {
-        &#34;matcher&#34;: &#34;Write|Edit&#34;,
-        &#34;hooks&#34;: [
+### Hook handler fields
+
+Each object in the inner `hooks` array is a hook handler: the shell command, LLM prompt, or agent that runs when the matcher matches. There are three types:
+
+* **[Command hooks](#command-hook-fields)** (`type: &#34;command&#34;`): run a shell command. Your script receives the event&#39;s [JSON input](#hook-input-and-output) on stdin and communicates results back through exit codes and stdout.
+* **[Prompt hooks](#prompt-and-agent-hook-fields)** (`type: &#34;prompt&#34;`): send a prompt to a Claude model for single-turn evaluation. The model returns a yes/no decision as JSON. See [Prompt-based hooks](#prompt-based-hooks).
+* **[Agent hooks](#prompt-and-agent-hook-fields)** (`type: &#34;agent&#34;`): spawn a subagent that can use tools like Read, Grep, and Glob to verify conditions before returning a decision. See [Agent-based hooks](#agent-based-hooks).
+
+#### Common fields
+
+These fields apply to all hook types:
+
+| Field           | Required | Description                                                                                                                                   |
+| :-------------- | :------- | :-------------------------------------------------------------------------------------------------------------------------------------------- |
+| `type`          | yes      | `&#34;command&#34;`, `&#34;prompt&#34;`, or `&#34;agent&#34;`                                                                                                         |
+| `timeout`       | no       | Seconds before canceling. Defaults: 600 for command, 30 for prompt, 60 for agent                                                              |
+| `statusMessage` | no       | Custom spinner message displayed while the hook runs                                                                                          |
+| `once`          | no       | If `true`, runs only once per session then is removed. Skills only, not agents. See [Hooks in skills and agents](#hooks-in-skills-and-agents) |
+
+#### Command hook fields
+
+In addition to the [common fields](#common-fields), command hooks accept these fields:
+
+| Field     | Required | Description                                                                                                         |
+| :-------- | :------- | :------------------------------------------------------------------------------------------------------------------ |
+| `command` | yes      | Shell command to execute                                                                                            |
+| `async`   | no       | If `true`, runs in the background without blocking. See [Run hooks in the background](#run-hooks-in-the-background) |
+
+#### Prompt and agent hook fields
+
+In addition to the [common fields](#common-fields), prompt and agent hooks accept these fields:
+
+| Field    | Required | Description                                                                                 |
+| :------- | :------- | :------------------------------------------------------------------------------------------ |
+| `prompt` | yes      | Prompt text to send to the model. Use `$ARGUMENTS` as a placeholder for the hook input JSON |
+| `model`  | no       | Model to use for evaluation. Defaults to a fast model                                       |
+
+All matching hooks run in parallel, and identical handlers are deduplicated automatically. Handlers run in the current directory with Claude Code&#39;s environment. The `$CLAUDE_CODE_REMOTE` environment variable is set to `&#34;true&#34;` in remote web environments and not set in the local CLI.
+
+### Reference scripts by path
+
+Use environment variables to reference hook scripts relative to the project or plugin root, regardless of the working directory when the hook runs:
+
+* `$CLAUDE_PROJECT_DIR`: the project root. Wrap in quotes to handle paths with spaces.
+* `${CLAUDE_PLUGIN_ROOT}`: the plugin&#39;s root directory, for scripts bundled with a [plugin](/en/plugins).
+
+&lt;Tabs&gt;
+  &lt;Tab title=&#34;Project scripts&#34;&gt;
+    This example uses `$CLAUDE_PROJECT_DIR` to run a style checker from the project&#39;s `.claude/hooks/` directory after any `Write` or `Edit` tool call:
+
+    ```json  theme={null}
+    {
+      &#34;hooks&#34;: {
+        &#34;PostToolUse&#34;: [
           {
-            &#34;type&#34;: &#34;command&#34;,
-            &#34;command&#34;: &#34;${CLAUDE_PLUGIN_ROOT}/scripts/format.sh&#34;,
-            &#34;timeout&#34;: 30
+            &#34;matcher&#34;: &#34;Write|Edit&#34;,
+            &#34;hooks&#34;: [
+              {
+                &#34;type&#34;: &#34;command&#34;,
+                &#34;command&#34;: &#34;\&#34;$CLAUDE_PROJECT_DIR\&#34;/.claude/hooks/check-style.sh&#34;
+              }
+            ]
           }
         ]
       }
-    ]
-  }
-}
-```
-
-&lt;Note&gt;
-  Plugin hooks use the same format as regular hooks with an optional `description` field to explain the hook&#39;s purpose.
-&lt;/Note&gt;
-
-&lt;Note&gt;
-  Plugin hooks run alongside your custom hooks. If multiple hooks match an event, they all execute in parallel.
-&lt;/Note&gt;
-
-**Environment variables for plugins**:
-
-* `${CLAUDE_PLUGIN_ROOT}`: Absolute path to the plugin directory
-* `${CLAUDE_PROJECT_DIR}`: Project root directory (same as for project hooks)
-* All standard environment variables are available
-
-See the [plugin components reference](/en/plugins-reference#hooks) for details on creating plugin hooks.
+    }
+    ```
+  &lt;/Tab&gt;
+
+  &lt;Tab title=&#34;Plugin scripts&#34;&gt;
+    Define plugin hooks in `hooks/hooks.json` with an optional top-level `description` field. When a plugin is enabled, its hooks merge with your user and project hooks.
+
+    This example runs a formatting script bundled with the plugin:
+
+    ```json  theme={null}
+    {
+      &#34;description&#34;: &#34;Automatic code formatting&#34;,
+      &#34;hooks&#34;: {
+        &#34;PostToolUse&#34;: [
+          {
+            &#34;matcher&#34;: &#34;Write|Edit&#34;,
+            &#34;hooks&#34;: [
+              {
+                &#34;type&#34;: &#34;command&#34;,
+                &#34;command&#34;: &#34;${CLAUDE_PLUGIN_ROOT}/scripts/format.sh&#34;,
+                &#34;timeout&#34;: 30
+              }
+            ]
+          }
+        ]
+      }
+    }
+    ```
+
+    See the [plugin components reference](/en/plugins-reference#hooks) for details on creating plugin hooks.
+  &lt;/Tab&gt;
+&lt;/Tabs&gt;
 
 ### Hooks in skills and agents
 
 In addition to settings files and plugins, hooks can be defined directly in [skills](/en/skills) and [subagents](/en/sub-agents) using frontmatter. These hooks are scoped to the component&#39;s lifecycle and only run when that component is active.
 
-**Supported events**: `PreToolUse`, `PostToolUse`, and `Stop`
-
-**Example in a Skill**:
+All hook events are supported. For subagents, `Stop` hooks are automatically converted to `SubagentStop` since that is the event that fires when a subagent completes.
+
+Hooks use the same configuration format as settings-based hooks but are scoped to the component&#39;s lifetime and cleaned up when it finishes.
+
+This skill defines a `PreToolUse` hook that runs a security validation script before each `Bash` command:
 
 ```yaml  theme={null}
 ---
@@ -196,198 +344,593 @@
 ---
 ```
 
-**Example in an agent**:
-
-```yaml  theme={null}
----
-name: code-reviewer
-description: Review code changes
-hooks:
-  PostToolUse:
-    - matcher: &#34;Edit|Write&#34;
-      hooks:
-        - type: command
-          command: &#34;./scripts/run-linter.sh&#34;
----
-```
-
-Component-scoped hooks follow the same configuration format as settings-based hooks but are automatically cleaned up when the component finishes executing.
-
-**Additional option for skills:**
-
-* `once`: Set to `true` to run the hook only once per session. After the first successful execution, the hook is removed. Note: This option is currently only supported for skills, not for agents.
-
-## Prompt-Based Hooks
-
-In addition to bash command hooks (`type: &#34;command&#34;`), Claude Code supports prompt-based hooks (`type: &#34;prompt&#34;`) that use an LLM to evaluate whether to allow or block an action. Prompt-based hooks are currently only supported for `Stop` and `SubagentStop` hooks, where they enable intelligent, context-aware decisions.
-
-### How prompt-based hooks work
-
-Instead of executing a bash command, prompt-based hooks:
-
-1. Send the hook input and your prompt to a fast LLM (Haiku)
-2. The LLM responds with structured JSON containing a decision
-3. Claude Code processes the decision automatically
-
-### Configuration
-
-```json  theme={null}
-{
-  &#34;hooks&#34;: {
-    &#34;Stop&#34;: [
-      {
-        &#34;hooks&#34;: [
-          {
-            &#34;type&#34;: &#34;prompt&#34;,
-            &#34;prompt&#34;: &#34;Evaluate if Claude should stop: $ARGUMENTS. Check if all tasks are complete.&#34;
-          }
-        ]
-      }
-    ]
-  }
-}
-```
-
-**Fields:**
-
-* `type`: Must be `&#34;prompt&#34;`
-* `prompt`: The prompt text to send to the LLM
-  * Use `$ARGUMENTS` as a placeholder for the hook input JSON
-  * If `$ARGUMENTS` is not present, input JSON is appended to the prompt
-* `timeout`: (Optional) Timeout in seconds (default: 30 seconds)
-
-### Response schema
-
-The LLM must respond with JSON containing:
-
-```json  theme={null}
-{
-  &#34;ok&#34;: true | false,
-  &#34;reason&#34;: &#34;Explanation for the decision&#34;
-}
-```
-
-**Response fields:**
-
-* `ok`: `true` allows the action, `false` prevents it
-* `reason`: Required when `ok` is `false`. Explanation shown to Claude
-
-### Supported hook events
-
-Prompt-based hooks work with any hook event, but are most useful for:
-
-* **Stop**: Intelligently decide if Claude should continue working
-* **SubagentStop**: Evaluate if a subagent has completed its task
-* **UserPromptSubmit**: Validate user prompts with LLM assistance
-* **PreToolUse**: Make context-aware permission decisions
-* **PermissionRequest**: Intelligently allow or deny permission dialogs
-
-### Example: Intelligent Stop hook
-
-```json  theme={null}
-{
-  &#34;hooks&#34;: {
-    &#34;Stop&#34;: [
-      {
-        &#34;hooks&#34;: [
-          {
-            &#34;type&#34;: &#34;prompt&#34;,
-            &#34;prompt&#34;: &#34;You are evaluating whether Claude should stop working. Context: $ARGUMENTS\n\nAnalyze the conversation and determine if:\n1. All user-requested tasks are complete\n2. Any errors need to be addressed\n3. Follow-up work is needed\n\nRespond with JSON: {\&#34;ok\&#34;: true} to allow stopping, or {\&#34;ok\&#34;: false, \&#34;reason\&#34;: \&#34;your explanation\&#34;} to continue working.&#34;,
-            &#34;timeout&#34;: 30
-          }
-        ]
-      }
-    ]
-  }
-}
-```
-
-### Example: SubagentStop with custom logic
-
-```json  theme={null}
-{
-  &#34;hooks&#34;: {
-    &#34;SubagentStop&#34;: [
-      {
-        &#34;hooks&#34;: [
-          {
-            &#34;type&#34;: &#34;prompt&#34;,
-            &#34;prompt&#34;: &#34;Evaluate if this subagent should stop. Input: $ARGUMENTS\n\nCheck if:\n- The subagent completed its assigned task\n- Any errors occurred that need fixing\n- Additional context gathering is needed\n\nReturn: {\&#34;ok\&#34;: true} to allow stopping, or {\&#34;ok\&#34;: false, \&#34;reason\&#34;: \&#34;explanation\&#34;} to continue.&#34;
-          }
-        ]
-      }
-    ]
-  }
-}
-```
-
-### Comparison with bash command hooks
-
-| Feature               | Bash Command Hooks      | Prompt-Based Hooks             |
-| --------------------- | ----------------------- | ------------------------------ |
-| **Execution**         | Runs bash script        | Queries LLM                    |
-| **Decision logic**    | You implement in code   | LLM evaluates context          |
-| **Setup complexity**  | Requires script file    | Configure prompt               |
-| **Context awareness** | Limited to script logic | Natural language understanding |
-| **Performance**       | Fast (local execution)  | Slower (API call)              |
-| **Use case**          | Deterministic rules     | Context-aware decisions        |
-
-### Best practices
-
-* **Be specific in prompts**: Clearly state what you want the LLM to evaluate
-* **Include decision criteria**: List the factors the LLM should consider
-* **Test your prompts**: Verify the LLM makes correct decisions for your use cases
-* **Set appropriate timeouts**: Default is 30 seconds, adjust if needed
-* **Use for complex decisions**: Bash hooks are better for simple, deterministic rules
-
-See the [plugin components reference](/en/plugins-reference#hooks) for details on creating plugin hooks.
-
-## Hook Events
+Agents use the same format in their YAML frontmatter.
+
+### The `/hooks` menu
+
+Type `/hooks` in Claude Code to open the interactive hooks manager, where you can view, add, and delete hooks without editing settings files directly. For a step-by-step walkthrough, see [Set up your first hook](/en/hooks-guide#set-up-your-first-hook) in the guide.
+
+Each hook in the menu is labeled with a bracket prefix indicating its source:
+
+* `[User]`: from `~/.claude/settings.json`
+* `[Project]`: from `.claude/settings.json`
+* `[Local]`: from `.claude/settings.local.json`
+* `[Plugin]`: from a plugin&#39;s `hooks/hooks.json`, read-only
+
+### Disable or remove hooks
+
+To remove a hook, delete its entry from the settings JSON file, or use the `/hooks` menu and select the hook to delete it.
+
+To temporarily disable all hooks without removing them, set `&#34;disableAllHooks&#34;: true` in your settings file or use the toggle in the `/hooks` menu. There is no way to disable an individual hook while keeping it in the configuration.
+
+Direct edits to hooks in settings files don&#39;t take effect immediately. Claude Code captures a snapshot of hooks at startup and uses it throughout the session. This prevents malicious or accidental hook modifications from taking effect mid-session without your review. If hooks are modified externally, Claude Code warns you and requires review in the `/hooks` menu before changes apply.
+
+## Hook input and output
+
+Hooks receive JSON data via stdin and communicate results through exit codes, stdout, and stderr. This section covers fields and behavior common to all events. Each event&#39;s section under [Hook events](#hook-events) includes its specific input schema and decision control options.
+
+### Common input fields
+
+All hook events receive these fields via stdin as JSON, in addition to event-specific fields documented in each [hook event](#hook-events) section:
+
+| Field             | Description                                                                                                                        |
+| :---------------- | :--------------------------------------------------------------------------------------------------------------------------------- |
+| `session_id`      | Current session identifier                                                                                                         |
+| `transcript_path` | Path to conversation JSON                                                                                                          |
+| `cwd`             | Current working directory when the hook is invoked                                                                                 |
+| `permission_mode` | Current [permission mode](/en/iam#permission-modes): `&#34;default&#34;`, `&#34;plan&#34;`, `&#34;acceptEdits&#34;`, `&#34;dontAsk&#34;`, or `&#34;bypassPermissions&#34;` |
+| `hook_event_name` | Name of the event that fired                                                                                                       |
+
+For example, a `PreToolUse` hook for a Bash command receives this on stdin:
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;/home/user/.claude/projects/.../transcript.jsonl&#34;,
+  &#34;cwd&#34;: &#34;/home/user/my-project&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;PreToolUse&#34;,
+  &#34;tool_name&#34;: &#34;Bash&#34;,
+  &#34;tool_input&#34;: {
+    &#34;command&#34;: &#34;npm test&#34;
+  }
+}
+```
+
+The `tool_name` and `tool_input` fields are event-specific. Each [hook event](#hook-events) section documents the additional fields for that event.
+
+### Exit code output
+
+The exit code from your hook command tells Claude Code whether the action should proceed, be blocked, or be ignored.
+
+**Exit 0** means success. Claude Code parses stdout for [JSON output fields](#json-output) like `decision` or `reason`. JSON output is only processed on exit 0. For most events, stdout is only shown in verbose mode (`Ctrl+O`). The exceptions are `UserPromptSubmit` and `SessionStart`, where stdout is added as context that Claude can see and act on.
+
+**Exit 2** means a blocking error. Claude Code ignores stdout and any JSON in it. Instead, stderr text is fed back to Claude as an error message. The effect depends on the event: `PreToolUse` blocks the tool call, `UserPromptSubmit` rejects the prompt, and so on. See [exit code 2 behavior](#exit-code-2-behavior-per-event) for the full list.
+
+**Any other exit code** is a non-blocking error. stderr is shown in verbose mode (`Ctrl+O`) and execution continues.
+
+For example, a hook command script that blocks dangerous Bash commands:
+
+```bash  theme={null}
+#!/bin/bash
+# Reads JSON input from stdin, checks the command
+command=$(jq -r &#39;.tool_input.command&#39; &lt; /dev/stdin)
+
+if [[ &#34;$command&#34; == rm* ]]; then
+  echo &#34;Blocked: rm commands are not allowed&#34; &gt;&amp;2
+  exit 2  # Blocking error: tool call is prevented
+fi
+
+exit 0  # Success: tool call proceeds
+```
+
+#### Exit code 2 behavior per event
+
+Exit code 2 is the way a hook signals &#34;stop, don&#39;t do this.&#34; The effect depends on the event, because some events represent actions that can be blocked (like a tool call that hasn&#39;t happened yet) and others represent things that already happened or can&#39;t be prevented.
+
+| Hook event           | Can block? | What happens on exit 2                                    |
+| :------------------- | :--------- | :-------------------------------------------------------- |
+| `PreToolUse`         | Yes        | Blocks the tool call                                      |
+| `PermissionRequest`  | Yes        | Denies the permission                                     |
+| `UserPromptSubmit`   | Yes        | Blocks prompt processing and erases the prompt            |
+| `Stop`               | Yes        | Prevents Claude from stopping, continues the conversation |
+| `SubagentStop`       | Yes        | Prevents the subagent from stopping                       |
+| `PostToolUse`        | No         | Shows stderr to Claude (tool already ran)                 |
+| `PostToolUseFailure` | No         | Shows stderr to Claude (tool already failed)              |
+| `Notification`       | No         | Shows stderr to user only                                 |
+| `SubagentStart`      | No         | Shows stderr to user only                                 |
+| `SessionStart`       | No         | Shows stderr to user only                                 |
+| `SessionEnd`         | No         | Shows stderr to user only                                 |
+| `PreCompact`         | No         | Shows stderr to user only                                 |
+
+### JSON output
+
+You must choose one approach per hook, not both: either use exit codes alone for signaling, or exit 0 and print JSON for structured control. Claude Code only processes JSON on exit 0. If you exit 2, any JSON is ignored.
+
+Instead of relying on exit codes alone, hooks can print JSON to stdout on exit 0. Claude Code reads specific fields from this JSON to decide what to do next.
+
+Your hook&#39;s stdout must contain only the JSON object. If your shell profile prints text on startup, it can interfere with JSON parsing. See [JSON validation failed](/en/hooks-guide#json-validation-failed) in the troubleshooting guide.
+
+The JSON object has two parts:
+
+* **Top-level fields** like `continue` and `decision` work across all events. These are listed in the table below.
+* **`hookSpecificOutput`** is a nested object for event-specific fields like `permissionDecision` or `additionalContext`. It requires a `hookEventName` field set to the event name, like `&#34;PreToolUse&#34;` or `&#34;Stop&#34;`. Each event&#39;s decision control section under [Hook events](#hook-events) documents what fields go here.
+
+| Field            | Default | Description                                                                                                                                           |
+| :--------------- | :------ | :---------------------------------------------------------------------------------------------------------------------------------------------------- |
+| `continue`       | `true`  | If `false`, Claude stops processing entirely after the hook runs. Takes precedence over event-specific fields like `decision` or `permissionDecision` |
+| `stopReason`     | none    | Message shown to the user when `continue` is `false`. Not shown to Claude                                                                             |
+| `suppressOutput` | `false` | If `true`, hides stdout from verbose mode output                                                                                                      |
+| `systemMessage`  | none    | Warning message shown to the user                                                                                                                     |
+
+This example uses a top-level field to stop Claude:
+
+```json  theme={null}
+{ &#34;continue&#34;: false, &#34;stopReason&#34;: &#34;Build failed, fix errors before continuing&#34; }
+```
+
+This example uses `hookSpecificOutput` to deny a PreToolUse tool call:
+
+```json  theme={null}
+{
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;PreToolUse&#34;,
+    &#34;permissionDecision&#34;: &#34;deny&#34;,
+    &#34;permissionDecisionReason&#34;: &#34;Database writes are not allowed&#34;
+  }
+}
+```
+
+For extended examples including Bash command validation, prompt filtering, and auto-approval scripts, see [What you can automate](/en/hooks-guide#what-you-can-automate) in the guide and the [Bash command validator reference implementation](https://github.com/anthropics/claude-code/blob/main/examples/hooks/bash_command_validator_example.py).
+
+## Hook events
+
+Each event corresponds to a point in Claude Code&#39;s lifecycle where hooks can run. The sections below are ordered to match the lifecycle: from session setup through the agentic loop to session end. Each section describes when the event fires, what matchers it supports, the JSON input it receives, and how to control behavior through output.
+
+### SessionStart
+
+Runs when Claude Code starts a new session or resumes an existing session. Useful for loading development context like existing issues or recent changes to your codebase, or setting up environment variables. For static context that does not require a script, use [CLAUDE.md](/en/memory) instead.
+
+SessionStart runs on every session, so keep these hooks fast.
+
+The matcher value corresponds to how the session was initiated:
+
+| Matcher   | When it fires                          |
+| :-------- | :------------------------------------- |
+| `startup` | New session                            |
+| `resume`  | `--resume`, `--continue`, or `/resume` |
+| `clear`   | `/clear`                               |
+| `compact` | Auto or manual compaction              |
+
+#### SessionStart input
+
+In addition to the [common input fields](#common-input-fields), SessionStart hooks receive `source`, `model`, and optionally `agent_type`. The `source` field indicates how the session started: `&#34;startup&#34;` for new sessions, `&#34;resume&#34;` for resumed sessions, `&#34;clear&#34;` after `/clear`, or `&#34;compact&#34;` after compaction. The `model` field contains the model identifier. If you start Claude Code with `claude --agent &lt;name&gt;`, an `agent_type` field contains the agent name.
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;cwd&#34;: &#34;/Users/...&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;SessionStart&#34;,
+  &#34;source&#34;: &#34;startup&#34;,
+  &#34;model&#34;: &#34;claude-sonnet-4-5-20250929&#34;
+}
+```
+
+#### SessionStart decision control
+
+Any text your hook script prints to stdout is added as context for Claude. In addition to the [JSON output fields](#json-output) available to all hooks, you can return these event-specific fields:
+
+| Field               | Description                                                               |
+| :------------------ | :------------------------------------------------------------------------ |
+| `additionalContext` | String added to Claude&#39;s context. Multiple hooks&#39; values are concatenated |
+
+```json  theme={null}
+{
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;SessionStart&#34;,
+    &#34;additionalContext&#34;: &#34;My additional context here&#34;
+  }
+}
+```
+
+#### Persist environment variables
+
+SessionStart hooks have access to the `CLAUDE_ENV_FILE` environment variable, which provides a file path where you can persist environment variables for subsequent Bash commands.
+
+To set individual environment variables, write `export` statements to `CLAUDE_ENV_FILE`. Use append (`&gt;&gt;`) to preserve variables set by other hooks:
+
+```bash  theme={null}
+#!/bin/bash
+
+if [ -n &#34;$CLAUDE_ENV_FILE&#34; ]; then
+  echo &#39;export NODE_ENV=production&#39; &gt;&gt; &#34;$CLAUDE_ENV_FILE&#34;
+  echo &#39;export DEBUG_LOG=true&#39; &gt;&gt; &#34;$CLAUDE_ENV_FILE&#34;
+  echo &#39;export PATH=&#34;$PATH:./node_modules/.bin&#34;&#39; &gt;&gt; &#34;$CLAUDE_ENV_FILE&#34;
+fi
+
+exit 0
+```
+
+To capture all environment changes from setup commands, compare the exported variables before and after:
+
+```bash  theme={null}
+#!/bin/bash
+
+ENV_BEFORE=$(export -p | sort)
+
+# Run your setup commands that modify the environment
+source ~/.nvm/nvm.sh
+nvm use 20
+
+if [ -n &#34;$CLAUDE_ENV_FILE&#34; ]; then
+  ENV_AFTER=$(export -p | sort)
+  comm -13 &lt;(echo &#34;$ENV_BEFORE&#34;) &lt;(echo &#34;$ENV_AFTER&#34;) &gt;&gt; &#34;$CLAUDE_ENV_FILE&#34;
+fi
+
+exit 0
+```
+
+Any variables written to this file will be available in all subsequent Bash commands that Claude Code executes during the session.
+
+&lt;Note&gt;
+  `CLAUDE_ENV_FILE` is available for SessionStart hooks. Other hook types do not have access to this variable.
+&lt;/Note&gt;
+
+### UserPromptSubmit
+
+Runs when the user submits a prompt, before Claude processes it. This allows you
+to add additional context based on the prompt/conversation, validate prompts, or
+block certain types of prompts.
+
+#### UserPromptSubmit input
+
+In addition to the [common input fields](#common-input-fields), UserPromptSubmit hooks receive the `prompt` field containing the text the user submitted.
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;cwd&#34;: &#34;/Users/...&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;UserPromptSubmit&#34;,
+  &#34;prompt&#34;: &#34;Write a function to calculate the factorial of a number&#34;
+}
+```
+
+#### UserPromptSubmit decision control
+
+`UserPromptSubmit` hooks can control whether a user prompt is processed and add context. All [JSON output fields](#json-output) are available.
+
+There are two ways to add context to the conversation on exit code 0:
+
+* **Plain text stdout**: any non-JSON text written to stdout is added as context
+* **JSON with `additionalContext`**: use the JSON format below for more control. The `additionalContext` field is added as context
+
+Plain stdout is shown as hook output in the transcript. The `additionalContext` field is added more discretely.
+
+To block a prompt, return a JSON object with `decision` set to `&#34;block&#34;`:
+
+| Field               | Description                                                                                                        |
+| :------------------ | :----------------------------------------------------------------------------------------------------------------- |
+| `decision`          | `&#34;block&#34;` prevents the prompt from being processed and erases it from context. Omit to allow the prompt to proceed |
+| `reason`            | Shown to the user when `decision` is `&#34;block&#34;`. Not added to context                                               |
+| `additionalContext` | String added to Claude&#39;s context                                                                                   |
+
+```json  theme={null}
+{
+  &#34;decision&#34;: &#34;block&#34;,
+  &#34;reason&#34;: &#34;Explanation for decision&#34;,
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;UserPromptSubmit&#34;,
+    &#34;additionalContext&#34;: &#34;My additional context here&#34;
+  }
+}
+```
+
+&lt;Note&gt;
+  The JSON format isn&#39;t required for simple use cases. To add context, you can print plain text to stdout with exit code 0. Use JSON when you need to
+  block prompts or want more structured control.
+&lt;/Note&gt;
 
 ### PreToolUse
 
-Runs after Claude creates tool parameters and before processing the tool call.
-
-**Common matchers:**
-
-* `Task` - Subagent tasks (see [subagents documentation](/en/sub-agents))
-* `Bash` - Shell commands
-* `Glob` - File pattern matching
-* `Grep` - Content search
-* `Read` - File reading
-* `Edit` - File editing
-* `Write` - File writing
-* `WebFetch`, `WebSearch` - Web operations
+Runs after Claude creates tool parameters and before processing the tool call. Matches on tool name: `Bash`, `Edit`, `Write`, `Read`, `Glob`, `Grep`, `Task`, `WebFetch`, `WebSearch`, and any [MCP tool names](#match-mcp-tools).
 
 Use [PreToolUse decision control](#pretooluse-decision-control) to allow, deny, or ask for permission to use the tool.
+
+#### PreToolUse input
+
+In addition to the [common input fields](#common-input-fields), PreToolUse hooks receive `tool_name`, `tool_input`, and `tool_use_id`. The `tool_input` fields depend on the tool:
+
+##### Bash
+
+Executes shell commands.
+
+| Field               | Type    | Example            | Description                                   |
+| :------------------ | :------ | :----------------- | :-------------------------------------------- |
+| `command`           | string  | `&#34;npm test&#34;`       | The shell command to execute                  |
+| `description`       | string  | `&#34;Run test suite&#34;` | Optional description of what the command does |
+| `timeout`           | number  | `120000`           | Optional timeout in milliseconds              |
+| `run_in_background` | boolean | `false`            | Whether to run the command in background      |
+
+##### Write
+
+Creates or overwrites a file.
+
+| Field       | Type   | Example               | Description                        |
+| :---------- | :----- | :-------------------- | :--------------------------------- |
+| `file_path` | string | `&#34;/path/to/file.txt&#34;` | Absolute path to the file to write |
+| `content`   | string | `&#34;file content&#34;`      | Content to write to the file       |
+
+##### Edit
+
+Replaces a string in an existing file.
+
+| Field         | Type    | Example               | Description                        |
+| :------------ | :------ | :-------------------- | :--------------------------------- |
+| `file_path`   | string  | `&#34;/path/to/file.txt&#34;` | Absolute path to the file to edit  |
+| `old_string`  | string  | `&#34;original text&#34;`     | Text to find and replace           |
+| `new_string`  | string  | `&#34;replacement text&#34;`  | Replacement text                   |
+| `replace_all` | boolean | `false`               | Whether to replace all occurrences |
+
+##### Read
+
+Reads file contents.
+
+| Field       | Type   | Example               | Description                                |
+| :---------- | :----- | :-------------------- | :----------------------------------------- |
+| `file_path` | string | `&#34;/path/to/file.txt&#34;` | Absolute path to the file to read          |
+| `offset`    | number | `10`                  | Optional line number to start reading from |
+| `limit`     | number | `50`                  | Optional number of lines to read           |
+
+##### Glob
+
+Finds files matching a glob pattern.
+
+| Field     | Type   | Example          | Description                                                            |
+| :-------- | :----- | :--------------- | :--------------------------------------------------------------------- |
+| `pattern` | string | `&#34;**/*.ts&#34;`      | Glob pattern to match files against                                    |
+| `path`    | string | `&#34;/path/to/dir&#34;` | Optional directory to search in. Defaults to current working directory |
+
+##### Grep
+
+Searches file contents with regular expressions.
+
+| Field         | Type    | Example          | Description                                                                           |
+| :------------ | :------ | :--------------- | :------------------------------------------------------------------------------------ |
+| `pattern`     | string  | `&#34;TODO.*fix&#34;`    | Regular expression pattern to search for                                              |
+| `path`        | string  | `&#34;/path/to/dir&#34;` | Optional file or directory to search in                                               |
+| `glob`        | string  | `&#34;*.ts&#34;`         | Optional glob pattern to filter files                                                 |
+| `output_mode` | string  | `&#34;content&#34;`      | `&#34;content&#34;`, `&#34;files_with_matches&#34;`, or `&#34;count&#34;`. Defaults to `&#34;files_with_matches&#34;` |
+| `-i`          | boolean | `true`           | Case insensitive search                                                               |
+| `multiline`   | boolean | `false`          | Enable multiline matching                                                             |
+
+##### WebFetch
+
+Fetches and processes web content.
+
+| Field    | Type   | Example                       | Description                          |
+| :------- | :----- | :---------------------------- | :----------------------------------- |
+| `url`    | string | `&#34;https://example.com/api&#34;`   | URL to fetch content from            |
+| `prompt` | string | `&#34;Extract the API endpoints&#34;` | Prompt to run on the fetched content |
+
+##### WebSearch
+
+Searches the web.
+
+| Field             | Type   | Example                        | Description                                       |
+| :---------------- | :----- | :----------------------------- | :------------------------------------------------ |
+| `query`           | string | `&#34;react hooks best practices&#34;` | Search query                                      |
+| `allowed_domains` | array  | `[&#34;docs.example.com&#34;]`         | Optional: only include results from these domains |
+| `blocked_domains` | array  | `[&#34;spam.example.com&#34;]`         | Optional: exclude results from these domains      |
+
+##### Task
+
+Spawns a [subagent](/en/sub-agents).
+
+| Field           | Type   | Example                    | Description                                  |
+| :-------------- | :----- | :------------------------- | :------------------------------------------- |
+| `prompt`        | string | `&#34;Find all API endpoints&#34;` | The task for the agent to perform            |
+| `description`   | string | `&#34;Find API endpoints&#34;`     | Short description of the task                |
+| `subagent_type` | string | `&#34;Explore&#34;`                | Type of specialized agent to use             |
+| `model`         | string | `&#34;sonnet&#34;`                 | Optional model alias to override the default |
+
+#### PreToolUse decision control
+
+`PreToolUse` hooks can control whether a tool call proceeds. In addition to the [JSON output fields](#json-output) available to all hooks, your hook script can return a `hookSpecificOutput` object with these event-specific fields:
+
+| Field                      | Description                                                                                                                                      |
+| :------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------- |
+| `permissionDecision`       | `&#34;allow&#34;` bypasses the permission system, `&#34;deny&#34;` prevents the tool call, `&#34;ask&#34;` prompts the user to confirm                                   |
+| `permissionDecisionReason` | For `&#34;allow&#34;` and `&#34;ask&#34;`, shown to the user but not Claude. For `&#34;deny&#34;`, shown to Claude                                                       |
+| `updatedInput`             | Modifies the tool&#39;s input parameters before execution. Combine with `&#34;allow&#34;` to auto-approve, or `&#34;ask&#34;` to show the modified input to the user |
+| `additionalContext`        | String added to Claude&#39;s context before the tool executes                                                                                        |
+
+```json  theme={null}
+{
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;PreToolUse&#34;,
+    &#34;permissionDecision&#34;: &#34;allow&#34;,
+    &#34;permissionDecisionReason&#34;: &#34;My reason here&#34;,
+    &#34;updatedInput&#34;: {
+      &#34;field_to_modify&#34;: &#34;new value&#34;
+    },
+    &#34;additionalContext&#34;: &#34;Current environment: production. Proceed with caution.&#34;
+  }
+}
+```
+
+&lt;Note&gt;
+  The `decision` and `reason` fields are deprecated for PreToolUse hooks.
+  Use `hookSpecificOutput.permissionDecision` and
+  `hookSpecificOutput.permissionDecisionReason` instead. The deprecated fields
+  `&#34;approve&#34;` and `&#34;block&#34;` map to `&#34;allow&#34;` and `&#34;deny&#34;` respectively.
+&lt;/Note&gt;
 
 ### PermissionRequest
 
 Runs when the user is shown a permission dialog.
 Use [PermissionRequest decision control](#permissionrequest-decision-control) to allow or deny on behalf of the user.
 
-Recognizes the same matcher values as PreToolUse.
+Matches on tool name, same values as PreToolUse.
+
+#### PermissionRequest input
+
+PermissionRequest hooks receive `tool_name` and `tool_input` fields like PreToolUse hooks, but without `tool_use_id`. An optional `permission_suggestions` array contains the &#34;always allow&#34; options the user would normally see in the permission dialog. The difference is when the hook fires: PermissionRequest hooks run when a permission dialog is about to be shown to the user, while PreToolUse hooks run before tool execution regardless of permission status.
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;cwd&#34;: &#34;/Users/...&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;PermissionRequest&#34;,
+  &#34;tool_name&#34;: &#34;Bash&#34;,
+  &#34;tool_input&#34;: {
+    &#34;command&#34;: &#34;rm -rf node_modules&#34;,
+    &#34;description&#34;: &#34;Remove node_modules directory&#34;
+  },
+  &#34;permission_suggestions&#34;: [
+    { &#34;type&#34;: &#34;toolAlwaysAllow&#34;, &#34;tool&#34;: &#34;Bash&#34; }
+  ]
+}
+```
+
+#### PermissionRequest decision control
+
+`PermissionRequest` hooks can allow or deny permission requests. In addition to the [JSON output fields](#json-output) available to all hooks, your hook script can return a `decision` object with these event-specific fields:
+
+| Field                | Description                                                                                                    |
+| :------------------- | :------------------------------------------------------------------------------------------------------------- |
+| `behavior`           | `&#34;allow&#34;` grants the permission, `&#34;deny&#34;` denies it                                                            |
+| `updatedInput`       | For `&#34;allow&#34;` only: modifies the tool&#39;s input parameters before execution                                      |
+| `updatedPermissions` | For `&#34;allow&#34;` only: applies permission rule updates, equivalent to the user selecting an &#34;always allow&#34; option |
+| `message`            | For `&#34;deny&#34;` only: tells Claude why the permission was denied                                                  |
+| `interrupt`          | For `&#34;deny&#34;` only: if `true`, stops Claude                                                                     |
+
+```json  theme={null}
+{
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;PermissionRequest&#34;,
+    &#34;decision&#34;: {
+      &#34;behavior&#34;: &#34;allow&#34;,
+      &#34;updatedInput&#34;: {
+        &#34;command&#34;: &#34;npm run lint&#34;
+      }
+    }
+  }
+}
+```
 
 ### PostToolUse
 
 Runs immediately after a tool completes successfully.
 
-Recognizes the same matcher values as PreToolUse.
+Matches on tool name, same values as PreToolUse.
+
+#### PostToolUse input
+
+`PostToolUse` hooks fire after a tool has already executed successfully. The input includes both `tool_input`, the arguments sent to the tool, and `tool_response`, the result it returned. The exact schema for both depends on the tool.
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;cwd&#34;: &#34;/Users/...&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;PostToolUse&#34;,
+  &#34;tool_name&#34;: &#34;Write&#34;,
+  &#34;tool_input&#34;: {
+    &#34;file_path&#34;: &#34;/path/to/file.txt&#34;,
+    &#34;content&#34;: &#34;file content&#34;
+  },
+  &#34;tool_response&#34;: {
+    &#34;filePath&#34;: &#34;/path/to/file.txt&#34;,
+    &#34;success&#34;: true
+  },
+  &#34;tool_use_id&#34;: &#34;toolu_01ABC123...&#34;
+}
+```
+
+#### PostToolUse decision control
+
+`PostToolUse` hooks can provide feedback to Claude after tool execution. In addition to the [JSON output fields](#json-output) available to all hooks, your hook script can return these event-specific fields:
+
+| Field                  | Description                                                                                |
+| :--------------------- | :----------------------------------------------------------------------------------------- |
+| `decision`             | `&#34;block&#34;` prompts Claude with the `reason`. Omit to allow the action to proceed            |
+| `reason`               | Explanation shown to Claude when `decision` is `&#34;block&#34;`                                   |
+| `additionalContext`    | Additional context for Claude to consider                                                  |
+| `updatedMCPToolOutput` | For [MCP tools](#match-mcp-tools) only: replaces the tool&#39;s output with the provided value |
+
+```json  theme={null}
+{
+  &#34;decision&#34;: &#34;block&#34;,
+  &#34;reason&#34;: &#34;Explanation for decision&#34;,
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;PostToolUse&#34;,
+    &#34;additionalContext&#34;: &#34;Additional information for Claude&#34;
+  }
+}
+```
+
+### PostToolUseFailure
+
+Runs when a tool execution fails. This event fires for tool calls that throw errors or return failure results. Use this to log failures, send alerts, or provide corrective feedback to Claude.
+
+Matches on tool name, same values as PreToolUse.
+
+#### PostToolUseFailure input
+
+PostToolUseFailure hooks receive the same `tool_name` and `tool_input` fields as PostToolUse, along with error information as top-level fields:
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;cwd&#34;: &#34;/Users/...&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;PostToolUseFailure&#34;,
+  &#34;tool_name&#34;: &#34;Bash&#34;,
+  &#34;tool_input&#34;: {
+    &#34;command&#34;: &#34;npm test&#34;,
+    &#34;description&#34;: &#34;Run test suite&#34;
+  },
+  &#34;tool_use_id&#34;: &#34;toolu_01ABC123...&#34;,
+  &#34;error&#34;: &#34;Command exited with non-zero status code 1&#34;,
+  &#34;is_interrupt&#34;: false
+}
+```
+
+| Field          | Description                                                                     |
+| :------------- | :------------------------------------------------------------------------------ |
+| `error`        | String describing what went wrong                                               |
+| `is_interrupt` | Optional boolean indicating whether the failure was caused by user interruption |
+
+#### PostToolUseFailure decision control
+
+`PostToolUseFailure` hooks can provide context to Claude after a tool failure. In addition to the [JSON output fields](#json-output) available to all hooks, your hook script can return these event-specific fields:
+
+| Field               | Description                                                   |
+| :------------------ | :------------------------------------------------------------ |
+| `additionalContext` | Additional context for Claude to consider alongside the error |
+
+```json  theme={null}
+{
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;PostToolUseFailure&#34;,
+    &#34;additionalContext&#34;: &#34;Additional information about the failure for Claude&#34;
+  }
+}
+```
 
 ### Notification
 
-Runs when Claude Code sends notifications. Supports matchers to filter by notification type.
-
-**Common matchers:**
-
-* `permission_prompt` - Permission requests from Claude Code
-* `idle_prompt` - When Claude is waiting for user input (after 60+ seconds of idle time)
-* `auth_success` - Authentication success notifications
-* `elicitation_dialog` - When Claude Code needs input for MCP tool elicitation
-
-You can use matchers to run different hooks for different notification types, or omit the matcher to run hooks for all notifications.
-
-**Example: Different notifications for different types**
+Runs when Claude Code sends notifications. Matches on notification type: `permission_prompt`, `idle_prompt`, `auth_success`, `elicitation_dialog`. Omit the matcher to run hooks for all notification types.
+
+Use separate matchers to run different handlers depending on the notification type. This configuration triggers a permission-specific alert script when Claude needs permission approval and a different notification when Claude has been idle:
 
 ```json  theme={null}
 {
@@ -416,266 +959,9 @@
 }
 ```
 
-### UserPromptSubmit
-
-Runs when the user submits a prompt, before Claude processes it. This allows you
-to add additional context based on the prompt/conversation, validate prompts, or
-block certain types of prompts.
-
-### Stop
-
-Runs when the main Claude Code agent has finished responding. Does not run if
-the stoppage occurred due to a user interrupt.
-
-### SubagentStop
-
-Runs when a Claude Code subagent (Task tool call) has finished responding.
-
-### PreCompact
-
-Runs before Claude Code is about to run a compact operation.
-
-**Matchers:**
-
-* `manual` - Invoked from `/compact`
-* `auto` - Invoked from auto-compact (due to full context window)
-
-### Setup
-
-Runs when Claude Code is invoked with repository setup and maintenance flags (`--init`, `--init-only`, or `--maintenance`). Use this hook for operations you don&#39;t want on every session—such as installing dependencies, running migrations, or periodic maintenance tasks.
-
-&lt;Note&gt;
-  Use **Setup** hooks for one-time or occasional operations (dependency installation, migrations, cleanup). Use **SessionStart** hooks for things you want on every session (loading context, setting environment variables). Setup hooks require explicit flags because running them automatically would slow down every session start.
-&lt;/Note&gt;
-
-**Matchers:**
-
-* `init` - Invoked from `--init` or `--init-only` flags
-* `maintenance` - Invoked from `--maintenance` flag
-
-Setup hooks have access to the `CLAUDE_ENV_FILE` environment variable for persisting environment variables, similar to SessionStart hooks.
-
-### SessionStart
-
-Runs when Claude Code starts a new session or resumes an existing session (which
-currently does start a new session under the hood). Useful for loading development context like existing issues or recent changes to your codebase, or setting up environment variables.
-
-&lt;Note&gt;
-  For one-time operations like installing dependencies or running migrations, use [Setup hooks](#setup) instead. SessionStart runs on every session, so keep these hooks fast.
-&lt;/Note&gt;
-
-**Matchers:**
-
-* `startup` - Invoked from startup
-* `resume` - Invoked from `--resume`, `--continue`, or `/resume`
-* `clear` - Invoked from `/clear`
-* `compact` - Invoked from auto or manual compact.
-
-#### Persisting environment variables
-
-SessionStart hooks have access to the `CLAUDE_ENV_FILE` environment variable, which provides a file path where you can persist environment variables for subsequent bash commands.
-
-**Example: Setting individual environment variables**
-
-```bash  theme={null}
-#!/bin/bash
-
-if [ -n &#34;$CLAUDE_ENV_FILE&#34; ]; then
-  echo &#39;export NODE_ENV=production&#39; &gt;&gt; &#34;$CLAUDE_ENV_FILE&#34;
-  echo &#39;export API_KEY=your-api-key&#39; &gt;&gt; &#34;$CLAUDE_ENV_FILE&#34;
-  echo &#39;export PATH=&#34;$PATH:./node_modules/.bin&#34;&#39; &gt;&gt; &#34;$CLAUDE_ENV_FILE&#34;
-fi
-
-exit 0
-```
-
-**Example: Persisting all environment changes from the hook**
-
-When your setup modifies the environment (for example, `nvm use`), capture and persist all changes by diffing the environment:
-
-```bash  theme={null}
-#!/bin/bash
-
-ENV_BEFORE=$(export -p | sort)
-
-# Run your setup commands that modify the environment
-source ~/.nvm/nvm.sh
-nvm use 20
-
-if [ -n &#34;$CLAUDE_ENV_FILE&#34; ]; then
-  ENV_AFTER=$(export -p | sort)
-  comm -13 &lt;(echo &#34;$ENV_BEFORE&#34;) &lt;(echo &#34;$ENV_AFTER&#34;) &gt;&gt; &#34;$CLAUDE_ENV_FILE&#34;
-fi
-
-exit 0
-```
-
-Any variables written to this file will be available in all subsequent bash commands that Claude Code executes during the session.
-
-&lt;Note&gt;
-  `CLAUDE_ENV_FILE` is only available for SessionStart hooks. Other hook types do not have access to this variable.
-&lt;/Note&gt;
-
-### SessionEnd
-
-Runs when a Claude Code session ends. Useful for cleanup tasks, logging session
-statistics, or saving session state.
-
-The `reason` field in the hook input will be one of:
-
-* `clear` - Session cleared with /clear command
-* `logout` - User logged out
-* `prompt_input_exit` - User exited while prompt input was visible
-* `other` - Other exit reasons
-
-## Hook Input
-
-Hooks receive JSON data via stdin containing session information and
-event-specific data:
-
-```typescript  theme={null}
-{
-  // Common fields
-  session_id: string
-  transcript_path: string  // Path to conversation JSON
-  cwd: string              // The current working directory when the hook is invoked
-  permission_mode: string  // Current permission mode: &#34;default&#34;, &#34;plan&#34;, &#34;acceptEdits&#34;, &#34;dontAsk&#34;, or &#34;bypassPermissions&#34;
-
-  // Event-specific fields
-  hook_event_name: string
-  ...
-}
-```
-
-### PreToolUse Input
-
-The exact schema for `tool_input` depends on the tool. Here are examples for commonly hooked tools.
-
-#### Bash tool
-
-The Bash tool is the most commonly hooked tool for command validation:
-
-```json  theme={null}
-{
-  &#34;session_id&#34;: &#34;abc123&#34;,
-  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
-  &#34;cwd&#34;: &#34;/Users/...&#34;,
-  &#34;permission_mode&#34;: &#34;default&#34;,
-  &#34;hook_event_name&#34;: &#34;PreToolUse&#34;,
-  &#34;tool_name&#34;: &#34;Bash&#34;,
-  &#34;tool_input&#34;: {
-    &#34;command&#34;: &#34;psql -c &#39;SELECT * FROM users&#39;&#34;,
-    &#34;description&#34;: &#34;Query the users table&#34;,
-    &#34;timeout&#34;: 120000
-  },
-  &#34;tool_use_id&#34;: &#34;toolu_01ABC123...&#34;
-}
-```
-
-| Field               | Type    | Description                                   |
-| :------------------ | :------ | :-------------------------------------------- |
-| `command`           | string  | The shell command to execute                  |
-| `description`       | string  | Optional description of what the command does |
-| `timeout`           | number  | Optional timeout in milliseconds              |
-| `run_in_background` | boolean | Whether to run the command in background      |
-
-#### Write tool
-
-```json  theme={null}
-{
-  &#34;session_id&#34;: &#34;abc123&#34;,
-  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
-  &#34;cwd&#34;: &#34;/Users/...&#34;,
-  &#34;permission_mode&#34;: &#34;default&#34;,
-  &#34;hook_event_name&#34;: &#34;PreToolUse&#34;,
-  &#34;tool_name&#34;: &#34;Write&#34;,
-  &#34;tool_input&#34;: {
-    &#34;file_path&#34;: &#34;/path/to/file.txt&#34;,
-    &#34;content&#34;: &#34;file content&#34;
-  },
-  &#34;tool_use_id&#34;: &#34;toolu_01ABC123...&#34;
-}
-```
-
-| Field       | Type   | Description                        |
-| :---------- | :----- | :--------------------------------- |
-| `file_path` | string | Absolute path to the file to write |
-| `content`   | string | Content to write to the file       |
-
-#### Edit tool
-
-```json  theme={null}
-{
-  &#34;session_id&#34;: &#34;abc123&#34;,
-  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
-  &#34;cwd&#34;: &#34;/Users/...&#34;,
-  &#34;permission_mode&#34;: &#34;default&#34;,
-  &#34;hook_event_name&#34;: &#34;PreToolUse&#34;,
-  &#34;tool_name&#34;: &#34;Edit&#34;,
-  &#34;tool_input&#34;: {
-    &#34;file_path&#34;: &#34;/path/to/file.txt&#34;,
-    &#34;old_string&#34;: &#34;original text&#34;,
-    &#34;new_string&#34;: &#34;replacement text&#34;
-  },
-  &#34;tool_use_id&#34;: &#34;toolu_01ABC123...&#34;
-}
-```
-
-| Field         | Type    | Description                                         |
-| :------------ | :------ | :-------------------------------------------------- |
-| `file_path`   | string  | Absolute path to the file to edit                   |
-| `old_string`  | string  | Text to find and replace                            |
-| `new_string`  | string  | Replacement text                                    |
-| `replace_all` | boolean | Whether to replace all occurrences (default: false) |
-
-#### Read tool
-
-```json  theme={null}
-{
-  &#34;session_id&#34;: &#34;abc123&#34;,
-  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
-  &#34;cwd&#34;: &#34;/Users/...&#34;,
-  &#34;permission_mode&#34;: &#34;default&#34;,
-  &#34;hook_event_name&#34;: &#34;PreToolUse&#34;,
-  &#34;tool_name&#34;: &#34;Read&#34;,
-  &#34;tool_input&#34;: {
-    &#34;file_path&#34;: &#34;/path/to/file.txt&#34;
-  },
-  &#34;tool_use_id&#34;: &#34;toolu_01ABC123...&#34;
-}
-```
-
-| Field       | Type   | Description                                |
-| :---------- | :----- | :----------------------------------------- |
-| `file_path` | string | Absolute path to the file to read          |
-| `offset`    | number | Optional line number to start reading from |
-| `limit`     | number | Optional number of lines to read           |
-
-### PostToolUse Input
-
-The exact schema for `tool_input` and `tool_response` depends on the tool.
-
-```json  theme={null}
-{
-  &#34;session_id&#34;: &#34;abc123&#34;,
-  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
-  &#34;cwd&#34;: &#34;/Users/...&#34;,
-  &#34;permission_mode&#34;: &#34;default&#34;,
-  &#34;hook_event_name&#34;: &#34;PostToolUse&#34;,
-  &#34;tool_name&#34;: &#34;Write&#34;,
-  &#34;tool_input&#34;: {
-    &#34;file_path&#34;: &#34;/path/to/file.txt&#34;,
-    &#34;content&#34;: &#34;file content&#34;
-  },
-  &#34;tool_response&#34;: {
-    &#34;filePath&#34;: &#34;/path/to/file.txt&#34;,
-    &#34;success&#34;: true
-  },
-  &#34;tool_use_id&#34;: &#34;toolu_01ABC123...&#34;
-}
-```
-
-### Notification Input
+#### Notification input
+
+In addition to the [common input fields](#common-input-fields), Notification hooks receive `message` with the notification text, an optional `title`, and `notification_type` indicating which type fired.
 
 ```json  theme={null}
 {
@@ -685,11 +971,24 @@
   &#34;permission_mode&#34;: &#34;default&#34;,
   &#34;hook_event_name&#34;: &#34;Notification&#34;,
   &#34;message&#34;: &#34;Claude needs your permission to use Bash&#34;,
+  &#34;title&#34;: &#34;Permission needed&#34;,
   &#34;notification_type&#34;: &#34;permission_prompt&#34;
 }
 ```
 
-### UserPromptSubmit Input
+Notification hooks cannot block or modify notifications. In addition to the [JSON output fields](#json-output) available to all hooks, you can return `additionalContext` to add context to the conversation:
+
+| Field               | Description                      |
+| :------------------ | :------------------------------- |
+| `additionalContext` | String added to Claude&#39;s context |
+
+### SubagentStart
+
+Runs when a Claude Code subagent is spawned via the Task tool. Supports matchers to filter by agent type name (built-in agents like `Bash`, `Explore`, `Plan`, or custom agent names from `.claude/agents/`).
+
+#### SubagentStart input
+
+In addition to the [common input fields](#common-input-fields), SubagentStart hooks receive `agent_id` with the unique identifier for the subagent and `agent_type` with the agent name (built-in agents like `&#34;Bash&#34;`, `&#34;Explore&#34;`, `&#34;Plan&#34;`, or custom agent names).
 
 ```json  theme={null}
 {
@@ -697,31 +996,34 @@
   &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
   &#34;cwd&#34;: &#34;/Users/...&#34;,
   &#34;permission_mode&#34;: &#34;default&#34;,
-  &#34;hook_event_name&#34;: &#34;UserPromptSubmit&#34;,
-  &#34;prompt&#34;: &#34;Write a function to calculate the factorial of a number&#34;
-}
-```
-
-### Stop Input
-
-`stop_hook_active` is true when Claude Code is already continuing as a result of
-a stop hook. Check this value or process the transcript to prevent Claude Code
-from running indefinitely.
-
-```json  theme={null}
-{
-  &#34;session_id&#34;: &#34;abc123&#34;,
-  &#34;transcript_path&#34;: &#34;~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
-  &#34;cwd&#34;: &#34;/Users/...&#34;,
-  &#34;permission_mode&#34;: &#34;default&#34;,
-  &#34;hook_event_name&#34;: &#34;Stop&#34;,
-  &#34;stop_hook_active&#34;: true
-}
-```
-
-### SubagentStop Input
-
-Triggered when a subagent finishes. The `transcript_path` is the main session&#39;s transcript, while `agent_transcript_path` is the subagent&#39;s own transcript stored in a nested `subagents/` folder.
+  &#34;hook_event_name&#34;: &#34;SubagentStart&#34;,
+  &#34;agent_id&#34;: &#34;agent-abc123&#34;,
+  &#34;agent_type&#34;: &#34;Explore&#34;
+}
+```
+
+SubagentStart hooks cannot block subagent creation, but they can inject context into the subagent. In addition to the [JSON output fields](#json-output) available to all hooks, you can return:
+
+| Field               | Description                            |
+| :------------------ | :------------------------------------- |
+| `additionalContext` | String added to the subagent&#39;s context |
+
+```json  theme={null}
+{
+  &#34;hookSpecificOutput&#34;: {
+    &#34;hookEventName&#34;: &#34;SubagentStart&#34;,
+    &#34;additionalContext&#34;: &#34;Follow security guidelines for this task&#34;
+  }
+}
+```
+
+### SubagentStop
+
+Runs when a Claude Code subagent has finished responding. Matches on agent type, same values as SubagentStart.
+
+#### SubagentStop input
+
+In addition to the [common input fields](#common-input-fields), SubagentStop hooks receive `stop_hook_active`, `agent_id`, `agent_type`, and `agent_transcript_path`. The `agent_type` field is the value used for matcher filtering. The `transcript_path` is the main session&#39;s transcript, while `agent_transcript_path` is the subagent&#39;s own transcript stored in a nested `subagents/` folder.
 
 ```json  theme={null}
 {
@@ -732,19 +1034,69 @@
   &#34;hook_event_name&#34;: &#34;SubagentStop&#34;,
   &#34;stop_hook_active&#34;: false,
   &#34;agent_id&#34;: &#34;def456&#34;,
+  &#34;agent_type&#34;: &#34;Explore&#34;,
   &#34;agent_transcript_path&#34;: &#34;~/.claude/projects/.../abc123/subagents/agent-def456.jsonl&#34;
 }
 ```
 
-### PreCompact Input
-
-For `manual`, `custom_instructions` comes from what the user passes into
-`/compact`. For `auto`, `custom_instructions` is empty.
+SubagentStop hooks use the same decision control format as [Stop hooks](#stop-decision-control).
+
+### Stop
+
+Runs when the main Claude Code agent has finished responding. Does not run if
+the stoppage occurred due to a user interrupt.
+
+#### Stop input
+
+In addition to the [common input fields](#common-input-fields), Stop hooks receive `stop_hook_active`. This field is `true` when Claude Code is already continuing as a result of a stop hook. Check this value or process the transcript to prevent Claude Code from running indefinitely.
 
 ```json  theme={null}
 {
   &#34;session_id&#34;: &#34;abc123&#34;,
   &#34;transcript_path&#34;: &#34;~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;cwd&#34;: &#34;/Users/...&#34;,
+  &#34;permission_mode&#34;: &#34;default&#34;,
+  &#34;hook_event_name&#34;: &#34;Stop&#34;,
+  &#34;stop_hook_active&#34;: true
+}
+```
+
+#### Stop decision control
+
+`Stop` and `SubagentStop` hooks can control whether Claude continues. In addition to the [JSON output fields](#json-output) available to all hooks, your hook script can return these event-specific fields:
+
+| Field      | Description                                                                |
+| :--------- | :------------------------------------------------------------------------- |
+| `decision` | `&#34;block&#34;` prevents Claude from stopping. Omit to allow Claude to stop      |
+| `reason`   | Required when `decision` is `&#34;block&#34;`. Tells Claude why it should continue |
+
+```json  theme={null}
+{
+  &#34;decision&#34;: &#34;block&#34;,
+  &#34;reason&#34;: &#34;Must be provided when Claude is blocked from stopping&#34;
+}
+```
+
+### PreCompact
+
+Runs before Claude Code is about to run a compact operation.
+
+The matcher value indicates whether compaction was triggered manually or automatically:
+
+| Matcher  | When it fires                                |
+| :------- | :------------------------------------------- |
+| `manual` | `/compact`                                   |
+| `auto`   | Auto-compact when the context window is full |
+
+#### PreCompact input
+
+In addition to the [common input fields](#common-input-fields), PreCompact hooks receive `trigger` and `custom_instructions`. For `manual`, `custom_instructions` contains what the user passes into `/compact`. For `auto`, `custom_instructions` is empty.
+
+```json  theme={null}
+{
+  &#34;session_id&#34;: &#34;abc123&#34;,
+  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;cwd&#34;: &#34;/Users/...&#34;,
   &#34;permission_mode&#34;: &#34;default&#34;,
   &#34;hook_event_name&#34;: &#34;PreCompact&#34;,
   &#34;trigger&#34;: &#34;manual&#34;,
@@ -752,507 +1104,65 @@
 }
 ```
 
-### Setup Input
+### SessionEnd
+
+Runs when a Claude Code session ends. Useful for cleanup tasks, logging session
+statistics, or saving session state. Supports matchers to filter by exit reason.
+
+The `reason` field in the hook input indicates why the session ended:
+
+| Reason                        | Description                                |
+| :---------------------------- | :----------------------------------------- |
+| `clear`                       | Session cleared with `/clear` command      |
+| `logout`                      | User logged out                            |
+| `prompt_input_exit`           | User exited while prompt input was visible |
+| `bypass_permissions_disabled` | Bypass permissions mode was disabled       |
+| `other`                       | Other exit reasons                         |
+
+#### SessionEnd input
+
+In addition to the [common input fields](#common-input-fields), SessionEnd hooks receive a `reason` field indicating why the session ended. See the [reason table](#sessionend) above for all values.
 
 ```json  theme={null}
 {
   &#34;session_id&#34;: &#34;abc123&#34;,
-  &#34;transcript_path&#34;: &#34;~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
-  &#34;cwd&#34;: &#34;/Users/...&#34;,
-  &#34;permission_mode&#34;: &#34;default&#34;,
-  &#34;hook_event_name&#34;: &#34;Setup&#34;,
-  &#34;trigger&#34;: &#34;init&#34;
-}
-```
-
-The `trigger` field will be either `&#34;init&#34;` (from `--init` or `--init-only`) or `&#34;maintenance&#34;` (from `--maintenance`).
-
-### SessionStart Input
-
-```json  theme={null}
-{
-  &#34;session_id&#34;: &#34;abc123&#34;,
-  &#34;transcript_path&#34;: &#34;~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
-  &#34;cwd&#34;: &#34;/Users/...&#34;,
-  &#34;permission_mode&#34;: &#34;default&#34;,
-  &#34;hook_event_name&#34;: &#34;SessionStart&#34;,
-  &#34;source&#34;: &#34;startup&#34;,
-  &#34;model&#34;: &#34;claude-sonnet-4-20250514&#34;
-}
-```
-
-The `source` field indicates how the session started: `&#34;startup&#34;` for new sessions, `&#34;resume&#34;` for resumed sessions, `&#34;clear&#34;` after `/clear`, or `&#34;compact&#34;` after compaction. The `model` field contains the model identifier when available. If you start Claude Code with `claude --agent &lt;name&gt;`, an `agent_type` field contains the agent name.
-
-### SubagentStart Input
-
-```json  theme={null}
-{
-  &#34;session_id&#34;: &#34;abc123&#34;,
-  &#34;transcript_path&#34;: &#34;~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
-  &#34;cwd&#34;: &#34;/Users/...&#34;,
-  &#34;permission_mode&#34;: &#34;default&#34;,
-  &#34;hook_event_name&#34;: &#34;SubagentStart&#34;,
-  &#34;agent_id&#34;: &#34;agent-abc123&#34;,
-  &#34;agent_type&#34;: &#34;Explore&#34;
-}
-```
-
-Triggered when a subagent is spawned. The `agent_id` field contains the unique identifier for the subagent, and `agent_type` contains the agent name (built-in agents like `&#34;Bash&#34;`, `&#34;Explore&#34;`, `&#34;Plan&#34;`, or custom agent names).
-
-### SessionEnd Input
-
-```json  theme={null}
-{
-  &#34;session_id&#34;: &#34;abc123&#34;,
-  &#34;transcript_path&#34;: &#34;~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
+  &#34;transcript_path&#34;: &#34;/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl&#34;,
   &#34;cwd&#34;: &#34;/Users/...&#34;,
   &#34;permission_mode&#34;: &#34;default&#34;,
   &#34;hook_event_name&#34;: &#34;SessionEnd&#34;,
-  &#34;reason&#34;: &#34;exit&#34;
-}
-```
-
-## Hook Output
-
-There are two mutually exclusive ways for hooks to return output back to Claude Code. The output
-communicates whether to block and any feedback that should be shown to Claude
-and the user.
-
-### Simple: Exit Code
-
-Hooks communicate status through exit codes, stdout, and stderr:
-
-* **Exit code 0**: Success. `stdout` is shown to the user in verbose mode
-  (ctrl+o), except for `UserPromptSubmit` and `SessionStart`, where stdout is
-  added to the context. JSON output in `stdout` is parsed for structured control
-  (see [Advanced: JSON Output](#advanced-json-output)).
-* **Exit code 2**: Blocking error. Only `stderr` is used as the error message
-  and fed back to Claude. The format is `[command]: {stderr}`. JSON in `stdout`
-  is **not** processed for exit code 2. See per-hook-event behavior below.
-* **Other exit codes**: Non-blocking error. `stderr` is shown to the user in verbose mode (ctrl+o) with
-  format `Failed with non-blocking status code: {stderr}`. If `stderr` is empty,
-  it shows `No stderr output`. Execution continues.
-
-&lt;Warning&gt;
-  Reminder: Claude Code does not see stdout if the exit code is 0, except for
-  the `UserPromptSubmit` hook where stdout is injected as context.
-&lt;/Warning&gt;
-
-#### Exit Code 2 Behavior
-
-| Hook Event          | Behavior                                                           |
-| ------------------- | ------------------------------------------------------------------ |
-| `PreToolUse`        | Blocks the tool call, shows stderr to Claude                       |
-| `PermissionRequest` | Denies the permission, shows stderr to Claude                      |
-| `PostToolUse`       | Shows stderr to Claude (tool already ran)                          |
-| `Notification`      | N/A, shows stderr to user only                                     |
-| `UserPromptSubmit`  | Blocks prompt processing, erases prompt, shows stderr to user only |
-| `Stop`              | Blocks stoppage, shows stderr to Claude                            |
-| `SubagentStop`      | Blocks stoppage, shows stderr to Claude subagent                   |
-| `PreCompact`        | N/A, shows stderr to user only                                     |
-| `Setup`             | N/A, shows stderr to user only                                     |
-| `SessionStart`      | N/A, shows stderr to user only                                     |
-| `SessionEnd`        | N/A, shows stderr to user only                                     |
-
-### Advanced: JSON Output
-
-Hooks can return structured JSON in `stdout` for more sophisticated control.
-
-&lt;Warning&gt;
-  JSON output is only processed when the hook exits with code 0. If your hook
-  exits with code 2 (blocking error), `stderr` text is used directly—any JSON in `stdout`
-  is ignored. For other non-zero exit codes, only `stderr` is shown to the user in verbose mode (ctrl+o).
-&lt;/Warning&gt;
-
-#### Common JSON Fields
-
-All hook types can include these optional fields:
-
-```json  theme={null}
-{
-  &#34;continue&#34;: true, // Whether Claude should continue after hook execution (default: true)
-  &#34;stopReason&#34;: &#34;string&#34;, // Message shown when continue is false
-
-  &#34;suppressOutput&#34;: true, // Hide stdout from transcript mode (default: false)
-  &#34;systemMessage&#34;: &#34;string&#34; // Optional warning message shown to the user
-}
-```
-
-If `continue` is false, Claude stops processing after the hooks run.
-
-* For `PreToolUse`, this is different from `&#34;permissionDecision&#34;: &#34;deny&#34;`, which
-  only blocks a specific tool call and provides automatic feedback to Claude.
-* For `PostToolUse`, this is different from `&#34;decision&#34;: &#34;block&#34;`, which
-  provides automated feedback to Claude.
-* For `UserPromptSubmit`, this prevents the prompt from being processed.
-* For `Stop` and `SubagentStop`, this takes precedence over any
-  `&#34;decision&#34;: &#34;block&#34;` output.
-* In all cases, `&#34;continue&#34; = false` takes precedence over any
-  `&#34;decision&#34;: &#34;block&#34;` output.
-
-`stopReason` accompanies `continue` with a reason shown to the user, not shown
-to Claude.
-
-#### `PreToolUse` Decision Control
-
-`PreToolUse` hooks can control whether a tool call proceeds.
-
-* `&#34;allow&#34;` bypasses the permission system. `permissionDecisionReason` is shown
-  to the user but not to Claude.
-* `&#34;deny&#34;` prevents the tool call from executing. `permissionDecisionReason` is
-  shown to Claude.
-* `&#34;ask&#34;` asks the user to confirm the tool call in the UI.
-  `permissionDecisionReason` is shown to the user but not to Claude.
-
-Additionally, hooks can modify tool inputs before execution using `updatedInput`:
-
-* `updatedInput` modifies the tool&#39;s input parameters before the tool executes
-* Combine with `&#34;permissionDecision&#34;: &#34;allow&#34;` to modify the input and auto-approve the tool call
-* Combine with `&#34;permissionDecision&#34;: &#34;ask&#34;` to modify the input and show it to the user for confirmation
-
-Hooks can also provide context to Claude using `additionalContext`:
-
-* `&#34;hookSpecificOutput.additionalContext&#34;` adds a string to Claude&#39;s context before the tool executes.
-
-```json  theme={null}
-{
-  &#34;hookSpecificOutput&#34;: {
-    &#34;hookEventName&#34;: &#34;PreToolUse&#34;,
-    &#34;permissionDecision&#34;: &#34;allow&#34;,
-    &#34;permissionDecisionReason&#34;: &#34;My reason here&#34;,
-    &#34;updatedInput&#34;: {
-      &#34;field_to_modify&#34;: &#34;new value&#34;
-    },
-    &#34;additionalContext&#34;: &#34;Current environment: production. Proceed with caution.&#34;
-  }
-}
-```
-
-&lt;Note&gt;
-  The `decision` and `reason` fields are deprecated for PreToolUse hooks.
-  Use `hookSpecificOutput.permissionDecision` and
-  `hookSpecificOutput.permissionDecisionReason` instead. The deprecated fields
-  `&#34;approve&#34;` and `&#34;block&#34;` map to `&#34;allow&#34;` and `&#34;deny&#34;` respectively.
-&lt;/Note&gt;
-
-#### `PermissionRequest` Decision Control
-
-`PermissionRequest` hooks can allow or deny permission requests shown to the user.
-
-* For `&#34;behavior&#34;: &#34;allow&#34;` you can also optionally pass in an `&#34;updatedInput&#34;` that modifies the tool&#39;s input parameters before the tool executes.
-* For `&#34;behavior&#34;: &#34;deny&#34;` you can also optionally pass in a `&#34;message&#34;` string that tells the model why the permission was denied, and a boolean `&#34;interrupt&#34;` which will stop Claude.
-
-```json  theme={null}
-{
-  &#34;hookSpecificOutput&#34;: {
-    &#34;hookEventName&#34;: &#34;PermissionRequest&#34;,
-    &#34;decision&#34;: {
-      &#34;behavior&#34;: &#34;allow&#34;,
-      &#34;updatedInput&#34;: {
-        &#34;command&#34;: &#34;npm run lint&#34;
-      }
-    }
-  }
-}
-```
-
-#### `PostToolUse` Decision Control
-
-`PostToolUse` hooks can provide feedback to Claude after tool execution.
-
-* `&#34;block&#34;` automatically prompts Claude with `reason`.
-* `undefined` does nothing. `reason` is ignored.
-* `&#34;hookSpecificOutput.additionalContext&#34;` adds context for Claude to consider.
-
-```json  theme={null}
-{
-  &#34;decision&#34;: &#34;block&#34; | undefined,
-  &#34;reason&#34;: &#34;Explanation for decision&#34;,
-  &#34;hookSpecificOutput&#34;: {
-    &#34;hookEventName&#34;: &#34;PostToolUse&#34;,
-    &#34;additionalContext&#34;: &#34;Additional information for Claude&#34;
-  }
-}
-```
-
-#### `UserPromptSubmit` Decision Control
-
-`UserPromptSubmit` hooks can control whether a user prompt is processed and add context.
-
-**Adding context (exit code 0):**
-There are two ways to add context to the conversation:
-
-1. **Plain text stdout** (simpler): Any non-JSON text written to stdout is added
-   as context. This is the easiest way to inject information.
-
-2. **JSON with `additionalContext`** (structured): Use the JSON format below for
-   more control. The `additionalContext` field is added as context.
-
-Both methods work with exit code 0. Plain stdout is shown as hook output in
-the transcript; `additionalContext` is added more discretely.
-
-**Blocking prompts:**
-
-* `&#34;decision&#34;: &#34;block&#34;` prevents the prompt from being processed. The submitted
-  prompt is erased from context. `&#34;reason&#34;` is shown to the user but not added
-  to context.
-* `&#34;decision&#34;: undefined` (or omitted) allows the prompt to proceed normally.
-
-```json  theme={null}
-{
-  &#34;decision&#34;: &#34;block&#34; | undefined,
-  &#34;reason&#34;: &#34;Explanation for decision&#34;,
-  &#34;hookSpecificOutput&#34;: {
-    &#34;hookEventName&#34;: &#34;UserPromptSubmit&#34;,
-    &#34;additionalContext&#34;: &#34;My additional context here&#34;
-  }
-}
-```
-
-&lt;Note&gt;
-  The JSON format isn&#39;t required for simple use cases. To add context, you can print plain text to stdout with exit code 0. Use JSON when you need to
-  block prompts or want more structured control.
-&lt;/Note&gt;
-
-#### `Stop`/`SubagentStop` Decision Control
-
-`Stop` and `SubagentStop` hooks can control whether Claude must continue.
-
-* `&#34;block&#34;` prevents Claude from stopping. You must populate `reason` for Claude
-  to know how to proceed.
-* `undefined` allows Claude to stop. `reason` is ignored.
-
-```json  theme={null}
-{
-  &#34;decision&#34;: &#34;block&#34; | undefined,
-  &#34;reason&#34;: &#34;Must be provided when Claude is blocked from stopping&#34;
-}
-```
-
-#### `Setup` Decision Control
-
-`Setup` hooks allow you to load context and configure the environment during repository initialization or maintenance.
-
-* `&#34;hookSpecificOutput.additionalContext&#34;` adds the string to the context.
-* Multiple hooks&#39; `additionalContext` values are concatenated.
-* Setup hooks have access to `CLAUDE_ENV_FILE` for persisting environment variables.
-
-```json  theme={null}
-{
-  &#34;hookSpecificOutput&#34;: {
-    &#34;hookEventName&#34;: &#34;Setup&#34;,
-    &#34;additionalContext&#34;: &#34;Repository initialized with custom configuration&#34;
-  }
-}
-```
-
-#### `SessionStart` Decision Control
-
-`SessionStart` hooks allow you to load in context at the start of a session.
-
-* `&#34;hookSpecificOutput.additionalContext&#34;` adds the string to the context.
-* Multiple hooks&#39; `additionalContext` values are concatenated.
-
-```json  theme={null}
-{
-  &#34;hookSpecificOutput&#34;: {
-    &#34;hookEventName&#34;: &#34;SessionStart&#34;,
-    &#34;additionalContext&#34;: &#34;My additional context here&#34;
-  }
-}
-```
-
-#### `SessionEnd` Decision Control
-
-`SessionEnd` hooks run when a session ends. They cannot block session termination
-but can perform cleanup tasks.
-
-#### Exit Code Example: Bash Command Validation
-
-```python  theme={null}
-#!/usr/bin/env python3
-import json
-import re
-import sys
-
-# Define validation rules as a list of (regex pattern, message) tuples
-VALIDATION_RULES = [
-    (
-        r&#34;\bgrep\b(?!.*\|)&#34;,
-        &#34;Use &#39;rg&#39; (ripgrep) instead of &#39;grep&#39; for better performance and features&#34;,
-    ),
-    (
-        r&#34;\bfind\s+\S+\s+-name\b&#34;,
-        &#34;Use &#39;rg --files | rg pattern&#39; or &#39;rg --files -g pattern&#39; instead of &#39;find -name&#39; for better performance&#34;,
-    ),
-]
-
-
-def validate_command(command: str) -&gt; list[str]:
-    issues = []
-    for pattern, message in VALIDATION_RULES:
-        if re.search(pattern, command):
-            issues.append(message)
-    return issues
-
-
-try:
-    input_data = json.load(sys.stdin)
-except json.JSONDecodeError as e:
-    print(f&#34;Error: Invalid JSON input: {e}&#34;, file=sys.stderr)
-    sys.exit(1)
-
-tool_name = input_data.get(&#34;tool_name&#34;, &#34;&#34;)
-tool_input = input_data.get(&#34;tool_input&#34;, {})
-command = tool_input.get(&#34;command&#34;, &#34;&#34;)
-
-if tool_name != &#34;Bash&#34; or not command:
-    sys.exit(1)
-
-# Validate the command
-issues = validate_command(command)
-
-if issues:
-    for message in issues:
-        print(f&#34;• {message}&#34;, file=sys.stderr)
-    # Exit code 2 blocks tool call and shows stderr to Claude
-    sys.exit(2)
-```
-
-#### JSON Output Example: UserPromptSubmit to Add Context and Validation
-
-&lt;Note&gt;
-  For `UserPromptSubmit` hooks, you can inject context using either method:
-
-  * **Plain text stdout** with exit code 0: Simplest approach, prints text
-  * **JSON output** with exit code 0: Use `&#34;decision&#34;: &#34;block&#34;` to reject prompts,
-    or `additionalContext` for structured context injection
-
-  Remember: Exit code 2 only uses `stderr` for the error message. To block using
-  JSON (with a custom reason), use `&#34;decision&#34;: &#34;block&#34;` with exit code 0.
-&lt;/Note&gt;
-
-```python  theme={null}
-#!/usr/bin/env python3
-import json
-import sys
-import re
-import datetime
-
-# Load input from stdin
-try:
-    input_data = json.load(sys.stdin)
-except json.JSONDecodeError as e:
-    print(f&#34;Error: Invalid JSON input: {e}&#34;, file=sys.stderr)
-    sys.exit(1)
-
-prompt = input_data.get(&#34;prompt&#34;, &#34;&#34;)
-
-# Check for sensitive patterns
-sensitive_patterns = [
-    (r&#34;(?i)\b(password|secret|key|token)\s*[:=]&#34;, &#34;Prompt contains potential secrets&#34;),
-]
-
-for pattern, message in sensitive_patterns:
-    if re.search(pattern, prompt):
-        # Use JSON output to block with a specific reason
-        output = {
-            &#34;decision&#34;: &#34;block&#34;,
-            &#34;reason&#34;: f&#34;Security policy violation: {message}. Please rephrase your request without sensitive information.&#34;
-        }
-        print(json.dumps(output))
-        sys.exit(0)
-
-# Add current time to context
-context = f&#34;Current time: {datetime.datetime.now()}&#34;
-print(context)
-
-&#34;&#34;&#34;
-The following is also equivalent:
-print(json.dumps({
-  &#34;hookSpecificOutput&#34;: {
-    &#34;hookEventName&#34;: &#34;UserPromptSubmit&#34;,
-    &#34;additionalContext&#34;: context,
-  },
-}))
-&#34;&#34;&#34;
-
-# Allow the prompt to proceed with the additional context
-sys.exit(0)
-```
-
-#### JSON Output Example: PreToolUse with Approval
-
-```python  theme={null}
-#!/usr/bin/env python3
-import json
-import sys
-
-# Load input from stdin
-try:
-    input_data = json.load(sys.stdin)
-except json.JSONDecodeError as e:
-    print(f&#34;Error: Invalid JSON input: {e}&#34;, file=sys.stderr)
-    sys.exit(1)
-
-tool_name = input_data.get(&#34;tool_name&#34;, &#34;&#34;)
-tool_input = input_data.get(&#34;tool_input&#34;, {})
-
-# Example: Auto-approve file reads for documentation files
-if tool_name == &#34;Read&#34;:
-    file_path = tool_input.get(&#34;file_path&#34;, &#34;&#34;)
-    if file_path.endswith((&#34;.md&#34;, &#34;.mdx&#34;, &#34;.txt&#34;, &#34;.json&#34;)):
-        # Use JSON output to auto-approve the tool call
-        output = {
-            &#34;decision&#34;: &#34;approve&#34;,
-            &#34;reason&#34;: &#34;Documentation file auto-approved&#34;,
-            &#34;suppressOutput&#34;: True  # Don&#39;t show in verbose mode
-        }
-        print(json.dumps(output))
-        sys.exit(0)
-
-# For other cases, let the normal permission flow proceed
-sys.exit(0)
-```
-
-## Working with MCP Tools
-
-Claude Code hooks work seamlessly with
-[Model Context Protocol (MCP) tools](/en/mcp). When MCP servers
-provide tools, they appear with a special naming pattern that you can match in
-your hooks.
-
-### MCP Tool Naming
-
-MCP tools follow the pattern `mcp__&lt;server&gt;__&lt;tool&gt;`, for example:
-
-* `mcp__memory__create_entities` - Memory server&#39;s create entities tool
-* `mcp__filesystem__read_file` - Filesystem server&#39;s read file tool
-* `mcp__github__search_repositories` - GitHub server&#39;s search tool
-
-### Configuring Hooks for MCP Tools
-
-You can target specific MCP tools or entire MCP servers:
+  &#34;reason&#34;: &#34;other&#34;
+}
+```
+
+SessionEnd hooks have no decision control. They cannot block session termination but can perform cleanup tasks.
+
+## Prompt-based hooks
+
+In addition to Bash command hooks (`type: &#34;command&#34;`), Claude Code supports prompt-based hooks (`type: &#34;prompt&#34;`) that use an LLM to evaluate whether to allow or block an action. Prompt-based hooks work with the following events: `PreToolUse`, `PostToolUse`, `PostToolUseFailure`, `PermissionRequest`, `UserPromptSubmit`, `Stop`, and `SubagentStop`.
+
+### How prompt-based hooks work
+
+Instead of executing a Bash command, prompt-based hooks:
+
+1. Send the hook input and your prompt to a Claude model, Haiku by default
+2. The LLM responds with structured JSON containing a decision
+3. Claude Code processes the decision automatically
+
+### Prompt hook configuration
+
+Set `type` to `&#34;prompt&#34;` and provide a `prompt` string instead of a `command`. Use the `$ARGUMENTS` placeholder to inject the hook&#39;s JSON input data into your prompt text. Claude Code sends the combined prompt and input to a fast Claude model, which returns a JSON decision.
+
+This `Stop` hook asks the LLM to evaluate whether all tasks are complete before allowing Claude to finish:
 
 ```json  theme={null}
 {
   &#34;hooks&#34;: {
-    &#34;PreToolUse&#34;: [
+    &#34;Stop&#34;: [
       {
-        &#34;matcher&#34;: &#34;mcp__memory__.*&#34;,
         &#34;hooks&#34;: [
           {
-            &#34;type&#34;: &#34;command&#34;,
-            &#34;command&#34;: &#34;echo &#39;Memory operation initiated&#39; &gt;&gt; ~/mcp-operations.log&#34;
-          }
-        ]
-      },
-      {
-        &#34;matcher&#34;: &#34;mcp__.*__write.*&#34;,
-        &#34;hooks&#34;: [
-          {
-            &#34;type&#34;: &#34;command&#34;,
-            &#34;command&#34;: &#34;/home/user/scripts/validate-mcp-write.py&#34;
+            &#34;type&#34;: &#34;prompt&#34;,
+            &#34;prompt&#34;: &#34;Evaluate if Claude should stop: $ARGUMENTS. Check if all tasks are complete.&#34;
           }
         ]
       }
@@ -1261,102 +1171,219 @@
 }
 ```
 
-## Examples
-
-&lt;Tip&gt;
-  For practical examples including code formatting, notifications, and file protection, see [More Examples](/en/hooks-guide#more-examples) in the get started guide.
-&lt;/Tip&gt;
-
-## Security Considerations
+| Field     | Required | Description                                                                                                                                                         |
+| :-------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
+| `type`    | yes      | Must be `&#34;prompt&#34;`                                                                                                                                                  |
+| `prompt`  | yes      | The prompt text to send to the LLM. Use `$ARGUMENTS` as a placeholder for the hook input JSON. If `$ARGUMENTS` is not present, input JSON is appended to the prompt |
+| `model`   | no       | Model to use for evaluation. Defaults to a fast model                                                                                                               |
+| `timeout` | no       | Timeout in seconds. Default: 30                                                                                                                                     |
+
+### Response schema
+
+The LLM must respond with JSON containing:
+
+```json  theme={null}
+{
+  &#34;ok&#34;: true | false,
+  &#34;reason&#34;: &#34;Explanation for the decision&#34;
+}
+```
+
+| Field    | Description                                                |
+| :------- | :--------------------------------------------------------- |
+| `ok`     | `true` allows the action, `false` prevents it              |
+| `reason` | Required when `ok` is `false`. Explanation shown to Claude |
+
+### Example: Multi-criteria Stop hook
+
+This `Stop` hook uses a detailed prompt to check three conditions before allowing Claude to stop. If `&#34;ok&#34;` is `false`, Claude continues working with the provided reason as its next instruction. `SubagentStop` hooks use the same format to evaluate whether a [subagent](/en/sub-agents) should stop:
+
+```json  theme={null}
+{
+  &#34;hooks&#34;: {
+    &#34;Stop&#34;: [
+      {
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;prompt&#34;,
+            &#34;prompt&#34;: &#34;You are evaluating whether Claude should stop working. Context: $ARGUMENTS\n\nAnalyze the conversation and determine if:\n1. All user-requested tasks are complete\n2. Any errors need to be addressed\n3. Follow-up work is needed\n\nRespond with JSON: {\&#34;ok\&#34;: true} to allow stopping, or {\&#34;ok\&#34;: false, \&#34;reason\&#34;: \&#34;your explanation\&#34;} to continue working.&#34;,
+            &#34;timeout&#34;: 30
+          }
+        ]
+      }
+    ]
+  }
+}
+```
+
+## Agent-based hooks
+
+Agent-based hooks (`type: &#34;agent&#34;`) are like prompt-based hooks but with multi-turn tool access. Instead of a single LLM call, an agent hook spawns a subagent that can read files, search code, and inspect the codebase to verify conditions. Agent hooks support the same events as prompt-based hooks.
+
+### How agent hooks work
+
+When an agent hook fires:
+
+1. Claude Code spawns a subagent with your prompt and the hook&#39;s JSON input
+2. The subagent can use tools like Read, Grep, and Glob to investigate
+3. After up to 50 turns, the subagent returns a structured `{ &#34;ok&#34;: true/false }` decision
+4. Claude Code processes the decision the same way as a prompt hook
+
+Agent hooks are useful when verification requires inspecting actual files or test output, not just evaluating the hook input data alone.
+
+### Agent hook configuration
+
+Set `type` to `&#34;agent&#34;` and provide a `prompt` string. The configuration fields are the same as [prompt hooks](#prompt-hook-configuration), with a longer default timeout:
+
+| Field     | Required | Description                                                                                 |
+| :-------- | :------- | :------------------------------------------------------------------------------------------ |
+| `type`    | yes      | Must be `&#34;agent&#34;`                                                                           |
+| `prompt`  | yes      | Prompt describing what to verify. Use `$ARGUMENTS` as a placeholder for the hook input JSON |
+| `model`   | no       | Model to use. Defaults to a fast model                                                      |
+| `timeout` | no       | Timeout in seconds. Default: 60                                                             |
+
+The response schema is the same as prompt hooks: `{ &#34;ok&#34;: true }` to allow or `{ &#34;ok&#34;: false, &#34;reason&#34;: &#34;...&#34; }` to block.
+
+This `Stop` hook verifies that all unit tests pass before allowing Claude to finish:
+
+```json  theme={null}
+{
+  &#34;hooks&#34;: {
+    &#34;Stop&#34;: [
+      {
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;agent&#34;,
+            &#34;prompt&#34;: &#34;Verify that all unit tests pass. Run the test suite and check the results. $ARGUMENTS&#34;,
+            &#34;timeout&#34;: 120
+          }
+        ]
+      }
+    ]
+  }
+}
+```
+
+## Run hooks in the background
+
+By default, hooks block Claude&#39;s execution until they complete. For long-running tasks like deployments, test suites, or external API calls, set `&#34;async&#34;: true` to run the hook in the background while Claude continues working. Async hooks cannot block or control Claude&#39;s behavior: response fields like `decision`, `permissionDecision`, and `continue` have no effect, because the action they would have controlled has already completed.
+
+### Configure an async hook
+
+Add `&#34;async&#34;: true` to a command hook&#39;s configuration to run it in the background without blocking Claude. This field is only available on `type: &#34;command&#34;` hooks.
+
+This hook runs a test script after every `Write` tool call. Claude continues working immediately while `run-tests.sh` executes for up to 120 seconds. When the script finishes, its output is delivered on the next conversation turn:
+
+```json  theme={null}
+{
+  &#34;hooks&#34;: {
+    &#34;PostToolUse&#34;: [
+      {
+        &#34;matcher&#34;: &#34;Write&#34;,
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;command&#34;,
+            &#34;command&#34;: &#34;/path/to/run-tests.sh&#34;,
+            &#34;async&#34;: true,
+            &#34;timeout&#34;: 120
+          }
+        ]
+      }
+    ]
+  }
+}
+```
+
+The `timeout` field sets the maximum time in seconds for the background process. If not specified, async hooks use the same 10-minute default as sync hooks.
+
+### How async hooks execute
+
+When an async hook fires, Claude Code starts the hook process and immediately continues without waiting for it to finish. The hook receives the same JSON input via stdin as a synchronous hook.
+
+After the background process exits, if the hook produced a JSON response with a `systemMessage` or `additionalContext` field, that content is delivered to Claude as context on the next conversation turn.
+
+### Example: run tests after file changes
+
+This hook starts a test suite in the background whenever Claude writes a file, then reports the results back to Claude when the tests finish. Save this script to `.claude/hooks/run-tests-async.sh` in your project and make it executable with `chmod +x`:
+
+```bash  theme={null}
+#!/bin/bash
+# run-tests-async.sh
+
+# Read hook input from stdin
+INPUT=$(cat)
+FILE_PATH=$(echo &#34;$INPUT&#34; | jq -r &#39;.tool_input.file_path // empty&#39;)
+
+# Only run tests for source files
+if [[ &#34;$FILE_PATH&#34; != *.ts &amp;&amp; &#34;$FILE_PATH&#34; != *.js ]]; then
+  exit 0
+fi
+
+# Run tests and report results via systemMessage
+RESULT=$(npm test 2&gt;&amp;1)
+EXIT_CODE=$?
+
+if [ $EXIT_CODE -eq 0 ]; then
+  echo &#34;{\&#34;systemMessage\&#34;: \&#34;Tests passed after editing $FILE_PATH\&#34;}&#34;
+else
+  echo &#34;{\&#34;systemMessage\&#34;: \&#34;Tests failed after editing $FILE_PATH: $RESULT\&#34;}&#34;
+fi
+```
+
+Then add this configuration to `.claude/settings.json` in your project root. The `async: true` flag lets Claude keep working while tests run:
+
+```json  theme={null}
+{
+  &#34;hooks&#34;: {
+    &#34;PostToolUse&#34;: [
+      {
+        &#34;matcher&#34;: &#34;Write|Edit&#34;,
+        &#34;hooks&#34;: [
+          {
+            &#34;type&#34;: &#34;command&#34;,
+            &#34;command&#34;: &#34;\&#34;$CLAUDE_PROJECT_DIR\&#34;/.claude/hooks/run-tests-async.sh&#34;,
+            &#34;async&#34;: true,
+            &#34;timeout&#34;: 300
+          }
+        ]
+      }
+    ]
+  }
+}
+```
+
+### Limitations
+
+Async hooks have several constraints compared to synchronous hooks:
+
+* Only `type: &#34;command&#34;` hooks support `async`. Prompt-based hooks cannot run asynchronously.
+* Async hooks cannot block tool calls or return decisions. By the time the hook completes, the triggering action has already proceeded.
+* Hook output is delivered on the next conversation turn. If the session is idle, the response waits until the next user interaction.
+* Each execution creates a separate background process. There is no deduplication across multiple firings of the same async hook.
+
+## Security considerations
 
 ### Disclaimer
 
-**USE AT YOUR OWN RISK**: Claude Code hooks execute arbitrary shell commands on
-your system automatically. By using hooks, you acknowledge that:
-
-* You are solely responsible for the commands you configure
-* Hooks can modify, delete, or access any files your user account can access
-* Malicious or poorly written hooks can cause data loss or system damage
-* Anthropic provides no warranty and assumes no liability for any damages
-  resulting from hook usage
-* You should thoroughly test hooks in a safe environment before production use
-
-Always review and understand any hook commands before adding them to your
-configuration.
-
-### Security Best Practices
-
-Here are some key practices for writing more secure hooks:
-
-1. **Validate and sanitize inputs** - Never trust input data blindly
-2. **Always quote shell variables** - Use `&#34;$VAR&#34;` not `$VAR`
-3. **Block path traversal** - Check for `..` in file paths
-4. **Use absolute paths** - Specify full paths for scripts (use
-   &#34;\$CLAUDE\_PROJECT\_DIR&#34; for the project path)
-5. **Skip sensitive files** - Avoid `.env`, `.git/`, keys, etc.
-
-### Configuration Safety
-
-Direct edits to hooks in settings files don&#39;t take effect immediately. Claude
-Code:
-
-1. Captures a snapshot of hooks at startup
-2. Uses this snapshot throughout the session
-3. Warns if hooks are modified externally
-4. Requires review in `/hooks` menu for changes to apply
-
-This prevents malicious hook modifications from affecting your current session.
-
-## Hook Execution Details
-
-* **Timeout**: 60-second execution limit by default, configurable per command.
-  * A timeout for an individual command does not affect the other commands.
-* **Parallelization**: All matching hooks run in parallel
-* **Deduplication**: Multiple identical hook commands are deduplicated automatically
-* **Environment**: Runs in current directory with Claude Code&#39;s environment
-  * The `CLAUDE_PROJECT_DIR` environment variable is available and contains the
-    absolute path to the project root directory (where Claude Code was started)
-  * The `CLAUDE_CODE_REMOTE` environment variable indicates whether the hook is running in a remote (web) environment (`&#34;true&#34;`) or local CLI environment (not set or empty). Use this to run different logic based on execution context.
-* **Input**: JSON via stdin
-* **Output**:
-  * PreToolUse/PermissionRequest/PostToolUse/Stop/SubagentStop: Progress shown in verbose mode (ctrl+o)
-  * Notification/SessionEnd: Logged to debug only (`--debug`)
-  * UserPromptSubmit/SessionStart/Setup: stdout added as context for Claude
-
-## Debugging
-
-### Basic Troubleshooting
-
-If your hooks aren&#39;t working:
-
-1. **Check configuration** - Run `/hooks` to see if your hook is registered
-2. **Verify syntax** - Ensure your JSON settings are valid
-3. **Test commands** - Run hook commands manually first
-4. **Check permissions** - Make sure scripts are executable
-5. **Review logs** - Use `claude --debug` to see hook execution details
-
-Common issues:
-
-* **Quotes not escaped** - Use `\&#34;` inside JSON strings
-* **Wrong matcher** - Check tool names match exactly (case-sensitive)
-* **Command not found** - Use full paths for scripts
-
-### Advanced Debugging
-
-For complex hook issues:
-
-1. **Inspect hook execution** - Use `claude --debug` to see detailed hook
-   execution
-2. **Validate JSON schemas** - Test hook input/output with external tools
-3. **Check environment variables** - Verify Claude Code&#39;s environment is correct
-4. **Test edge cases** - Try hooks with unusual file paths or inputs
-5. **Monitor system resources** - Check for resource exhaustion during hook
-   execution
-6. **Use structured logging** - Implement logging in your hook scripts
-
-### Debug Output Example
-
-Use `claude --debug` to see hook execution details:
+Hooks run with your system user&#39;s full permissions.
+
+&lt;Warning&gt;
+  Hooks execute shell commands with your full user permissions. They can modify, delete, or access any files your user account can access. Review and test all hook commands before adding them to your configuration.
+&lt;/Warning&gt;
+
+### Security best practices
+
+Keep these practices in mind when writing hooks:
+
+* **Validate and sanitize inputs**: never trust input data blindly
+* **Always quote shell variables**: use `&#34;$VAR&#34;` not `$VAR`
+* **Block path traversal**: check for `..` in file paths
+* **Use absolute paths**: specify full paths for scripts, using `&#34;$CLAUDE_PROJECT_DIR&#34;` for the project root
+* **Skip sensitive files**: avoid `.env`, `.git/`, keys, etc.
+
+## Debug hooks
+
+Run `claude --debug` to see hook execution details, including which hooks matched, their exit codes, and output. Toggle verbose mode with `Ctrl+O` to see hook progress in the transcript.
 
 ```
 [DEBUG] Executing hooks for PostToolUse:Write
@@ -1364,13 +1391,8 @@
 [DEBUG] Found 1 hook matchers in settings
 [DEBUG] Matched 1 hooks for query &#34;Write&#34;
 [DEBUG] Found 1 hook commands to execute
-[DEBUG] Executing hook command: &lt;Your command&gt; with timeout 60000ms
+[DEBUG] Executing hook command: &lt;Your command&gt; with timeout 600000ms
 [DEBUG] Hook command completed with status 0: &lt;Your stdout&gt;
 ```
 
-Progress messages appear in verbose mode (ctrl+o) showing:
-
-* Which hook is running
-* Command being executed
-* Success/failure status
-* Output or error messages
+For troubleshooting common issues like hooks not firing, infinite Stop hook loops, or configuration errors, see [Limitations and troubleshooting](/en/hooks-guide#limitations-and-troubleshooting) in the guide.
</code></pre>
    </div>
</body>
</html>